// 소요시간: 42분

/*

시간 : 50개 테스트케이스를 합쳐서 C의 경우 5초 / C++의 경우 5초 / Java의 경우 5초 / Python의 경우 10초
메모리 : 힙, 정적 메모리 합쳐서 256MB 이내, 스택 메모리 1MB 이내
※ SW Expert 아카데미의 문제를 무단 복제하는 것을 금지합니다.


엔지니어링 선표는 일을 하던 도중 창고에서 특이한 자석이 놓여있는 판을 발견했다.
이 판에는 4개의 자석이 놓여져 있었고, 각 자석은 8개의 ‘날’(튀어나온 곳)를 가지고 있다.
자석의 각 날 마다 N 극 또는 S 극의 자성을 가지고 있다.
이 특이한 자석은 [Fig. 1] 과 같이 1 번부터 4 번까지 판에 일렬로 배치되어 있고,
빨간색 화살표 위치에 날 하나가 오도록 배치되어 있다.
                   
[Fig. 1]

심심한 선표는 이 특이한 자석을 가지고 놀아보니 신기한 규칙을 발견했다.
임의의 자석을 1 칸씩 K 번 회전시키려고 해보니, 하나의 자석이 1 칸 회전될 때, 
붙어 있는 자석은 서로 붙어 있는 날의 자성과 다를 경우에만 인력에 의해 반대 방향으로 1 칸 회전된다.

이를 신기하게 생각한 선표는 무작위로 자석을 돌렸을 때,
모든 회전이 끝난 후, 아래와 같은 방법으로 점수를 계산을 하고자 한다.

- 1 번 자석에서 빨간색 화살표 위치에 있는 날의 자성이 N 극이면 0 점, S 극이면 1 점을 획득한다.
- 2 번 자석에서 빨간색 화살표 위치에 있는 날의 자성이 N 극이면 0 점, S 극이면 2 점을 획득한다.
- 3 번 자석에서 빨간색 화살표 위치에 있는 날의 자성이 N 극이면 0 점, S 극이면 4 점을 획득한다.
- 4 번 자석에서 빨간색 화살표 위치에 있는 날의 자성이 N 극이면 0 점, S 극이면 8 점을 획득한다.


4 개 자석의 자성 정보와 자석을 1 칸씩 K 번 회전시키려고 할 때,
K 번 자석을 회전시킨 후 획득하는 점수의 총 합을 출력하는 프로그램을 작성하라.

 

[예시]

[Fig. 1] 과 같이 자석의 자성 정보가 주어지고, 아래의 순서와 같이 자석을 1 칸씩 2 번 회전시키는 경우를 생각해보자.
① 1 번 자석을 시계방향으로 회전
② 3 번 자석을 반시계 방향으로 회전


[Fig. 2-1] 에서 1 번 자석을 시계방향으로 1 칸 회전시키면,
2 번 자석은 1 번 자석과 서로 붙어 있는 날의 자성이 달라 반시계 방향으로 1 칸 회전된다.
이 때, 3 번 자석은 2 번 자석과 서로 붙어 있는 날의 자성이 N 극으로 같아서 회전되지 않는다.
3 번 자석이 회전되지 않기 때문에 4 번 자석도 회전되지 않는다.

[Fig. 2-1]
                      
[Fig. 2-1] 의 회전 결과는 [Fig. 2-2] 이다.

[Fig. 2-2]
                      
[Fig. 2-2] 에서 3 번 자석을 반시계 방향으로 1 칸 회전시키면, [Fig. 3-1] 과 같이 자석들이 회전하게 된다.

[Fig. 3-1]
                      
[Fig. 3-1] 의 회전 결과는 [Fig. 3-2] 이다.

[Fig. 3-2]
                      
 

모든 자석의 회전이 끝난 후 획득하는 점수는 0 + 2 + 0 + 8 = 10 이 된다.
따라서, 이 예제의 정답은 10 이다.

 

[제약사항]

1. 시간제한 : 최대 50 개 테스트 케이스를 모두 통과하는 데 C / C++ / Java 모두 3 초
2. 자석의 개수는 4 개이며, 각 자석은 8 개의 날을 가지고 있다.
3. 자석을 회전시키는 횟수 K 는 1 이상 20 이하의 정수이다. ( 1 ≤ K ≤ 20 )
4. 하나의 자석이 1 칸 회전될 때, 붙어 있는 자석은 서로 붙어 있는 날의 자성이 다를 경우에만 반대 방향으로 1 칸 회전된다.
5. 자석을 회전시키는 방향은 시계방향이 1 로, 반시계 방향이 -1 로 주어진다.
6. 날의 자성은 N 극이 0 으로, S 극이 1 로 주어진다.
7. 각 자석의 날 자성정보는 빨간색 화살표 위치의 날부터 시계방향 순서대로 주어진다.

  예를 들어, [Fig. 1] 의 1 번 자석의 자성정보는 0 0 1 0 0 1 0 0 과 같이 주어진다.

 

[입력]

입력의 맨 첫 줄에는 총 테스트 케이스의 개수 T 가 주어지고,
그 다음 줄부터 T 개의 테스트 케이스가 주어진다.
각 테스트 케이스의 첫 번째 줄에는 자석을 회전시키는 횟수 K 가 주어진다.
다음 4 개의 줄에는 1 번 자석부터 4 번 자석까지 각각 8 개 날의 자성정보가 차례대로 주어진다.
그 다음 K 개의 줄에는 자석을 1 칸씩 회전시키는 회전 정보가 주어진다.
자석의 회전 정보는 회전시키려는 자석의 번호, 회전방향으로 구성되어 있다.
회전방향은 1 일 경우 시계방향이며, -1 일 경우 반시계방향이다.
 

[출력]

테스트 케이스 개수만큼 T 개의 줄에 각각의 테스트 케이스에 대한 답을 출력한다.
각 줄은 "#t" 로 시작하고 공백을 하나 둔 다음 정답을 출력한다. ( t 는 1 부터 시작하는 테스트 케이스의 번호이다. )
정답은 모든 자석의 회전이 끝난 후 획득한 점수의 총 합이다.



입력
10		// 총 테스트 케이스의 개수 T = 10
2		// 첫 번째 테스트 케이스, K = 2, 본문 예제
0 0 1 0 0 1 0 0
1 0 0 1 1 1 0 1
0 0 1 0 1 1 0 0
0 0 1 0 1 1 0 1
1 1
3 -1
...		// 나머지는 sample_input.txt 참조


출력
#1 10
#2 14
#3 3
#4 13
#5 15
#6 10
#7 2
#8 6
#9 5
#10 4

*/

/*

배열을 반시계 방향, 시계 방향으로 옮기는 방법을 알고 있다면
주어진 규칙을 그대로 적용만 하면 되므로 구현이 어렵지 않은 시뮬레이션 문제.

자석에서 회전을 하기 전에 확인하는 위치는 항상 자신의 왼쪽, 오른쪽 날의 자성이다.
(0부터 시작하는 인덱스를 사용하면 왼쪽은 6번, 오른쪽은 2번이 된다.)
그리고 서로 붙어 있는 자석과의 회전은 회전하기 전의 자성 정보에 의해 일어나므로,
항상 회전 전에 왼쪽과 오른쪽의 자성 정보를 저장한 후 회전을 해야 한다.

또한, 회전을 처음 시작하는 자석은 왼쪽과 오른쪽 둘다 확인해야 하지만,
이후 그 자석에 의해 연쇄적으로 일어나는 회전에서는 왼쪽만 보거나, 오른쪽만 봐야함을 잊으면 안된다.
(실제로 이 부분을 빠뜨려서 잠깐 방황을 했었다...ㅎㅋㅋ)

예를 들어 3번 자석이 회전을 시작할 때, 3번 자석의 왼쪽 날과 2번 자석의 오른쪽 날의 자성이 다른 경우,
3번 자석뿐만 아니라 2번 자석도 회전을 해야 하는데,
이때 2번 자석은 1번 자석에 영향을 주는지만 확인해야 하며 3번 자석은 볼 필요가 없다.

따라서 나는 이 부분을 해결해주기 위해 초기 자석의 범위를 0(양쪽)으로 설정한 다음
이후 자신의 왼쪽이 회전되어야 한다면 자석의 범위를 -1(왼쪽)로 설정하여 왼쪽만 보게하고,
오른쪽이 회전되어야 한다면 1(오른쪽)로 설정하여 오른쪽만 보게했다.

그리고 회전은 항상 이전과 반대로 일어나야 하는 것도 잊지 말자!!

*/

#include<iostream>
#include<cstdio>
#include<cstring>

using namespace std;

const int MAX = 10;

int K;
int magnet[MAX][MAX];
int score[5] = {0, 1, 2, 4, 8};

void rotate(int x, int dir) {
    if(dir == -1) { // 반시계 방향
        int temp = magnet[x][0];
        for(int i=0; i<7; i++) magnet[x][i] = magnet[x][i+1];
        magnet[x][7] = temp;
    }
    else { // 시계 방향
        int temp = magnet[x][7];
        for(int i=7; i>0; i--) magnet[x][i] = magnet[x][i-1];
        magnet[x][0] = temp;
    }
}

void check(int x, int dir, int range) {
    int left = magnet[x][6], right = magnet[x][2];
    rotate(x, dir);
    
    if(range <= 0 && x > 1 && left != magnet[x-1][2]) {
        check(x-1, dir == 1 ? -1 : 1, -1);
    }
    
    if(range >= 0 && x < 4 && right != magnet[x+1][6]) {
        check(x+1, dir == 1 ? -1 : 1, 1);
    }
}

int getScore() {
    int sum = 0;
    for(int i=1; i<=4; i++) {
        sum += magnet[i][0] * score[i];
    }
    
    return sum;
}

int main(int argc, char** argv)
{
    int test_case;
    int T;

    cin>>T;

    for(test_case = 1; test_case <= T; ++test_case)
    {
        scanf("%d", &K);
        for(int i=1; i<=4; i++) {
            for(int j=0; j<8; j++) {
                scanf("%d", &magnet[i][j]);
            }
        }

        for(int i=0; i<K; i++) {
            int mNum, dir;
            scanf("%d %d", &mNum, &dir);
            
            check(mNum, dir, 0);
        }
        
        printf("#%d %d\n", test_case, getScore());
    }
    return 0;//정상종료시 반드시 0을 리턴해야합니다.
}