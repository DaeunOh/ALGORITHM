// 소요시간: 1시간 10분
// 실행시간: 2735ms

/*

시간 : 50개 테스트케이스를 합쳐서 C의 경우 3초 / C++의 경우 3초 / Java의 경우 3초 / Python의 경우 15초
메모리 : 힙, 정적 메모리 합쳐서 256MB 이내, 스택 메모리 1MB 이내
※ SW Expert 아카데미의 문제를 무단 복제하는 것을 금지합니다.

 

원자력 발전소에서 근무하는 상원이는, 발전소에서 발생하는 에너지를 미리 계산하기 위해 
원자들의 움직임을 시뮬레이션 하는 프로그램을 만들려고 한다.

원자들은 2차원 평면에서 이동하며 
두 개 이상의 원자가 충돌 할 경우 충돌한 원자들은 각자 보유한 에너지를 모두 방출하고 소멸된다.

원자의 움직임은 다음과 같다.
 

1. 원자의 최초 위치는 2차원 평면상의 [x, y] 이다.
2. 원자는 각자 고유의 움직이는 방향을 가지고 있다. (상하좌우 4방향)
 - 상: y 가 증가하는 방향
 - 하: y 가 감소하는 방향
 - 좌: x 가 감소하는 방향
 - 우: x 가 증가하는 방향
3. 모든 원자들의 이동속도는 동일하다. 즉, 1초에 1만큼의 거리를 이동한다.
4. 모든 원자들은 최초 위치에서 동시에 이동을 시작한다.
5. 두 개 이상의 원자가 동시에 충돌 할 경우 충돌한 원자들은 모두 보유한 에너지를 방출하고 소멸된다.
           
                                    [그림-1]


[그림-1] 과 같이 원자들의 [x, y] 위치와 이동방향이 주어지고 각 원자들의 보유 에너지가 1 이라고 가정해보자. 
(실제 입력에서 원자들의 보유 에너지는 각각 다를 수 있다.)

충돌된 원자들이 소멸하면서 방출하는 에너지는 다음과 같다.

1초 후에 I, J 원자가 충돌 후 소멸하면서 2 에너지 방출
1.5초 후에 A, B 원자가 충돌 후 소멸하면서 2 에너지 방출
2초 후에 D, E, G, H 원자가 충돌 후 소멸하면서 4 에너지 방출
3초 후에 M, N 원자가 충돌 후 소멸하면서 2 에너지 방출
[그림-1]의 경우 시간이 흘러도 원자 C, F, K, L 은 영원히 충돌하지 않아 소멸되지 않는다.

따라서 원자들이 소멸되면서 방출하는 에너지의 총합은 10 이다.


N 개의 원자들의 [x, y] 위치, 이동 방향, 보유 에너지가 주어질 때 
원자들이 소멸되면서 방출하는 에너지의 총합을 구하는 프로그램을 작성하라.

 

[제약 사항]
 

1. 원자들의 수 N 은 1,000개 이하이다. (1≤N≤1,000)
2. 각 원자들의 보유 에너지 K 는 1 이상 100 이하이다. (1≤K≤100)
3. 원자들의 처음 위치 [x, y] 는 -1,000 이상 1,000 이하의 정수로 주어진다. (-1,000≤x,y≤1,000)
4. 원자들은 2차원 평면 위에서 움직이며 원자들이 움직일 수 있는 좌표의 범위에 제한은 없다.
5. 원자들의 이동 방향은 상(0), 하(1), 좌(2), 우(3)로 주어진다.
6. 원자들은 동시에 1초에 이동 방향으로 1만큼 이동한다.
7. 원자들의 최초 위치는 서로 중복되지 않는다.
8. 원자들은 2개 이상의 원자들이 서로 충돌할 경우 보유한 에너지를 방출하면서 바로 소멸된다.
9. 원자들은 이동 방향은 처음에 주어진 방향에서 바뀌지 않는다.
10. 원자들이 충돌하여 소멸되며 방출되는 에너지는 다른 원자의 위치나 이동 방향에 영향을 주지 않는다.

 

[입력]
 

입력의 가장 첫 줄에는 총 테스트 케이스의 개수 T가 주어진다.
그 다음 줄부터는 각 테스트 케이스가 주어진다. 각 테스트 케이스의 첫째 줄에는 원자들의 수 N이 주어진다.
다음 N개의 줄에는 원자들의 x 위치, y 위치, 이동 방향, 보유 에너지 K가 주어진다.
원자들의 이동 방향은 상(0), 하(1), 좌(2), 우(3)로 주어진다.

 

[출력]
 

테스트 케이스 T에 대한 결과는 “#T”을 찍고, 방출되는 에너지의 총합을 출력한다. 
(T는 테스트케이스의 번호를 의미하며 1부터 시작한다. )


입력
2
4
-1000 0 3 5
1000 0 2 3
0 1000 1 7
0 -1000 0 9
4
-1 1 3 3
0 1 1 1
0 0 2 2
-1 0 0 9	 
...


출력
#1 24
#2 0
#3 10

*/

/*

N개의 원자를 자신의 방향으로 이동시키며, 충돌하는 원자가 있을 때 그 원자들의 에너지만큼 방출시키는 시뮬레이션 문제.

원자들은 1초에 1만큼 이동하지만, 충돌은 0.5초 단위로 가능하므로 좌표를 2배 늘리는 것이 좋다.
또한, 좌표에 대한 visited 배열을 사용하기 위해서는 음수 인덱스가 존재하면 안되므로
좌표를 +2000 하여 원자들을 가운데로 옮겨줘야 한다.
(-1,000 <= x, y <= 1,000  ----------> 0 <= x, y <= 4000)

좌표를 설정하는 것이 끝났다면, 모든 원자가 에너지를 방출할 때까지 또는 범위를 벗어날 때까지 원자를 이동시켜야 한다.
원자를 이동시키면서 충돌을 체크하는 방법은 다음과 같다

1) 원자의 방향에 따라 nextY, nextX를 구한다.
2) nextY, nextX의 범위가 정해진 좌표 바운더리를 넘어가면 cnt(소멸 또는 벗어난 원자 개수)를 증가시킨다.
3) 만약 해당 자리에 다른 원자가 없다면 visited 배열을 자신의 인덱스로 표기해두고 넘어간다.
4) 하지만 해당 자리에 다른 원자가 있다면 그 원자들에 해당하는 방출 에너지를 증가시켜 주고,
    소멸된 원자 개수만큼 cnt를 증가시킨다.
5) 이 반복문은 cnt가 N이 될 때까지 반복한다.

정확한 좌표 설정과 소멸되거나 범위를 벗어난 원자들 설정만 잘 한다면 구현 방법은 어렵지 않다.
그래서 구현은 금방 할 수 있었으나...... 아무리 봐도 맞고, 시간 초과가 날 부분이 없는 것 같은데 자꾸 시간초과가 났다...

계속 여러 개의 테스트 케이스를 만드는 과정을 반복하다가
예전에 벡터가 배열보다 느리다는 말이 생각나서 원자를 관리하기 위해 사용했던 벡터를 배열로 바꿔 제출했더니
시간초과가 사라졌다 ^_^;;;;

웬만한 경우에는 배열로 다 커버가 가능하니... 벡터는... 정말 필요한 경우가 아니면 안 쓰는게 좋은 것 같다 ^^..!!
그래도 벡터로 인한 시간초과는 앞으로 다시는 나지 않을 것 같아서 행복하다 ㅎㅎㅎㅎ~

*/

#include<iostream>
#include<cstdio>
#include<vector>
#include<cstring>

using namespace std;

const int MAX = 4000 + 10;

int N;
int visited[MAX][MAX];
int E;
vector < pair<int, int> > rem;

int dx[4] = {0, 0, -1, 1};
int dy[4] = {1, -1, 0, 0};

struct ATOM {
    int x, y, d, k;
    
    void createATOM(int _x, int _y, int _d, int _k) {
        x = _x;
        y = _y;
        d = _d;
        k = _k;
    }
};

ATOM A[1010];

void solution() {
    int cnt = 0;
    
    while(N != cnt) {
        rem.clear();
        
        for(int i=0; i<N; i++) {
            if(A[i].d == -1) continue; // 소멸 또는 범위에서 벗어난 원자
            
            int nx = A[i].x + dx[A[i].d];
            int ny = A[i].y + dy[A[i].d];
            
            if(nx < 0 || nx > 4000 || ny < 0 || ny > 4000) { // 범위에서 벗어난 경우
                A[i].d = -1;
                cnt++;
            }
            else if(visited[nx][ny] == -1) {
                rem.push_back(make_pair(nx, ny)); // visited 배열을 초기화 할 위치
                visited[nx][ny] = i;
            }
            else { // 다른 원자가 해당 위치에 있는 경우
                A[i].d = -1;
                E += A[i].k;
                cnt++;
                
                if(A[visited[nx][ny]].d != -1) { // 기존에 있던 원자도 지워준다.
                    A[visited[nx][ny]].d = -1;
                    E += A[visited[nx][ny]].k;
                    cnt++;
                }
            }
            
            A[i].x = nx;
            A[i].y = ny;
        }
        
        for(int i=0; i<rem.size(); i++) visited[rem[i].first][rem[i].second] = -1;
    }
}

int main(int argc, char** argv)
{
int test_case;
int T;
    
cin>>T;
    
for(test_case = 1; test_case <= T; ++test_case)
{
        E = 0;
        memset(visited, -1, sizeof(visited));
        
        scanf("%d", &N);
        for(int i=0; i<N; i++) {
            int x, y, d, k;
            scanf("%d %d %d %d", &x, &y, &d, &k);
            
            ATOM a;
            a.createATOM(x*2 + 2000, y*2 + 2000, d, k);
            A[i] = a;
        }
        
        solution();
        
        printf("#%d %d\n", test_case, E);
}
return 0;//정상종료시 반드시 0을 리턴해야합니다.
}