/*

시간 : 50개 테스트케이스를 합쳐서 C의 경우 3초 / C++의 경우 3초 / Java의 경우 3초 / Python의 경우 15초
메모리 : 힙, 정적 메모리 합쳐서 256MB 이내, 스택 메모리 1MB 이내
※ SW Expert 아카데미의 문제를 무단 복제하는 것을 금지합니다.


N*N 크기의 정사각형 모양의 방에 사람들이 앉아 있다.

점심을 먹기 위해 아래 층으로 내려가야 하는데, 밥을 빨리 먹기 위해 최대한 빠른 시간 내에 내려가야 한다.

방 안의 사람들은 P로, 계단 입구를 S라고 했을 때 [Fig. 1]은 사람의 위치와 계단 입구의 위치를 표시한 모습이다.

[Fig. 1]
 

이동 완료 시간은 모든 사람들이 계단을 내려가 아래 층으로 이동을 완료한 시간이다.

사람들이 아래층으로 이동하는 시간은 계단 입구까지 이동 시간과 계단을 내려가는 시간이 포함된다.

    ① 계단 입구까지 이동 시간
        - 사람이 현재 위치에서 계단의 입구까지 이동하는데 걸리는 시간으로 다음과 같이 계산한다.
        - 이동 시간(분) = | PR - SR | + | PC - SC |
          (PR, PC : 사람 P의 세로위치, 가로위치, SR, SC : 계단 입구 S의 세로위치, 가로위치)

    ② 계단을 내려가는 시간
        - 계단을 내려가는 시간은 계단 입구에 도착한 후부터 계단을 완전히 내려갈 때까지의 시간이다.
        - 계단 입구에 도착하면, 1분 후 아래칸으로 내려 갈 수 있다.
        - 계단 위에는 동시에 최대 3명까지만 올라가 있을 수 있다.
        - 이미 계단을 3명이 내려가고 있는 경우, 그 중 한 명이 계단을 완전히 내려갈 때까지 계단 입구에서 대기해야 한다.
        - 계단마다 길이 K가 주어지며, 계단에 올라간 후 완전히 내려가는데 K 분이 걸린다.

사람의 위치와 계단 입구의 위치 및 계단의 길이 정보가 표시된 N*N 크기의 지도가 주어진다.

이때, 모든 사람들이 계단을 내려가 이동이 완료되는 시간이 최소가 되는 경우를 찾고,

그 때의 소요시간을 출력하는 프로그램을 작성하라.


[예시]

방의 한 변의 길이 N 이 5인 지도가 [Fig. 2]와 같이 주어진 경우를 생각해보자.

지도 내에 1 은 사람을 나타내고, 2 이상 10 이하의 숫자는 계단의 입구를 나타내며 해당 숫자는 계단의 길이를 의미한다.

[Fig. 2]에는 사람 6명이 있고, 계단은 2개가 있으며 길이는 각각 3과 5이다.
 

[Fig. 2]


다음은 이동 완료되는 시간이 최소가 되는 경우 중 하나이다.

    - 1번, 2번, 3번 사람은 길이가 3인 1번 계단을 통해 이동

    - 4번, 5번, 6번 사람은 길이가 5인 2번 계단을 통해 이동

[표. 1]


이 경우, 모든 사람이 계단을 내려가 이동 완료하는 최소 시간은 9분이다.

다른 예시로, 한 변의 길이가 N인 방에 [Fig. 3]과 같이 배치되어 있는 경우를 생각해보자.

지도 내에 1 은 사람을 나타내고, 2 이상 10 이하의 숫자는 계단의 입구를 나타내며 해당 숫자는 계단의 길이를 의미한다.

 

[Fig. 3]

 
다음은 이동이 완료되는 시간이 최소가 되는 경우 중 하나이다.

    - 1번, 2번, 3번, 4번 사람은 길이가 2인 1번 계단을 통해 이동

    - 5번, 6번 사람은 길이가 5인 2번 계단을 통해 이동

[표. 2]


이 경우, 모든 사람이 계단을 내려가 이동 완료하는 최소 시간은 8분이다.


[제약 사항]

1. 시간제한 : 최대 50개 테스트 케이스를 모두 통과하는데, C/C++/Java 모두 3초

2. 방의 한 변의 길이 N은 4 이상 10 이하의 정수이다. (4 ≤ N ≤ 10)

3. 사람의 수는 1 이상 10 이하의 정수이다. (1 ≤ 사람의 수 ≤ 10)

4. 계단의 입구는 반드시 2개이며, 서로 위치가 겹치지 않는다.

5. 계단의 길이는 2 이상 10 이하의 정수이다. (2 ≤ 계단의 길이 ≤ 10)

6. 초기에 입력으로 주어지는 사람의 위치와 계단 입구의 위치는 서로 겹치지 않는다.


[입력]

입력의 맨 첫 줄에는 총 테스트 케이스의 개수 T가 주어지고, 그 다음 줄부터 T개의 테스트 케이스가 주어진다.

각 테스트 케이스의 첫 번째 줄에는 방의 한 변의 길이 N이 주어진다.

다음 N줄에는 N*N 크기의 지도의 정보가 주어진다.

지도에서 1은 사람을, 2 이상은 계단의 입구를 나타내며 그 값은 계단의 길이를 의미한다.


[출력]

테스트 케이스의 개수만큼 T줄에 T개의 테스트 케이스 각각에 대한 답을 출력한다.

각 줄은 "#x"로 시작하고 공백을 하나 둔 다음 정답을 출력한다. (x는 1부터 시작하는 테스트 케이스의 번호이다)

정답은 이동이 완료되는 최소의 시간을 출력한다.

입력
10	// 총 테스트 케이스 개수 T=10
5	// 첫 번째 테스트 케이스
0 1 1 0 0
0 0 1 0 3
0 1 0 1 0
0 0 0 0 0
1 0 5 0 0
5	// 두 번째 테스트 케이스
0 0 1 1 0
0 0 1 0 2
0 0 0 1 0
0 1 0 0 0
1 0 5 0 0
…	// 나머지는 점심 식사시간.txt 참조

출력
#1 9
#2 8
#3 9
#4 7
#5 8
#6 8
#7 11
#8 11
#9 18
#10 12

*/

/*

한 사람당 1번 계단과 2번 계단 중 어느 계단으로 갈건지 조합을 짜고,
그 조합에 맞춰 거리를 계산 후, 계단에 도착할 때까지 거리를 1씩 감소시키는 방식으로 시작한다.

처음 문제를 이해할 때는 "계단 입구에 도착하면, 1분 후 아래칸으로 내려 갈 수 있다."라는 규칙 때문에 시간 계산이 어려웠다.
이후 규칙을 이해하고 나서는 시뮬레이션 문제의 성격에 맞춰 주어진 규칙대로 설계하고 구현했지만,
한 반복문 안에 짜려니 어느 시점에 계단을 내려가야 하는지 조건문을 설정하기가 어려웠다.
그래서 예시를 들어가며 다시 설계를 시도했고, 이때는 조건문과 예시와 딱 맞아 떨어지는듯 했다.

하지만, 같은 시간대에 정원이 3이었던 계단이 0이 되는 순간이 있을 때,
계단에 대기하고 있던 사람이 앞 순번에 있었다면 계단을 내려갈 수 있게 되었더라도
내려가지 못하는 경우를 처리하지 않고 있었다.

이와 같은 문제를 해결하기 위해, 계단을 내려가고 있는 사람들은 먼저 처리하고,
이후 계단까지 가고 있거나, 계단에 도착한 사람들을 처리했더니 문제를 해결할 수 있었다. ㅠㅠ

*/

#include<iostream>
#include<cstdio>
#include<vector>
#include<cstring>

using namespace std;

const int MAX = 10 + 10;

int N;
int map[MAX][MAX];
vector<pair<int, int>> S;

int stair[2];

int comb[MAX];
int myMin;

struct PERSON {
    int y, x, d, k;
    
    void create(int Y, int X, int D, int K) {
        y = Y;
        x = X;
        d = D;
        k = K;
    }
};

vector<PERSON> P;

int getAbs(int x) {
    if(x > 0) return x;
    else return -x;
}

int getResult() {
    int cnt = 0;
    while(1) {
        cnt++;
        for(int i=0; i<P.size(); i++) {
            if(P[i].d >= 0) continue;
            
            // 계단 내려가는 중일 때
            if(P[i].k > 0) P[i].k--; // 내려갈 계단이 남아있다면
            else if(P[i].k == 0) { // 내려간 계단이 최하층이라면
                stair[comb[i]]--;
                P[i].k = -1;
            }
        }
        
        for(int i=0; i<P.size(); i++) {
            if(P[i].d == -1) continue;
            
            // 계단까지 가고 있거나, 계단에 도착한 경우
            if(P[i].d > 0) P[i].d--; // 계단에 도착하지 못한 경우
            else if(P[i].d == 0 && stair[comb[i]] < 3) { // 계단에 도착해 있을 때 대기가 없는 경우에는 입장
                P[i].d = -1;
                stair[comb[i]]++;
                P[i].k = map[S[comb[i]].first][S[comb[i]].second] - 1;
            }
        }
        
        bool flag = false;
        for(int i=0; i<P.size(); i++) {
            if(P[i].k != -1) {
                flag = true;
                break;
            }
        }
        
        if(!flag) return cnt;
    }
}

void getDistance() {
    for(int i=0; i<P.size(); i++) {
        int d = getAbs(P[i].y - S[comb[i]].first) + getAbs(P[i].x - S[comb[i]].second);
        P[i].d = d;
        P[i].k = 0;
    }
}

void getComb(int x) {
    if(x >= P.size()) {
        getDistance();
        
        int res = getResult();
        
        if(res < myMin) myMin = res;
    }
    else {
        for(int i=0; i<2; i++) {
            comb[x] = i;
            getComb(x + 1);
        }
    }
}

int main(int argc, char** argv)
{
    int test_case;
    int T;

    cin>>T;

    for(test_case = 1; test_case <= T; ++test_case)
    {
        P.clear();
        S.clear();
        memset(stair, 0, sizeof(stair));
        myMin = 987987987;
        scanf("%d", &N);
        
        for(int i=1; i<=N; i++) {
            for(int j=1; j<=N; j++) {
                scanf("%d", &map[i][j]);
                
                if(map[i][j] == 1) {
                    PERSON p;
                    p.create(i, j, 0, 0);
                    P.push_back(p);
                }
                else if(map[i][j] >= 2) S.push_back(make_pair(i, j));
            }
        }
        
        getComb(0);
        
        printf("#%d %d\n", test_case, myMin);
    }
    return 0;//정상종료시 반드시 0을 리턴해야합니다.
}