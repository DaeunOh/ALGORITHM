// 소요시간: 1시간 30분
// 실행시간: 449ms

/*

시간 : 50개 테스트케이스를 합쳐서 C의 경우 3초 / C++의 경우 3초 / Java의 경우 3초 / Python의 경우 15초
메모리 : 힙, 정적 메모리 합쳐서 256MB 이내, 스택 메모리 1MB 이내
※ SW Expert 아카데미의 문제를 무단 복제하는 것을 금지합니다.


줄기세포 배양 시뮬레이션 프로그램을 만들려고 한다.
줄기세포들을 배양 용기에 도포한 후 일정 시간 동안 배양을 시킨 후 
줄기 세포의 개수가 몇 개가 되는지 계산하는 시뮬레이션 프로그램을 만들어야 한다.

하나의 줄기 세포는 가로, 세로 크기가 1인 정사각형 형태로 존재하며 배양 용기는 격자 그리드로 구성되어 있으며 
하나의 그리드 셀은 줄기 세포의 크기와 동일한 가로, 세로 크기가 1인 정사각형이다.

각 줄기 세포는 생명력이라는 수치를 가지고 있다.
초기 상태에서 줄기 세포들은 비활성 상태이며 
생명력 수치가 X인 줄기 세포의 경우 X시간 동안 비활성 상태이고 X시간이 지나는 순간 활성 상태가 된다.

줄기 세포가 활성 상태가 되면 X시간 동안 살아있을 수 있으며 X시간이 지나면 세포는 죽게 된다.
세포가 죽더라도 소멸되는 것은 아니고 죽은 상태로 해당 그리드 셀을 차지하게 된다.

활성화된 줄기 세포는 첫 1시간 동안 상, 하, 좌, 우 네 방향으로 동시에 번식을 한다.
번식된 줄기 세포는 비활성 상태이다.
하나의 그리드 셀에는 하나의 줄기 세포만 존재할 수 있기 때문에 
번식하는 방향에 이미 줄기 세포가 존재하는 경우 해당 방향으로 추가적으로 번식하지 않는다.
두 개 이상의 줄기 세포가 하나의 그리드 셀에 동시 번식하려고 하는 경우 
생명력 수치가 높은 줄기 세포가 해당 그리드 셀을 혼자서 차지하게 된다.

줄기 세포의 크기에 비해 배양 용기의 크기가 매우 크기 때문에 시뮬레이션에서 배양 용기의 크기는 무한하다고 가정한다.

아래 [그림1]과 [그림2]는 줄기 세포가 번식하는 예를 나타낸다.
 
[그림 1]
 
[그림 2]

 
줄기 세포의 초기 상태 정보와 배양 시간 K시간이 주어질 때, 
K시간 후 살아있는 줄기 세포(비활성 상태 + 활성 상태)의 총 개수를 구하는 프로그램을 작성하라.


[제약 사항]
 

초기 상태에서 줄기 세포가 분포된 영역의 넓이는 세로 크기 N, 가로 크기 M이며 
N, M은 각각 1 이상 50 이하의 정수이다. (1≤N≤50, 1≤M≤50)
배양 시간은 K시간으로 주어지며 K는 1 이상 300 이하의 정수이다. (1≤K≤300)
배양 용기의 크기는 무한하다. 따라서 줄기 세포가 배양 용기 가장자리에 닿아서 번식할 수 없는 경우는 없다.
줄기 세포의 생명력 X는 1 이상 10 이하의 정수이다. (1≤X≤10)
 

[입력]
 

입력의 가장 첫 줄에는 총 테스트 케이스의 개수 T가 주어진다.
그 다음 줄부터는 각 테스트 케이스가 주어지며
각 테스트 케이스의 첫째 줄에는 초기 상태에서줄기 세포가 분포된 세로 크기 N, 가로 크기 M, 배양 시간 K가 순서대로 주어진다.
다음 N 줄에는 각 줄마다 M개의 그리드 상태 정보가 주어진다.
1~10까지의 숫자는 해당 그리드 셀에 위치한 줄기 세포의 생명력을 의미하며,
0인 경우 줄기 세포가 존재하지 않는 그리드이다.

 

[출력]
 

테스트 케이스 T에 대한 결과는 “#T”을 찍고,
배양을 K시간 시킨 후 배양 용기에 있는 살아있는 줄기 세포(비활성 상태 + 활성 상태)의 개수를 출력한다. 
(T는 테스트케이스의 번호를 의미하며 1부터 시작한다. )

입력
5
2 2 10		// 첫 번째 테스트 케이스: N=2, M=2, K=10
1 1
0 2
5 5 19		// 두 번째 테스트 케이스: N=5, M=5, K=19
3 2 0 3 0
0 3 0 0 0
0 0 0 0 0
0 0 1 0 0
0 0 0 0 2
9 10 37             	// 세 번째 테스트 케이스: N=9, M=10, K=37   
0 0 0 0 0 0 0 0 3 0
0 0 0 0 0 0 0 0 5 3
0 0 2 0 0 0 0 4 0 0
3 0 0 0 0 0 4 0 0 0
0 0 0 0 0 3 5 0 0 2
0 0 0 0 0 0 0 0 0 5
0 0 0 0 0 0 0 0 2 3
0 0 0 0 0 0 0 0 0 0
0 0 2 2 0 0 0 0 0 0
…		// 나머지 테스트 케이스는 sample_input.txt를 참조한다


출력
#1 22
#2 36
#3 90
#4 164
#5 712

*/

/*

주어진 생명력을 가지고 비활성 상태, 활성 상태, 죽은 상태를 구분하며
활성 상태시 줄기 세포를 배양하면서 배양 용기를 채워나가는 시뮬레이션 문제.

가장 먼저, 배양 용기의 제한이 없다는 점이 가장 당황스러웠다...
보통 번식하는 문제를 푸는 경우에 용기의 제한이 있어 일정 범위를 넘어가면 번식하지 못하도록 했는데,
이 문제는 배양 용기의 제한이 없다고 해서 처음에는 2차원 배열의 맵을 사용하면 안되는 줄 알았다.

그러나 아무리 번식이 되더라도 최대 300초라는 제한이 있기 때문에,
번식할 수 있는 범위는 한정적이 될 수밖에 없어 2차원 배열을 사용하는 것이 좋다.

사실 최대 번식이 가능한 시간이 300초이고, 활성화 되기 전 기본 시간이 1초기 때문에
같은 방향으로 150칸 넘게는 번식이 되지 않는다.
그래서 MAX를 350으로 두고 150 위치에서 시작하면 최대 50 x 50의 초기 맵이 주어지기 때문에 
350 x 350 그리드의 가운데에 초기 맵이 위치할 수 있게 된다.
그러나 당시 구현할 때는 계산하는게 귀찮기도 하고... 넓게 잡는다고 문제는 없을 것 같아 MAX 1000으로 두었다.

설계를 하면서 세포의 비활성 상태, 활성 상태, 죽은 상태를 구분하기 위해 생명력을 깎는 방식을 사용했다.
1) 비활성 상태에서는 초기 생명력을 깎고,
2) 처음 활성 상태가 되었을 때(초기 생명력이 0일 때)는 초기 생명력을 -1로 만들어 준 후 새로운 생명력을 깎고,
    번식을 위해 큐에 해당 세포를 넣었으며,
3) 활성 상태가 지속되는 동안(초기 생명력이 -1일 때)에는 새로운 생명력을 깎았다.
이렇게 생명력을 깎으며 새로운 생명력이 0인 경우에는 더이상 생명력을 깎는 것 없이 죽은 상태로 처리했다.

이후 큐에 들어있는 세포는 번식이 가능한 세포이므로(상하좌우로 다 번식되기 때문에 한 세포당 번식은 1번만 가능하다.)
큐가 빌 때까지 상하좌우로 번식을 시작했다.

만약 번식하고자 하는 위치에 이미 세포가 있는 경우에는 반복문을 다음으로 넘기고,
세포가 없는 경우에는 동시에 번식하고자 하는 세포가 있는지, 없는지 확인 후
있는 경우에는 생명력에 따라 어떤 세포가 번식될지 결정했다.
그리고 최종적으로 번식되는 위치에 세포를 추가시킴으로써 맵의 업데이트와, visited 배열을 다시 정리해주었다.


이렇듯 나는 생명력을 줄이면서 활성시간 및 죽는시간을 결정했는데,
다 구현하고 나서는 활성시간 및 죽는시간은 time(현재 몇 초인지)에 맞춰서 결정하는 것이
조건문 설정에 있어서 복잡함이 없을 것 같다는 생각을 했다.
실제로 조건문 설정이 조금 헷갈려서 예제를 몇 번씩 써보면서 구현했다;;ㅎㅎㅎ;;;

다음에 한 번 더 복습 할 때는 그런 방식으로 구현해봐야겠다! ^_^

*/

#include<iostream>
#include<cstdio>
#include<vector>
#include<cstring>
#include<queue>

using namespace std;

const int MAX = 1000 + 10;

int N, M, K;
int map[MAX][MAX];
int visited[MAX][MAX];

int dy[4] = {-1, 1, 0, 0};
int dx[4] = {0, 0, -1, 1};

struct CELL {
    int y, x, X, alive;
    
    CELL(int _y, int _x, int _X, int _alive) {
        y = _y;
        x = _x;
        X = _X;
        alive = _alive;
    }
};

vector <CELL> cell;
queue <CELL> q;

void solution() {
    vector <pair<int, int>> temp;
    while(K--) {
        temp.clear();
        
        for(int i=0; i<cell.size(); i++) {
            // 세포가 죽은 경우
            if(cell[i].alive == 0) continue;
            
            // 1) 세포가 활성화 되기 전(활성화 되기 전 생명력 X를 깎는다.)
            // 2) 세포가 활성화 되는 시점 (활성화 되기 전 생명력을 -1로 바꿔주고, 활성화 이후 생명력을 1 감소시킨다.)
            // 3) 세포가 활성화 된 이후 (활성화 이후 생명력을 감소시킨다.)
            if(cell[i].X > 0) cell[i].X--;
            else if(cell[i].X == 0) {
                q.push(CELL(cell[i].y, cell[i].x, cell[i].alive, cell[i].alive)); // 번식이 가능하므로 큐에 넣는다.
                cell[i].X = -1;
                cell[i].alive--;
            }
            else cell[i].alive--;
        }
        
        while(!q.empty()) {
            CELL front = q.front();
            q.pop();
            
            for(int i=0; i<4; i++) {
                int nextY = front.y + dy[i];
                int nextX = front.x + dx[i];
                
                if(map[nextY][nextX]) continue; // 이미 세포가 있는 경우
                
                if(visited[nextY][nextX] == -1) { // 동시에 번식하고자 하는 세포가 없는 경우
                    visited[nextY][nextX] = front.alive;
                    temp.push_back(make_pair(nextY, nextX));
                }
                else { // 동시에 번식하고자 하는 세포가 있는 경우 생명력이 더 큰 세포가 번식되게끔 한다.
                    int otherX = visited[nextY][nextX];
                    if(front.alive > otherX) visited[nextY][nextX] = front.alive;
                }
            }
        }
        
        // 해당 번식 위치에 세포를 추가시킨다.
        // map에는 생명력을 넣고, visited는 -1로 바꿔준다.
        for(int i=0; i<temp.size(); i++) {
            int y = temp[i].first, x = temp[i].second;
            cell.push_back(CELL(y, x, visited[y][x], visited[y][x]));
            map[y][x] = visited[y][x];
            visited[y][x] = -1;
        }
    }
}

int main(int argc, char** argv)
{
    int test_case;
    int T;
        	cin>>T;
    
    for(test_case = 1; test_case <= T; ++test_case)
    {
        memset(map, 0, sizeof(map));
        memset(visited, -1, sizeof(visited));
        cell.clear();
        scanf("%d %d %d", &N, &M, &K);
        for(int i=0; i<N; i++) {
            for(int j=0; j<M; j++) {
                scanf("%d", &map[i+500][j+500]); // 배양 용기의 범위가 무한하므로 큰 배열의 가운데에 위치시킨다.
                
                if(map[i+500][j+500] != 0) // 세포가 있는 경우 세포 벡터에 추가시킨다.
                    cell.push_back(CELL(i+500, j+500, map[i+500][j+500], map[i+500][j+500]));
            }
        }
        
        solution();
        
        int cnt = 0;
        for(int i=0; i<cell.size(); i++) 
            if(cell[i].alive != -1) cnt++;
        
        printf("#%d %d\n", test_case, cnt);
    }
    return 0;//정상종료시 반드시 0을 리턴해야합니다.
}