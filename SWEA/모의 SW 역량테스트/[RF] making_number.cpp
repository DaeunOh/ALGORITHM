// 소요시간: 22분
// 실행시간: 43ms

/*

시간 : 50개 테스트케이스를 합쳐서 C의 경우 5초 / C++의 경우 5초 / Java의 경우 5초 / Python의 경우 10초
메모리 : 힙, 정적 메모리 합쳐서 256MB 이내, 스택 메모리 1MB 이내
※ SW Expert 아카데미의 문제를 무단 복제하는 것을 금지합니다.

선표는 게임을 통해 사칙 연산을 공부하고 있다.
N개의 숫자가 적혀 있는 게임 판이 있고, +, -, x, / 의 연산자 카드를 숫자 사이에 끼워 넣어 다양한 결과 값을 구해보기로 했다.
수식을 계산할 때 연산자의 우선 순위는 고려하지 않고 왼쪽에서 오른쪽으로 차례대로 계산한다.
예를 들어 1, 2, 3 이 적힌 게임 판에 +와 x를 넣어 1 + 2 * 3을 만들면 1 + 2를 먼저 계산하고 그 뒤에 * 를 계산한다.
즉 1+2*3의 결과는 9이다.

주어진 연산자 카드를 사용하여 수식을 계산했을 때 그 결과가 최대가 되는 수식과 최소가 되는 수식을 찾고, 두 값의 차이를 출력하시오.


[예시]

[Figure 1] 과 같이 [3,5,3,7,9]가 적힌 숫자판과 [‘+’ 2개, ‘-‘ 1개, ‘/’ 1개]의 연산자 카드가 주어진 경우를 생각해보자.

[Figure 1]

아래 [Table 1]은 만들 수 있는 수식과 계산 결과이다.
 
[Table 1]

이 경우 최댓값은 3 - 5 / 3 + 7 + 9 = 16, 최솟값은 3 + 5 + 3 / 7 - 9 = -8 이다.
즉 결과는 최댓값과 최솟값의 차이 ( 16 - ( -8 ) ) 로 24 가 답이 된다.

 

[제약사항]

1. 시간 제한 : 최대 50 개 테스트 케이스를 모두 통과하는 데 C / C++ / Java 모두 3 초
2. 게임 판에 적힌 숫자의 개수 N 은 3 이상 12 이하의 정수이다. ( 3 ≤ N ≤ 12 )
3. 연산자 카드 개수의 총 합은 항상 N - 1 이다.
4. 게임 판에 적힌 숫자는 1 이상 9 이하의 정수이다.
5. 수식을 완성할 때 각 연산자 카드를 모두 사용해야 한다..
6. 숫자와 숫자 사이에는 연산자가 1 개만 들어가야 한다.
7. 완성된 수식을 계산할 때 연산자의 우선 순위는 고려하지 않고, 왼쪽에서 오른쪽으로 차례대로 계산한다.
8. 나눗셈을 계산 할 때 소수점 이하는 버린다.
9. 입력으로 주어지는 숫자의 순서는 변경할 수 없다.
10. 연산 중의 값은 -100,000,000 이상 100,000,000 이하임이 보장된다.

 

[입력]

입력의 맨 첫 줄에는 총 테스트 케이스의 개수 T 가 주어지고,
그 다음 줄부터 T 개의 테스트 케이스가 주어진다.
각 테스트 케이스의 첫 번째 줄에는 숫자의 개수 N 이 주어진다.
다음 줄에는 '+', '-', '*', '/' 순서대로 연산자 카드의 개수가 공백을 사이에 두고 주어진다.
다음 줄에는 수식에 들어가는 N 개의 숫자가 순서대로 공백을 사이에 두고 주어진다.

 

[출력]

테스트 케이스 개수만큼 T 개의 줄에 각각의 테스트 케이스에 대한 답을 출력한다.
각 줄은 "#t" 로 시작하고 공백을 하나 둔 다음 정답을 출력한다. ( t 는 1 부터 시작하는 테스트 케이스의 번호이다. )
정답은 연산자 카드를 사용하여 만들 수 있는 수식으로 얻은 결과값 중 최댓값과 최솟값의 차이이다.

 

 

입력
10		// 총 테스트 케이스의 개수 T = 10
5		// 첫 번째 테스트 케이스, N = 5 본문 예제
2 1 0 1		// 각 연산자의 개수 '+' 2 개, '-' 1 개, '*' 0 개, '/' 1 개
3 5 3 7 9		// 수식에 사용되는 숫자
6		// 두 번째 테스트 케이스, N = 6
4 1 0 0		// 각 연산자의 개수 '+' 4 개, '-' 1 개, '*' 0 개, '/' 0 개
1 2 3 4 5 6	// 수식에 사용되는 숫자
…		// 나머지는 sample_input.txt 참조

출력
#1 24
#2 8
#3 144
#4 8
#5 91
#6 150
#7 198
#8 2160
#9 46652
#10 701696

*/

/*

연산자 개수에 따른 조합을 만들고, 주어진 숫자를 이용하여 연산하는 문제.
연산 중의 값은 int의 범위를 넘지 않기 때문에 int를 사용하고,
게임 판에 적힌 숫자는 항상 1이상 9이하의 정수이기 때문에 0으로 나눠지는 경우는 고려하지 않아도 된다.

0부터 3까지의 i를 +, -, *, /로 생각하고,
연산자의 개수가 0이 아니라면 그 연산자를 조합을 만드는데 사용한다.
(사용하기 전에는 1을 감소시켰다가, 사용한 후에는 1을 증가시켜줘야 한다.)

이후 연산하는 과정에서는 왼쪽에서 오른쪽으로 차례대로 계산하기 때문에
초기 값을 첫 번째 숫자로 넣어주고, 조합에 따라 연산을 달리 해준다.

계산된 값중 최댓값은 max에 최솟값은 min에 넣어주고,
모든 연산이 끝나고 나서는 최댓값 - 최솟값을 한 결과를 출력하면 된다.

*/

#include<iostream>
#include<cstdio>
#include<algorithm>

using namespace std;

const int MAX = 15;

int N;
int oper[MAX];
int num[MAX];

int comb[MAX];
int myMin, myMax;

void getResult() {
    int res = num[0];
    for(int i=0; i<N-1; i++) {
        if(comb[i] == 0) res += num[i+1];
        else if(comb[i] == 1) res -= num[i+1];
        else if(comb[i] == 2) res *= num[i+1];
        else res /= num[i+1];
    }
    
    myMin = min(myMin, res);
    myMax = max(myMax, res);
}

void getComb(int x) {
    if(x >= N-1) {
        getResult();
    }
    else {
        for(int i=0; i<4; i++) {
            if(oper[i] > 0) {
                comb[x] = i;
                oper[i]--;
                getComb(x+1);
                oper[i]++;
            }
        }
    }
}

int main(int argc, char** argv)
{
    int test_case;
    int T;
    
    cin>>T;
    
    for(test_case = 1; test_case <= T; ++test_case)
    {
        myMin = 987987987;
        myMax = -987987987;
        
        scanf("%d", &N);
        scanf("%d %d %d %d", &oper[0], &oper[1], &oper[2], &oper[3]);
        for(int i=0; i<N; i++) scanf("%d", &num[i]);
        
        getComb(0);
        
        printf("#%d %d\n", test_case, myMax - myMin);
    }
    return 0;//정상종료시 반드시 0을 리턴해야합니다.
}