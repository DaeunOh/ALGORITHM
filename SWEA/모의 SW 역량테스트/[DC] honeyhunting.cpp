// 1시간 13분

/*

시간 : 50개 테스트케이스를 합쳐서 C++의 경우 3초 / Java의 경우 3초 / Python의 경우 6초
메모리 : 힙, 정적 메모리 합쳐서 256MB 이내, 스택 메모리 1MB 이내
※ SW Expert 아카데미의 문제를 무단 복제하는 것을 금지합니다.


N*N 개의 벌통이 정사각형 모양으로 배치되어 있다.
각 칸의 숫자는 각각의 벌통에 있는 꿀의 양을 나타내며, 꿀의 양은 서로 다를 수 있다.
아래 [Fig. 1]은 N=4인 16개의 벌통을 나타낸다.

[Fig. 1]

각 벌통에 있는 꿀의 양이 주어졌을 때, 다음과 같은 과정으로 벌꿀을 채취하여 최대한 많은 수익을 얻으려고 한다.
   ① 두 명의 일꾼이 있다. 꿀을 채취할 수 있는 벌통의 수 M이 주어질 때, 
       각각의 일꾼은 가로로 연속되도록 M개의 벌통을 선택하고, 선택한 벌통에서 꿀을 채취할 수 있다.
       단, 두 명의 일꾼이 선택한 벌통은 서로 겹치면 안 된다. 

       아래 [Fig. 2]는 M=2일 때, 두 일꾼이 각각 벌통을 선택하는 다양한 예를 보여준다.

       [Fig. 2]

   ② 두 명의 일꾼은 선택한 벌통에서 꿀을 채취하여 용기에 담아야 한다.
       단, 서로 다른 벌통에서 채취한 꿀이 섞이게 되면 상품가치가 떨이지게 되므로, 
       하나의 벌통에서 채취한 꿀은 하나의 용기에 담아야 한다.
       하나의 벌통에서 꿀을 채취할 때, 일부분만 채취할 수 없고 벌통에 있는 모든 꿀을 한번에 채취해야 한다.
       두 일꾼이 채취할 수 있는 꿀의 최대 양은 C 이다.

예를 들어, 아래 [Fig. 3]에서 C=10이고, 두 명의 일꾼이 선택한 벌통이 그림과 같을 때,
첫 번째 일꾼은 꿀의 양이 6과 1인 두 개의 벌통에서 모두 꿀을 채취할 수 있다.
하지만 두 번째 일꾼은 꿀의 양이 8과 5인 두 개의 벌통에서 모두 꿀을 채취할 경우,
채취한 꿀의 양이 13이 되어 C=10을 초과하기 때문에 두 개의 벌통에서 모두 꿀을 채취할 수 없다.
따라서 두 번째 일꾼은 꿀의 양이 8과 5인 벌통 중 하나를 선택하여 꿀을 채취해야 한다.
[Fig. 3]은 그 중 한 예를 보여주고 있다.

[Fig. 3]


   ③ 채취한 꿀은 시장에서 팔리게 된다. 
       이때 하나의 용기에 있는 꿀의 양이 많을수록 상품가치가 높아, 각 용기에 있는 꿀의 양의 제곱만큼의 수익이 생긴다.
       예를 들어 위 [Fig. 3]과 같이 꿀을 채취할 경우, 꿀의 양이 6, 1, 8인 세 개의 용기가 얻어지며 
       이때 수익의 합은, (6*6) + (1*1) + (8*8) = 36 + 1 + 64 = 101 이 된다.

벌통들의 크기 N과 벌통에 있는 꿀의 양에 대한 정보, 선택할 수 있는 벌통의 개수 M, 꿀을 채취할 수 있는 최대 양 C가 주어진다.
이때 두 일꾼이 꿀을 채취하여 얻을 수 있는 수익의 합이 최대가 되는 경우를 찾고, 
그 때의 최대 수익을 출력하는 프로그램을 작성하라.


[예시 1]

벌통들의 크기 N=4, 선택할 수 있는 벌통의 개수 M=2, 채취할 수 있는 꿀의 최대 양 C=13 이고,
아래 [Fig. 4]와 같이 벌통에 있는 꿀의 양의 정보가 주어진 경우를 보자.
최대 수익을 얻을 수 있는 경우 중 하나로 [Fig. 4]와 같이 벌통을 선택하여 선택하여 꿀을 채취하게 되면, 
총 수익이 174가 되어 최대가 된다.
따라서 이 경우 정답은 174이다.

[Fig. 4]


[예시 2]

벌통의 크기 N=3, 선택할 수 있는 벌통의 개수 M=3, 채취할 수 있는 꿀의 최대 양 C=10 이고,
아래 [Fig. 5]와 같이 벌통에 있는 꿀의 양의 정보가 주어진 경우를 보자.
최대 수익을 얻을 수 있는 경우 중 하나로 [Fig. 5]와 같이 벌통을 선택하여 꿀을 채취하게 되면, 
총 수익이 131이 되어 최대가 된다.
따라서 이 경우 정답은 131이다.
 
[Fig. 5]


[제약사항]

1. 시간제한 : 최대 50개 테스트 케이스를 모두 통과하는데, C/C++/Java 모두 3초.
2. 벌통들의 크기 N은 3 이상 10 이하의 정수이다. (3 ≤ N ≤ 10)
3. 선택할 수 있는 벌통의 개수 M은 1 이상 5 이하의 정수이다. (1 ≤ M ≤ 5)
4. 선택할 수 있는 벌통의 개수 M은 반드시 N 이하로만 주어진다.
5. 꿀을 채취할 수 있는 최대 양 C는 10 이상 30 이하의 정수이다. (10 ≤ C ≤ 30)
6. 하나의 벌통에서 채취할 수 있는 꿀의 양은 1 이상 9 이하의 정수이다.
7. 하나의 벌통에서 일부분의 꿀만 채취할 수 없고, 벌통에 있는 모든 꿀을 한번에 채취해야 한다.


[입력]

입력의 맨 첫 줄에는 총 테스트 케이스의 개수 T가 주어지고, 그 다음 줄부터 T개의 테스트 케이스가 주어진다.
각 테스트 케이스의 첫 번째 줄에는 벌통들의 크기 N, 
선택할 수 있는 벌통의 개수 M, 꿀을 채취할 수 있는 최대 양 C가 차례로 주어진다.
그 다음 줄부터 N*N 개의 벌통에서 채취할 수 있는 꿀의 양에 대한 정보가 주어진다.


[출력]

테스트 케이스의 개수만큼 T줄에 T개의 테스트 케이스 각각에 대한 답을 출력한다.
각 줄은 "#x"로 시작하고 공백을 하나 둔 다음 정답을 출력한다. (x는 1부터 시작하는 테스트 케이스의 번호이다)
출력해야 할 정답은 두 일꾼이 꿀을 채취하여 얻을 수 있는 최대 수익이다.


입력
10 	// 총 테스트 케이스 개수 T=10
4 2 13	// 첫 번째 테스트 케이스, N=4, M=2, C=13 (예시 1과 동일)
6 1 9 7    
9 8 5 8
3 4 5 3
8 2 6 7
3 3 10	// 두 번째 테스트 케이스, N=3, M=3, C=10 (예시 2와 동일)
7 2 9
6 6 6
5 5 7
…    	// 나머지는 sample_input.txt 참조

출력
#1 174
#2 131
#3 145
#4 155
#5 166
#6 239
#7 166
#8 172
#9 291
#10 464

*/

/*

N*N 맵에서 벌통을 연속으로 M개 만큼 "가로로만" 선택이 가능했기 때문에
아이디어를 떠올리는 것 자체는 비교적 쉬운 편에 속했던 문제!
(만약 세로로도 선택이 가능했으면 문제가 조금 복잡해질 뻔 했다...ㅎㅎㅎㅎ 다행;;;)

(i, j)를 시작으로 연속해서 M개의 벌통이 후보가 되었을 때,
벌통에 들어있는 벌꿀의 합이 C 이하가 되는 한에서 얻을 수 있는 최대 수익을 (i, j)에 저장한다.

예를 들어 (0, 0)을 시작으로 3개의 벌통이 후보가 된다면,
3개의 벌통을 다 고르는 것이 이상적이겠지만, C이하라는 제한이 있기 때문에 만약의 상황에 대비해
3개, 2개, 1개의 조합을 다 세워서 얻은 수익 중 최대 수익을 (0, 0)에 저장해야 한다.

이러한 과정을 M개 선택이 가능한 범위 내에서 모두 구해놓고,
이후 범위가 겹치지 않는 선에서 2개를 골랐을 때 최댓값을 구하면 그 값이 정답이 된다.
(가장 높은 값을 구해놓고, 그 값 기준으로 양 옆으로 M-1개를 제외한 나머지에서 두번째로 높은 값을 구해도 된다.)

SWEA 문제를 풀어보면서 느끼는 점은 생각보다 완전탐색으로 풀 수 있는 문제가 많다는 것이다.
항상 시간초과가 나지 않을까하는 마음에 최대한 효율적인 방법으로 짜려고 설계가 조금 오래 걸렸던 적이 많았는데,
정답 제출을 하고 나서 실행 시간을 보면 생각보다 너무 빠른 속도가 나와서 당황한 적이 많았다...ㅎㅎ;;;머쓱;;
(변수의 범위가 그렇게 크지 않아 시간 복잡도를 계산하는 것이 의미가 없었던 적도...)

그래도 일부는 시간 복잡도를 계산하는게 중요한 문제들도 있고 하니
항상 구현 전에 내 설계에 대한 대략적인 시간 복잡도를 구하는 것은 빠뜨리지 말고...
대신 충분히 제한시간 안에 해결 가능하면 더 효율적인 방법을 고안하기 보다 구현을 시작하는게
시간 절약에 도움이 되는 것 같다. ㅎㅎ
(효율적인 것도 중요하지만... 시간 내에 문제를 푸는 것이 더 중요하기 때문이다!!!)

*/

#include<iostream>
#include<cstdio>
#include<vector>
#include<algorithm>

using namespace std;

const int MAX = 10 + 10;

int N, M, C;
int map[MAX][MAX];
int honey[MAX][MAX];

int comb[MAX];
int myMax;

int honeyHunting(int len, int Y, int X) {
    // M개에서 len개를 고른 조합 중 하나를 이용하여
    // len개 만큼 더한 값이 C보다 작으면 수익을 반환하고, 그렇지 않으면 0을 반환한다.
    int sum = 0;
    int money = 0;
    for(int i=0; i<len; i++) {
        sum += map[Y][X+comb[i]];
        money += map[Y][X+comb[i]] * map[Y][X+comb[i]];
    }
    
    if(sum <= C) return money;
    else return 0;
}

void getComb(int x, int len, int Y, int X) {
    if(x >= len) {
        // 조합이 구해지면 벌꿀 채취를 통해 얻은 수익을 계속해서 최댓값으로 갱신한다.
        myMax = max(myMax, honeyHunting(len, Y, X));
    }
    else {
        for(int i=0; i<M; i++) {
            if(x == 0 || comb[x-1] < i) {
                comb[x] = i;
                getComb(x+1, len, Y, X);
            }
        }
    }
}

int solution() {
    for(int i=0; i<N; i++) {
        for(int j=0; j<N-M+1; j++) {
            myMax = 0;
            for(int k=M; k>=0; k--) {
                getComb(0, k, i, j);
            }
            honey[i][j] = myMax; // 다양한 조합에서 얻어진 수익 중 최대 수익을 저장한다.
        }
    }
    
    myMax = 0; // 가능한 두 개의 조합중 그 합이 최대가 되는 값이 최종적으로 myMax에 들어간다.
    for(int i=0; i<N; i++) {
        for(int j=0; j<N-M+1; j++) {
            // (i, j)를 기준으로 (i, j+2)부터의 값 중에 최댓값 찾기
            for(int k=i; k<N; k++) {
                for(int l=0; l<N-M+1; l++) {
                    if(i == k && l < j + M) continue;
                    myMax = max(myMax, honey[i][j] + honey[k][l]);
                }
            }
        }
    }
    
    return myMax;
}

int main(int argc, char** argv)
{
    int test_case;
    int T;
	
    cin>>T;
    
    for(test_case = 1; test_case <= T; ++test_case)
    {
        scanf("%d %d %d", &N, &M, &C);
        for(int i=0; i<N; i++) {
            for(int j=0; j<N; j++) {
                scanf("%d", &map[i][j]);
            }
        }
        
        printf("#%d %d\n", test_case, solution());
    }
    return 0;//정상종료시 반드시 0을 리턴해야합니다.
}