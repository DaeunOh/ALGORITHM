/*

시간 : 50개 테스트케이스를 합쳐서 C의 경우 3초 / C++의 경우 3초 / Java의 경우 3초 / Python의 경우 15초
메모리 : 힙, 정적 메모리 합쳐서 256MB 이내, 스택 메모리 1MB 이내
※ SW Expert 아카데미의 문제를 무단 복제하는 것을 금지합니다.


고객이 차량 정비소에 지갑을 두고 갔다.

차량 정비소에서 근무하는 이 대리는 고객에게 지갑을 돌려주려고 한다.

하지만, 차량 정비소를 방문한 고객이 너무 많아 모두 전화하여 확인하기가 불가능하다.

다행히 지갑에는 고객만족도 설문지가 있다.

고객만족도 설문지에는 고객이 이용했던 접수 창구번호와 정비 창구번호가 있다.

이 대리는 이 정보를 이용하여 전화로 확인할 고객을 정하려고 한다.

차량 정비소에는 N개의 접수 창구와 M개의 정비 창구가 있다.

접수 창구는 1부터 N까지 번호가 붙어 있다. 정비 창구도 1부터 M까지 번호가 붙어 있다.

차량 정비소에는 [Fig. 1]와 같이 두 단계를 거쳐 고객의 차량을 정비한다.

첫 단계는 접수 창구에서 고장을 접수하는 것이고, 두 번째 단계는 정비 창구에서 차량을 정비하는 것이다.
 


[Fig. 1]

차량 정비가 끝난 고객은 고객만족도 조사를 위해 고객만족도 설문지를 받는다.

접수 창구 및 정비 창구의 담당자 업무 능력이 달라서 담당자 별 처리 시간이 다르다.

한 담당자의 처리 시간은 고객과 고장의 종류에 상관 없이 항상 같다.

접수 창구 i에서 고객 한 명의 고장을 접수하는 데 걸리는 처리 시간은 ai이다. (1 ≤ i ≤ N)

정비 창구 j에서 고객 한 명의 차량을 정비하는 데 걸리는 처리 시간은 bj이다. (1 ≤ j ≤ M)

지금까지 차량 정비소를 방문한 고객은 K명이다.

고객은 도착하는 대로 1번부터 고객번호를 부여 받는다.

고객번호 k의 고객이 차량 정비소에 도착하는 시간은 tk이다. (1 ≤ k ≤ K)

고객이 차량 정비소에 도착하면, 빈 접수 창구가 있는 경우 빈 접수 창구에 가서 고장을 접수한다.

빈 접수 창구가 없는 경우 빈 접수 창구가 생길 때까지 기다린다.

고장 접수를 완료하면 정비 창구로 이동한다.

빈 정비 창구가 있는 경우 빈 정비 창구에 가서 차량을 정비 받는다.

빈 정비 창구가 없는 경우 빈 정비 창구가 생길 때까지 기다린다.

접수 창구의 우선순위는 아래와 같다.

   ① 여러 고객이 기다리고 있는 경우 고객번호가 낮은 순서대로 우선 접수한다.
   ② 빈 창구가 여러 곳인 경우 접수 창구번호가 작은 곳으로 간다.


정비 창구의 우선순위는 아래와 같다.

   ① 먼저 기다리는 고객이 우선한다.
   ② 두 명 이상의 고객들이 접수 창구에서 동시에 접수를 완료하고 정비 창구로 이동한 경우, 이용했던 접수 창구번호가 작은 고객이 우선한다.
   ③ 빈 창구가 여러 곳인 경우 정비 창구번호가 작은 곳으로 간다.


고객이 차량 정비소에 도착하여 접수 창구로 가는 시간 또는 접수 창구에서 정비 창구로 이동하는 시간은 무시할 수 있다. 즉, 이동 시간은 0이다.

고객의 도착 시간 tk, 접수 창구의 처리 시간 ai, 정비 창구의 처리 시간 bj가 주어졌을 때, 지갑을 분실한 고객과 같은 접수 창구와 같은 정비 창구를 이용한 고객의 고객번호들을 찾아 그 합을 출력하는 프로그램을 작성하라.

만약, 그런 고객이 없는 경우 -1을 출력한다.


[예시]

[Fig. 2]과 같이 접수 창구가 2개, 정비 창구가 2개가 있다고 하자. (N = 2, M = 2)
 

[Fig. 2]


접수 창구의 처리 시간 ai와 정비 창구의 처리 시간 bj는 [Table 1]과 같이 주어진다.

 

[Table 1]


지금까지 고객 6명이 이용했다. (K = 6)

고객 k의 도착 시간 tk는 [Table 2]와 같이 주어진다.

 

[Table 2]


지갑을 분실한 고객은 접수 창구 1과 정비 창구 2를 이용했다고 한다.

이 대리는 지갑을 분실한 고객과 같은 접수 창구 1과 정비 창구 2를 이용한 고객들의 고객번호를 알고 싶어 한다.

시간 별 고객들의 이동은 [Fig. 3]와 같다.

[Fig. 3]
 

접수 창구 1과 정비 창구 2를 이용한 고객의 고객번호는 1과 6이다.

따라서, 정답은 1 + 6 = 7이다.


[제약사항]

1. 시간제한 : 최대 50개 테스트 케이스를 모두 통과하는데, C/C++/Java 모두 3초

2. 접수 창구의 개수 N과 정비 창구의 개수 M은 1 이상 9 이하의 정수이다. (1 ≤ N, M ≤ 9)

3. 접수 창구 i에서 고장을 접수하는 처리 시간 ai는 1 이상 20 이하의 정수이다. (1 ≤ ai ≤ 20)

4. 정비 창구 j에서 차량을 정비하는 처리 시간 bj는 1 이상 20 이하의 정수이다. (1 ≤ bj ≤ 20)

5. 차량 정비소를 방문한 고객의 수 K는 2 이상 1,000 이하의 정수이다. (2 ≤ K ≤ 1,000)

6. 고객 k의 도착 시간 tk는 0 이상 1,000 이하의 정수이다. (0 ≤ tk ≤ 1,000)

7. 지갑을 두고 간 고객이 이용한 접수 창구번호 A는 1 이상 N 이하의 정수이다. (1 ≤ A ≤ N)

8. 지갑을 두고 간 고객이 이용한 정비 창구번호 B는 1 이상 M 이하의 정수이다. (1 ≤ B ≤ M)

9. 창구번호와 고객번호는 1부터 시작한다.


[입력]

입력의 맨 첫 줄에는 총 테스트 케이스의 개수 T가 주어지고, 그 다음 줄부터 T개의 테스트 케이스가 주어진다.

각 테스트 케이스의 첫 번째 줄에는 접수 창구의 개수 N, 정비 창구의 개수 M, 차량 정비소를 방문한 고객의 수 K, 지갑을 두고 간 고객이 이용한 접수 창구번호 A와 정비 창구번호 B가 주어진다.

두 번째 줄에는 i번째 접수 창구가 고장을 접수하는 데 걸리는 시간 ai가 N개 주어진다.

세 번째 줄에는 j번째 정비 창구가 차량을 정비하는 데 걸리는 시간 bj가 M개 주어진다.

네 번째 줄에는 k번째 고객이 차량 정비소를 방문하는 시간 tk가 순서대로 K개 주어진다.


[출력]

테스트 케이스의 개수만큼 T줄에 T개의 테스트 케이스 각각에 대한 답을 출력한다.

각 줄은 "#x"로 시작하고 공백을 하나 둔 다음 정답을 출력한다. (x는 1부터 시작하는 테스트 케이스의 번호이다)

출력해야 할 정답은 지갑을 두고 간 고객과 같은 접수 창구 A와 같은 정비 창구 B를 이용한 고객들의 고객번호의 합이다. 만약 그런 고객이 없는 경우 정답으로 -1을 출력한다.


입력
10		// 총 테스트 케이스 개수 T=10
1 1 2 1 1		// 첫 번째 테스트 케이스, N=1, M=1, K=2, A=1, B=1
5		// a1=5
7		// b1=7
7 10		// t1=7, t2=10
2 2 6 1 2		// 두 번째 테스트 케이스, N=2, M=2, K=6, A=1, B=2,본문예제
3 2		// a1=3, a2=2
4 2		// b1=4, b2=2
0 0 1 2 3 4	// t1=0, t2=0, t3=1, t4=2, t5=3, t6=4
…		// 나머지는 sample_input.txt 참조

출력
#1 3
#2 7
#3 2
#4 22
#5 18
#6 15
#7 -1
#8 259
#9 100
#10 164

*/

/*

구현하면서 중간에 빠뜨린 조건들도 많았고.. if를 써야할지 else if를 써야할지가 매우 헷갈린 탓에...
코드 순서도 엉망진창에 처음 보는 사람은 전혀 이해하지 못할 정도로 복잡하게 구현됐다.. ㅠㅠ

그리고 벡터 썼다가 큐 썼다가 배열 썼다가.. sort도 사용하고..
여러모로 반성을 많이 하게 만들어주는 코딩이었다 ㅎㅎㅎ;;;

그래도 최대한 주석 달아보려 노력하고 정답도 나왔지만
실행시간이 458ms로, 다른 사람들보다 좀 더 오래 걸린 것 같아서 너무 아쉬웠다.!!
(아마 K의 값이 최대 1000인데 K번을 도는 반복문을 많이 사용해서 그런 것 같다)
다른 구현 방법을 다시 생각해내서 다시 도전해봐야겠다!! 화이팅!

*/

#include<iostream>
#include<cstdio>
#include<vector>
#include<queue>
#include<cstring>
#include<algorithm>

using namespace std;

const int MAXNM = 9 + 10;
const int MAXK = 1000 + 10;

int N, M, K, A, B;

int ai[MAXNM];
int bj[MAXNM];

bool visitedN[MAXNM] = {false, };
bool visitedM[MAXNM] = {false, };

struct CUSTOMER {
    int tk, a, b, ai, bj;
    
    void create(int _tk) {
        tk = _tk;
        a = 0;
        b = 0;
        ai = 0;
        bj = 0;
    }
};

CUSTOMER c[MAXK];

void initialize() {
    memset(visitedN, 0, sizeof(visitedN));
    memset(visitedM, 0, sizeof(visitedM));
    
    scanf("%d %d %d %d %d", &N, &M, &K, &A, &B);    
    
    for(int i=1; i<=N; i++) scanf("%d", &ai[i]);
    for(int j=1; j<=M; j++) scanf("%d", &bj[j]);
        
    for(int i=1; i<=K; i++) {
        int tk;
        scanf("%d", &tk);

        c[i].create(tk);
    }
}

int solution() {
    int t = 0;
    queue<int> q;
    vector<pair<int, int>> waitingRep;

    while(1) {
        // 1. 접수가 끝났다면 접수창구를 비워주고,
        //	빈 정비창구가 있다면 정비 요청을 한다.
        // 	(단, 같은 시간대에 이동된 대기인원이 여러 명이라면 창구 번호가 작았던 고객을 우선으로 한다.)
        //	빈 정비창구가 없다면 대기한다.
        waitingRep.clear();
        for(int i=1; i<=K; i++) {
            if(c[i].tk >= 0) continue;
            
            if(c[i].ai > 0) c[i].ai--;
            else if(c[i].ai == 0) {
                visitedN[c[i].a] = false;
                waitingRep.push_back(make_pair(c[i].a, i));
                c[i].ai = -1;
            }
        }
        
        for(int i=1; i<=K; i++) {
            if(c[i].ai >= 0) continue;
            
            if(c[i].bj > 0) c[i].bj--;
            else if(c[i].bj == 0) {
                visitedM[c[i].b] = false;
                c[i].bj = -1;
            }
        }
        
        // 접수 창구 번호를 오름차순으로 정렬 후 큐에 넣어준다.
        sort(waitingRep.begin(), waitingRep.end());
        for(int i=0; i<waitingRep.size(); i++) q.push(waitingRep[i].second);
        
        for(int i=1; i<=M; i++) {
            if(q.empty()) break;
            
            if(!visitedM[i]) { // 빈 정비창구 존재
                visitedM[i] = true;
                c[q.front()].b = i;
                c[q.front()].bj = bj[i] - 1;
                q.pop();
            }
        }
        
        // 2. 도착한 사람이 있다면 접수창구가 비었는지 보고,
        //	빈 접수창구가 있다면 접수 요청을 한다.
        //	빈 접수창구가 없다면 대기한다.
        for(int i=1; i<=K; i++) {
            if(c[i].tk > 0) c[i].tk--;
            else if(c[i].tk == 0) {
                // 접수창구 확인
                for(int j=1; j<=N; j++) {
                    if(!visitedN[j]) { // 빈 접수창구 존재
                        visitedN[j] = true;
                        c[i].a = j;
                        c[i].ai = ai[j] - 1;
                        c[i].tk = -1; // 대기가 아님을 표시
                        break;
                    }
                }
            }
        }
            
        bool flag = false;
        for(int i=1; i<=K; i++) {
            if(c[i].bj != -1) {
                flag = true;
                break;
            }
        }
            
        if(!flag) break;
            
        t++;
    }
    
    int sum = 0;
    for(int i=1; i<=K; i++) {
        if(c[i].a == A && c[i].b == B) sum += i;
    }
    
    return sum;
}

int main(int argc, char** argv)
{
    int test_case;
    int T;
    
    scanf("%d", &T);
	
    for(test_case = 1; test_case <= T; ++test_case)
    {
        initialize();
        int sum = solution();

        if(sum != 0) printf("#%d %d\n", test_case, sum);
        else printf("#%d -1\n", test_case);
    }
    return 0;//정상종료시 반드시 0을 리턴해야합니다.
}