// 소요시간: 52분
// 실행시간: 32ms

/*

시간 : 50개 테스트케이스를 합쳐서 C의 경우 3초 / C++의 경우 3초 / Java의 경우 3초 / Python의 경우 15초
메모리 : 힙, 정적 메모리 합쳐서 256MB 이내, 스택 메모리 1MB 이내
※ SW Expert 아카데미의 문제를 무단 복제하는 것을 금지합니다.


N*N 크기의 도시에 홈방범 서비스를 제공하려고 한다.
홈방범 서비스는 운영 상의 이유로 [Fig. 1]의 파란색 부분과 같이 마름모 모양의 영역에서만 제공된다.
 
[Fig. 1]


또한, 홈방범 서비스를 제공하기 위해서는 운영 비용이 필요하다.
[Fig. 2]와 같이 서비스 영역의 크기 K 가 커질수록 운영 비용이 커진다.
운영 비용은 서비스 영역의 면적과 동일하며, 아래와 같이 구할 수 있다.

운영 비용 = K * K + (K - 1) * (K - 1)
운영 영역의 크기 K 는 1 이상의 정수이다.

 - K = 1 일 때, 운영 비용은 1 이다.
 - K = 2 일 때, 운영 비용은 5 이다.
 - K = 3 일 때, 운영 비용은 13 이다.
 - K = 4 일 때, 운영 비용은 25 이다.

[Fig. 2]


[Fig. 3]과 같이 도시를 벗어난 영역에 서비스를 제공해도 운영 비용은 변경되지 않는다.
[Fig. 3]의 경우 K = 3 이므로, 운영 비용은 13 이다.
 
[Fig. 3]


홈방범 서비스를 제공받는 집들은 각각 M의 비용을 지불할 수 있어, 
보안회사에서는 손해를 보지 않는 한 최대한 많은 집에 홈방범 서비스를 제공하려고 한다.
도시의 크기 N과 하나의 집이 지불할 수 있는 비용 M, 도시의 정보가 주어진다.
이때, 손해를 보지 않으면서 홈방범 서비스를 가장 많은 집들에 제공하는 서비스 영역을 찾고,
그 때의 홈방범 서비스를 제공 받는 집들의 수를 출력하는 프로그램을 작성하라.


[예시]

예를 들어, [Fig. 4]과 같이 N이 8인 도시의 정보가 주어지고, 하나의 집이 지불할 수 있는 비용 M이 3이라고 생각해 보자.
 
[Fig. 4]


[Fig. 5]와 같이 서비스 영역 K = 2로 하여 홈방범 서비스를 제공할 때는 최대 3개의 집까지 서비스 제공이 가능하다.
이 경우 보안회사의 이익은 4가 되어 손해를 보지 않고 서비스 제공이 가능하다.
보안회사의 이익(4) = 서비스 제공받는 집들을 통해 얻는 수익(3*3) - 운영 비용(5)

[Fig. 5]


[Fig. 6]은 서비스 영역 K = 3으로 하여 홈방범 서비스를 제공할 때에 최대 5개의 집까지 서비스 제공이 가능한 경우 중 하나이다.
보안회사의 이익(2) = 서비스 제공받는 집들을 통해 얻는 수익(3*5) - 운영 비용(13)

[Fig. 6]


위의 예에서, 보안회사가 손해를 보지 않고 서비스 가능한 최대 집의 수는 5이며, 5가 정답이 된다.


[제약사항]

1. 시간제한 : 최대 50개 테스트 케이스를 모두 통과하는데, C/C++/Java 모두 3초
2. 도시의 크기 N은 5 이상 20 이하의 정수이다. (5 ≤ N ≤ 20)
3. 하나의 집이 지불할 수 있는 비용 M은 1 이상 10 이하의 정수이다. (1 ≤ M ≤ 10)
4. 홈방범 서비스의 운영 비용은 서비스 영역의 면적과 동일하다.
5. 도시의 정보에서 집이 있는 위치는 1이고, 나머지는 0이다.
6. 도시에는 최소 1개 이상의 집이 존재한다.


[입력]

입력의 맨 첫 줄에는 총 테스트 케이스의 개수 T가 주어지고, 그 다음 줄부터 T개의 테스트 케이스가 주어진다.
각 테스트 케이스의 첫 번째 줄에는 도시의 크기 N과 하나의 집이 지불할 수 있는 비용 M이 주어진다.
그 다음 줄부터 N*N 크기의 도시정보가 주어진다. 지도에서 1은 집이 위치한 곳이고, 나머지는 0이다.


[출력]

테스트 케이스의 개수만큼 T줄에 T개의 테스트 케이스 각각에 대한 답을 출력한다.
각 줄은 "#x"로 시작하고 공백을 하나 둔 다음 정답을 출력한다. (x는 1부터 시작하는 테스트 케이스의 번호이다)
출력해야 할 정답은 손해를 보지 않으면서 홈방범 서비스를 가장 많은 집들에 제공하는 서비스 영역을 찾았을 때,
그 때의 서비스를 제공 받는 집들의 수이다.

입력
10		//총 테스트 케이스 개수 T=10
8 3		//첫 번째 테스트 케이스, N=8, M=3
0 0 0 0 0 1 0 0
0 1 0 1 0 0 0 1
0 0 0 0 0 0 0 0
0 0 0 1 0 1 0 0
0 0 1 1 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 1 0 1 0
1 0 0 0 0 0 0 0
…		//나머지는 sample_input.txt 참조

출력
#1 5
#2 4
#3 24
#4 48
#5 3
#6 65
#7 22
#8 22
#9 78
#10 400

*/

/*

이 문제의 핵심은 1) 완전탐색 + 2) 적절한 범위 설정이다.
범위 설정은 필수적인 요소는 아니지만, 소요시간을 단축하기 위해 고려해보았다.

또한, 마름모 모양의 영역을 계산할 때 반복문을 통해서 원하는 범위만을 볼 수도 있지만,
기준 지점과의 거리를 계산하는 방법을 통해 마름모 모양을 만들어 낼 수 있으므로 거리를 계산하는 것이 좋다.
예를 들어 K=1인 경우에는 거리가 0인 지점이 되고, K=2인 경우에는 거리가 0~1인 지점이 되므로
마름모 모양은 거리가 0~K-1인 지점을 보는 것만으로 만들어 낼 수 있음을 이용하자. ㅎㅎ


1) 완전탐색

완전탐색을 하기 전에는 항상 시간복잡도를 계산하는 것이 중요하기 때문에, 가장 먼저 시간복잡도를 계산해보았다.
N * N의 맵을 모두 돌면서, 하나의 칸당 다시 N * N의 맵을 돌고 나서 이익을 계산해야 하므로
시간복잡도는 O(N^4)라고 할 수 있다.

하지만 여기서 주어진 N의 최대 크기가 20이므로 한 테스트 케이스당 최대 20^4 = 160,000번의 연산이 수행되고,
테스트 케이스가 50개 주어지므로 50 * 16만이 되는데,
1억번의 연산이 약 1초정도 소요된다고 생각했을 때 주어진 제한 시간 3초가 넘어가지 않으므로 시간은 충분하다.
이와 같은 이유로 완전탐색을 이용한 구현이 가능하다고 판단했고, 설계를 시작했다.


2) 적절한 범위 설정

K는 최대 20까지 늘어날 수 있지만, 이익 = M * (서비스를 받는 집의 수) - K^2 + (K-1)^2 이므로,
만약 (전체 집의 수) * M이 운영비용을 넘지 못하는 K가 있다면,
K이상의 경우는 계산하지 않아도 항상 적자가 날 것임을 알 수 있다.
따라서 본인은 초기에 전체 집의 수를 세어 놓고, 전체 집의 수에 따라 K의 최댓값을 설정하는 방법으로 범위를 좁혔다.


범위를 설정한 이후 진행되는 단계는 다음과 같다.
3) 각 칸(y, x)마다 다른 칸(i, j)과의 거리(|y - i| + |x - j|)를 계산한다.
4) 만약 거리가 maxK보다 작다면 해당 거리의 cnt를 1 증가시킨다.
5) 이후 K를 넓혀 가면서 집의 수를 누적시키고, 계산한 이익이 0이상인 경우의 집의 수를 저장한다.
6) 최대 집의 수를 구하기 위해 최댓값을 계속해서 갱신한다.

*/

#include<iostream>
#include<cstdio>
#include<cstring>

using namespace std;

const int MAX = 20 + 10;

int N, M;
int map[MAX][MAX];
int total;
int maxK;
int cnt[MAX];

int myMax;

int getAbs(int x) {
    if(x > 0) return x;
    else return -x;
}

void getResult(int y, int x) {
    memset(cnt, 0, sizeof(cnt));
    
    for(int i=0; i<N; i++) {
        for(int j=0; j<N; j++) {
            if(map[i][j] == 1) {
                int dist = getAbs(y - i) + getAbs(x - j);
                if(dist < maxK) cnt[dist]++;
            }
        }
    }
    
    int sum = 0;
    int home = 0;
    for(int i=0; i<maxK; i++) {
        sum += cnt[i];
        
        if(M*sum - ((i+1)*(i+1) + i*i) >= 0) home = sum;
    }
    
    if(myMax < home) myMax = home;
}

void solution() {
    for(int i=0; i<N; i++) {
        for(int j=0; j<N; j++) {
            getResult(i, j);
        }
    }
}

int main(int argc, char** argv)
{
    int test_case;
    int T;
    
    cin>>T;

    for(test_case = 1; test_case <= T; ++test_case)
    {
        total =0;
        maxK = 1;
        myMax = -987987987;
        scanf("%d %d", &N, &M);
        for(int i=0; i<N; i++) {
            for(int j=0; j<N; j++) {
                scanf("%d", &map[i][j]);
                if(map[i][j] == 1) total++;
            }
        }
        
        while(M*total > maxK * maxK + (maxK-1) * (maxK-1)) maxK++;
        
        solution();
        
        printf("#%d %d\n", test_case, myMax);
    }
    return 0;//정상종료시 반드시 0을 리턴해야합니다.
}