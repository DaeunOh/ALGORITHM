// 소요시간: 1시간 45분
// 실행시간: 6ms

/*

시간 : 50개 테스트케이스를 합쳐서 C의 경우 5초 / C++의 경우 5초 / Java의 경우 5초 / Python의 경우 30초
메모리 : 힙, 정적 메모리 합쳐서 256MB 이내, 스택 메모리 1MB 이내
※ SW Expert 아카데미의 문제를 무단 복제하는 것을 금지합니다.


[Fig. 1] 과 같은 N * N 크기의 절벽지대에 활주로를 건설하려고 한다.
각 셀의 숫자는 그 지형의 높이를 의미한다.

[Fig. 1]
                      

활주로를 [Fig. 2] 와 같이 가로 또는 세로 방향으로 건설할 수 있는 가능성을 확인하려고 한다.

[Fig. 2]


활주로는 높이가 동일한 구간에서 건설이 가능하다.
높이가 다른 구간의 경우 활주로가 끊어지기 때문에 [Fig. 3] 과 같은 경사로를 설치해야만 활주로를 건설 할 수 있다.

[Fig. 3]
                                                  

경사로는 길이가 X 이고, 높이는 1 이다.
경사로는 높이 차이가 1 이고 낮은 지형의 높이가 동일하게 경사로의 길이만큼 연속되는 곳에 설치 할 수 있다.

 

예를 들어 [Fig. 4] 는 길이가 2 이고 높이가 1 인 경사로를 설치하는 예를 보여준다.

[Fig. 4]


경사로의 길이 X 와 절벽지대의 높이 정보가 주어질 때,
활주로를 건설할 수 있는 경우의 수를 계산하는 프로그램을 작성하라.
 


[예시]

지도의 한 변의 크기 N 이 6, 경사로의 길이 X 가 2 일 때,
[Fig. 5] 와 같이 지형의 높이가 주어진 경우를 생각해 보자.

[Fig. 5]


[Fig. 5] 의 지형 중 [ 3, 3, 3, 2, 1, 1 ] 의 경우 [Fig. 6] 과 같이 높이 2 인 구간이 경사로 길이보다 짧아서 활주로를 설치 할 수 없다.

[Fig. 6]
                                                      

[ 3, 3, 3, 2, 2, 1 ] 의 지형은 [Fig. 7] 과 같이 경사로를 지형 밖까지 설치해야 되기 때문에 활주로를 설치할 수 없다.

[Fig. 7]


[ 2, 2, 3, 2, 2, 2 ] 지형과 [ 3, 3, 3, 2, 2, 2 ] 지형의 경우 아래 [Fig. 8-1], [Fig. 8-2] 와 같이 경사로를 설치하여 활주로를 건설할 수 있다.

[Fig. 8]
                           

[Fig. 5] 와 같은 지형에 활주로를 건설하는 방법은
아래 [Fig. 9] 와 같이 총 7 가지 ( 가로 방향 3 가지, 세로 방향 4 가지 ) 경우가 있다.
즉, 예제에 대한 정답은 7 이 된다

[Fig. 9]
                                                      

[제약사항]

1. 시간제한 : 최대 50 개 테스트 케이스를 모두 통과하는 데 C / C++ / Java 모두 3 초
2. N 의 크기는 6 이상 20 이하의 정수이다. ( 6 ≤ N ≤ 20 )
3. 경사로의 높이는 항상 1 이고, 길이 X 는 2 이상 4 이하의 정수이다. ( 2 ≤ X ≤ 4 )
4. 지형의 높이는 1 이상 6 이하의 정수이다.
5. 동일한 셀에 두 개 이상의 경사로를 겹쳐서 사용할 수 없다.
( 아래 [Fig. 10] 과 같은 경우는 경사로를 설치하여 활주로를 연결 할 수 없다. )

[Fig. 10]
                                            

6. 경사로는 세워서 사용할 수 없다. ( [Fig. 11] 참고 )

[Fig. 11]

 

[입력]

입력의 맨 첫 줄에는 총 테스트 케이스의 개수 T 가 주어지고,
그 다음 줄부터 T 개의 테스트 케이스가 주어진다.
각 테스트 케이스의 첫 번째 줄에는 지도의 한 변의 크기인 N 과 경사로의 길이 X 가 주어진다.
다음 N 개의 줄에는 N * N 크기의 지형 정보가 주어진다.
 

[출력]

테스트 케이스 개수만큼 T 개의 줄에 각각의 테스트 케이스에 대한 답을 출력한다.
각 줄은 "#t" 로 시작하고 공백을 하나 둔 다음 정답을 출력한다. ( t 는 1 부터 시작하는 테스트 케이스의 번호이다. )
정답은 활주로를 건설할 수 있는 경우의 수이다.

 
입력
10		// 총 테스트 케이스의 개수 T = 10
6 2		// 첫 번째 테스트 케이스, N = 6, X = 2 본문 예제
3 3 3 2 1 1	// N * N 지형의 높이
3 3 3 2 2 1
3 3 3 3 3 2
2 2 3 2 2 2
2 2 3 2 2 2
2 2 2 2 2 2
6 4		// 두 번째 테스트 케이스, N = 6, X = 4
3 2 2 2 1 2	// N * N 지형의 높이
3 2 2 2 1 2
3 3 3 3 2 2
3 3 3 3 2 2
3 2 2 2 2 2
3 2 2 2 2 2
…		// 나머지는 sample_input.txt 참조


출력
#1 7
#2 4
#3 11
#4 11
#5 15
#6 4
#7 4
#8 1
#9 5
#10 8

*/

/*

활주로를 건설하기 위해 높이가 다른 지점에 경사로를 세우는 시뮬레이션 문제.
간단할 줄 알았는데, 생각하지 못한 조건들이 많았어서 시간이 꽤 오래 걸렸다. ㅠ_ㅠ...

경사로를 세우는데 필요한 큰 규칙은 다음과 같다.
1) 높이 차이가 2이상 나는 지점이 있다면 경사로를 세워도 활주로를 만들 수 없다.
2) 높이 차이가 1이 나는 지점에 오르막 경사로 또는 내리막 경사로를 세울 수 있다.
3) 경사로를 세우는 지점의 높이는 모두 같아야 한다.


하지만 오늘도 실수는 존재했다. ㅎㅎ;;

1) 높이 차이가 2이상이 나면 활주로를 만들 수 없는데, 
    규칙 1)을 제대로 고려하지 못하고 높이 차이가 나기만 하면 상관 없다고 구현을 해버렸다.
    --> 높이가 2이상 차이나면 해당 행(또는 열)에 대해 즉시 false를 return시켰다.

2) 경사로가 세워져 있는 지점인지를 고려하지 못했다. ㅠㅠ
    --> visited 배열을 이용하여 경사로를 세운 지점에 경사로가 존재한다고 표시 했다.


잘못된 부분을 고치고 구현한 코드의 전체적인 메커니즘은 다음과 같다.

1) 모든 행, 열에 대해 하나의 행, 열 단위로 가로 스캔, 세로 스캔을 진행한다.

2) 연속된 두 개의 높이를 비교한다.
    2-1) 높이 차이가 2 이상 나는 경우에는 활주로를 만들 수 없으므로 false를 return한다.
    2-2) 높이 차이가 1이 나는 경우에는 경사로를 둘 수 있는지 확인한다.
    2-3) 높이 차이가 나지 않는 경우에는 다음 인덱스로 넘어간다. (continue)

3) 높이 차이가 1이 나는 경우, 오르막 경사로를 세울지 내리막 경사로를 세울지 결정한다.
    왼쪽의 높이가 더 크다면 내리막 경사로를, 더 작다면 오르막 경사로를 세운다.

4) 어떤 경사로를 세울지 정했다면, 경사로를 둘 길이가 충분한지 본다.
    4-1) 경사로를 두었을 때 경사로가 맵의 범위를 넘어간다면 false를 return한다.
    4-2) 경사로를 둘 길이가 충분하다면 그 범위 안에 경사로를 세워야 하는데,
           오르막 경사로를 세우는 경우 경사로를 세울 지점에 이미 경사로가 존재하진 않는지도 확인한다.

5) 경사로를 세운 위치에는 visited 배열에 경사로를 채웠다고 체크한다.


시뮬레이션 문제는 재밌는데... 가끔 구현하기가 너무 어려운 문제들이 나온다 ㅠㅠㅠ..
조금 더 많이 연습해야겠다..!! ㅠ

*/

#include<iostream>
#include<cstdio>
#include<cstring>

using namespace std;

const int MAX = 20 + 10;

int N, X;
int map[MAX][MAX];
bool visitedRow[MAX][MAX];
bool visitedCol[MAX][MAX];

int cnt;

bool rowScan(int y) {
    for(int i=0; i<N-1; i++) {
        bool flag = false;
        
        // 높이가 2이상 차이나면 경사로를 두어도 해결할 수 없으므로 false를 return한다.
        if(map[y][i] > map[y][i+1] + 1 || map[y][i] + 1 < map[y][i+1]) return false;
        
        if(map[y][i] > map[y][i+1]) {
            // 경사로를 둘 길이가 충분한지 본다.
            if(i+X > N-1) return false;
            
            // X 길이만큼 낮은 높이 map[y][i+1]가 지속되는지 확인한다.
            for(int j=0; j<X; j++) {
                if(map[y][i+1] != map[y][i+1+j]) return false;
            }
            
            // 경사로를 놓은 위치를 표시한다.
            for(int j=0; j<X; j++) visitedRow[y][i+1+j] = true;
        }
        else if(map[y][i] < map[y][i+1]) {
            // 경사로를 둘 길이가 충분한지 본다.
            if(i+1-X < 0) return false;
            
             // 경사로가 없는 위치면서 X 길이만큼 낮은 높이 map[y][i]가 지속되는지 확인한다.
            for(int j=0; j<X; j++) {
                if(visitedRow[y][i-j] || map[y][i] != map[y][i-j]) return false;
            }
            
            // 경사로를 놓은 위치를 표시한다.
            for(int j=0; j<X; j++) visitedRow[y][i-j] = true;
        }
    }
    
    return true;
}

bool colScan(int x) {
    for(int i=0; i<N-1; i++) {
        if(map[i][x] > map[i+1][x] + 1 || map[i][x] + 1 < map[i+1][x]) return false;
        
        bool flag = false;
        if(map[i][x] > map[i+1][x]) {
            if(i+X > N-1) return false;
            
            for(int j=1; j<X; j++) {
                if(map[i+1][x] != map[i+1+j][x]) return false;
            }
            
            for(int j=0; j<X; j++) visitedCol[i+1+j][x] = true;
        }
        else if(map[i][x] < map[i+1][x]) {
            if(i+1-X < 0) return false;
            
            for(int j=1; j<X; j++) {
                if(visitedCol[i-j][x] || map[i][x] != map[i-j][x]) return false;
            }
            
            for(int j=0; j<X; j++) visitedCol[i-j][x] = true;
        }
    }
    
    return true;
}

void solution() {
    memset(visitedRow, 0, sizeof(visitedRow));
    memset(visitedCol, 0, sizeof(visitedCol));
    
    for(int i=0; i<N; i++) {
        if(rowScan(i)) cnt++;
        if(colScan(i)) cnt++;
    }
}

int main(int argc, char** argv)
{
    int test_case;
    int T;
    
    cin>>T;
    
    for(test_case = 1; test_case <= T; ++test_case)
    {
        cnt = 0;
        scanf("%d %d", &N, &X);
        for(int i=0; i<N; i++) {
            for(int j=0; j<N; j++) {
                scanf("%d", &map[i][j]);
            }
        }
        
        solution();
        
        printf("#%d %d\n", test_case, cnt);
    }
    return 0;//정상종료시 반드시 0을 리턴해야합니다.
}