/*

시간 : 50개 테스트케이스를 합쳐서 C의 경우 3초 / C++의 경우 3초 / Java의 경우 3초 / Python의 경우 15초
메모리 : 힙, 정적 메모리 합쳐서 256MB 이내, 스택 메모리 1MB 이내
※ SW Expert 아카데미의 문제를 무단 복제하는 것을 금지합니다.

김 프로는 수영장을 이용한다.

김 프로는 지출이 너무 많아 1년 동안 각 달의 이용 계획을 수립하고 가장 적은 비용으로 수영장을 이용할 수 있는 방법을 찾고 있다.

수영장에서 판매하고 있는 이용권은 아래와 같이 4 종류이다.

   ① 1일 이용권 : 1일 이용이 가능하다.

   ② 1달 이용권 : 1달 동안 이용이 가능하다. 1달 이용권은 매달 1일부터 시작한다.

   ③ 3달 이용권 : 3달 동안 이용이 가능하다. 3달 이용권은 매달 1일부터 시작한다.
       (11월, 12월에도 3달 이용권을 사용할 수 있다)

   ④ 1년 이용권 : 1년 동안 이용이 가능하다. 1년 이용권은 매년 1월 1일부터 시작한다.

각 달의 이용 계획은 [Table 1]의 형태로 수립된다.

[Table 1]


이용 계획에 나타나는 숫자는 해당 달에 수영장을 이용할 날의 수를 의미한다.

각 이용권의 요금과 각 달의 이용 계획이 입력으로 주어질 때,

가장 적은 비용으로 수영장을 이용할 수 있는 방법을 찾고 그 비용을 정답으로 출력하는 프로그램을 작성하라.


[예시]

수영장에서 판매하는 1일 이용권, 1달 이용권, 3달 이용권, 1년 이용권의 요금은 각각 10원, 40원, 100원, 300원이다.

이 때 수영장을 이용할 수 있는 방법은 [Table 2]와 같이 다양한 경우를 생각할 수 있다.

[Table 2]


다른 경우도 가능하지만, 가장 적은 비용으로 수영장을 이용한 경우는 4번 경우이다.

따라서, 정답은 110이 된다.


[제약 사항]

1. 시간 제한 : 최대 50개 테스트 케이스를 모두 통과하는 데 C/C++/Java 모두 3초

2. 모든 종류의 이용권 요금은 10 이상 3,000 이하의 정수이다.

3. 각 달의 이용 계획은 각 달의 마지막 일자보다 크지 않다.

[입력]

입력의 맨 첫 줄에는 총 테스트 케이스의 개수 T가 주어지고, 그 다음 줄부터 T개의 테스트 케이스가 주어진다.

각 테스트 케이스의 첫 번째 줄에는 1일 이용권의 요금, 1달 이용권의 요금, 3달 이용권의 요금, 1년 이용권의 요금이 순서대로 한 칸씩 띄고 주어진다.

그 다음 줄에는 1월부터 12월까지의 이용 계획이 주어진다.

[출력]

테스트 케이스 개수만큼 T개의 줄에 각각의 테스트 케이스에 대한 답을 출력한다.

각 줄은 "#t"로 시작하고 공백을 하나 둔 다음 정답을 출력한다. (t는 1부터 시작하는 테스트 케이스의 번호이다)

출력해야 할 정답은 이용 계획대로 수영장을 이용하는 경우 중 가장 적게 지출하는 비용이다.


입력
10      			// 총 테스트 케이스 개수 T = 10
10 40 100 300		// 첫 번째 테스트 케이스, 이용권 가격들
0 0 2 9 1 5 0 0 0 0 0 0	// 12개월 이용 계획
10 100 50 300   		// 두 번째 테스트 케이스, 이용권 가격들
0 0 0 0 0 0 0 0 6 2 7 8	// 12개월 이용 계획
…			// 나머지는 수영장.txt 참조

출력
#1 110
#2 100
#3 400
#4 530
#5 430
#6 1080
#7 1840
#8 800
#9 1980
#10 2260

*/

/*

처음에는 모든 조합을 다 짜서 풀어보려고 했는데,
세달이라는 기간이 나올 때는 조합에서는 고려가 어려워 중복되는 조합이 많아지게 되었다.
이를 좀 더 효율적으로 풀기 위해 또 다른 재귀함수를 이용했고, 문제를 해결할 수 있게 되었다.

1) x가 0부터 시작하는 재귀함수를 호출한다.
2) x가 12보다 작다면 plan[x]가 0인지 확인한다.
   만약 0이라면, x를 1 증가시킨 재귀함수를 다시 호출한다.
   0이 아니라면, 0부터 3까지 반복문을 돌린다.
3) i가 0부터 3까지가 의미하는 것은 1일, 1달, 3달, 1년 이용권이다.
   각 숫자에 맞게 x를 증가시키고 sum을 증가시킨 재귀함수를 적절히 호출한다.
4) x가 12보다 크다면 최솟값을 갱신시킨다.
   (여기서 sum이 0이면 안됨을 주의해야 한다.)

*/

#include<iostream>
#include<cstdio>

using namespace std;

int fee[4];
int plan[12];

int myMin;

void getResult(int x, int sum) {
    if(x >= 12) {
        if(sum != 0 && sum < myMin) myMin = sum;
        return;
    }
    
    if(plan[x] == 0) getResult(x+1, sum);
    else {
        for(int i=0; i<4; i++) {
            if(i == 0) getResult(x+1, sum + fee[i] * plan[x]);
            else if(i == 1) getResult(x+1, sum + fee[i]);
            else if(i == 2) getResult(x+3, sum + fee[i]);
            else getResult(x+12, sum + fee[i]);
        }
    }
}

int main(int argc, char** argv)
{
    int test_case;
    int T;
	
    cin>>T;

    for(test_case = 1; test_case <= T; ++test_case)
    {
        myMin = 987987987;
        
        for(int i=0; i<4; i++) scanf("%d", &fee[i]);
        
        for(int i=0; i<12; i++) scanf("%d", &plan[i]);
        
        getResult(0, 0);
        
        printf("#%d %d\n", test_case, myMin);
    }
    return 0;//정상종료시 반드시 0을 리턴해야합니다.
}