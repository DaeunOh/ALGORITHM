/*

시간 : 50개 테스트케이스를 합쳐서 C의 경우 5초 / C++의 경우 5초 / Java의 경우 5초 / Python의 경우 10초
메모리 : 힙, 정적 메모리 합쳐서 256MB 이내, 스택 메모리 1MB 이내
※ SW Expert 아카데미의 문제를 무단 복제하는 것을 금지합니다.
 

두 명의 손님에게 음식을 제공하려고 한다.
두 명의 손님은 식성이 비슷하기 때문에, 최대한 비슷한 맛의 음식을 만들어 내야 한다.
N개의 식재료가 있다.
식재료들을 각각 N / 2개씩 나누어 두 개의 요리를 하려고 한다. (N은 짝수이다.)
이때, 각각의 음식을 A음식, B음식이라고 하자.
비슷한 맛의 음식을 만들기 위해서는 A음식과 B음식의 맛의 차이가 최소가 되도록 재료를 배분해야 한다.
음식의 맛은 음식을 구성하는 식재료들의 조합에 따라 다르게 된다.


식재료 i는 식재료 j와 같이 요리하게 되면 궁합이 잘 맞아 시너지 Sij가 발생한다. (1 ≤ i ≤ N, 1 ≤ j ≤ N, i ≠ j)
각 음식의 맛은 음식을 구성하는 식재료들로부터 발생하는 시너지 Sij들의 합이다.


식재료 i를 식재료 j와 같이 요리하게 되면 발생하는 시너지 Sij의 정보가 주어지고, 
가지고 있는 식재료를 이용해 A음식과 B음식을 만들 때, 
두 음식 간의 맛의 차이가 최소가 되는 경우를 찾고 그 최솟값을 정답으로 출력하는 프로그램을 작성하라.

 

[예시]

N = 4인 예를 생각해보자. 시너지 Sij는 [Table 1]과 같이 주어진다.
(세로축으로 i번째 위치에 있고 가로축으로 j번째 위치에 있는 값이 Sij이다.)
                                        
                                                                      [Table 1]

식재료 1과 식재료 2를 A음식으로 만들고 식재료 3과 식재료 4를 B음식으로 만드는 경우를 생각하자.

1) 식재료 1을 식재료 2와 같이 요리했을 때 발생하는 시너지 S12는 5이다.
2) 식재료 2를 식재료 1과 같이 요리했을 때 발생하는 시너지 S21는 4이다.
3) A음식의 맛은 5 + 4 = 9가 된다.
4) 식재료 3을 식재료 4와 같이 요리했을 때 발생하는 시너지 S34는 3이다.
5) 식재료 4를 식재료 3과 같이 요리했을 때 발생하는 시너지 S43은 3이다.
6) B음식의 맛은 3 + 3 = 6이 된다.

따라서, 두 음식 간의 맛의 차이는 |9 – 6| = 3이 된다.


식재료 2와 식재료 4를 A음식으로 만들고 식재료 1과 식재료 3을 B음식으로 만드는 경우를 생각하자.


7) 식재료 2를 식재료 4와 같이 요리했을 때 발생하는 시너지 S24는 1이다.
8) 식재료 4를 식재료 2와 같이 요리했을 때 발생하는 시너지 S42는 2이다.
9) A음식의 전력은 1 + 2 = 3이 된다.
10) 식재료 1을 식재료 3과 같이 요리했을 때 발생하는 시너지 S13은 3이다.
11) 식재료 3과 식재료 1을 같이 요리했을 때 발생하는 시너지 S31은 2이다.
12) B음식의 맛은 3 + 2 = 5가 된다.

따라서, 두 음식간의 맛의 차이는 |3 – 5| = 2가 된다.
이 경우가 A음식과 B음식 간의 맛의 차이가 최소인 경우이다.
다른 경우에서는 맛의 차이가 2보다 작을 수 없다.
따라서, 본 예의 정답은 2가 된다.


[제약사항]

1. 시간 제한 : 최대 50개 테스트 케이스를 모두 통과하는 데 C / C++ / Java 모두 3초
2. 식재료의 수 N은 4이상 16이하의 짝수이다. (4 ≤ N ≤ 16)
3. 시너지 Sij는 1이상 20,000이하의 정수이다. (1 ≤ Sij ≤ 20,000, i ≠ j)
4. i와 j가 서로 같은 경우의 Sij값은 정의되지 않는다. 입력에서는 0으로 주어진다.


[입력]

입력의 맨 첫 줄에는 총 테스트 케이스의 개수 T가 주어지고,
그 다음 줄부터 T개의 테스트 케이스가 주어진다.
각 테스트 케이스의 첫 번째 줄에는 식재료의 수 N이 주어진다.
다음 N개의 줄에는 N * N개의 시너지 Sij값들이 주어진다. i와 j가 서로 같은 경우는 0으로 주어진다.


[출력]

테스트 케이스 개수만큼 T개의 줄에 각각의 테스트 케이스에 대한 답을 출력한다.
각 줄은 "#t"로 시작하고 공백을 하나 둔 다음 정답을 출력한다. (t 는 1부터 시작하는 테스트 케이스의 번호이다.)
정답은 두 음식 간의 맛의 차이가 최소가 되도록 A음식과 B음식을 만들었을 때 그 차이 값이다.


입력
10	// 총 테스트 케이스의 개수 T = 10
4	// 첫 번째 테스트 케이스, N = 4, 본문 예제
0 5 3 8	// S11, S12, S13, S14
4 0 4 1	// S21, S22, S23, S24
2 5 0 3	// S31, S32, S33, S34
7 2 3 0	// S41, S42, S43, S44
…	// 나머지는 sample_input.txt 참조

출력
#1 2
#2 1
#3 38
#4 15
#5 4
#6 0
#7 51
#8 23
#9 13
#10 11

*/

/*

단순 재귀함수를 이용한 조합을 통해 해결 가능한 문제.
N개의 식재료를 N/2 씩 나누어 가지고, 이를 통해 만든 음식의 맛의 차이가 최소가 되도록 만들면 된다.

예를 들어 N=6이면 A:123 B:456으로 나눠 가질 수 있고,
이 때의 음식의 맛은 S[1][2] + S[2][1] + S[1][3] + S[3][1] + S[2][3] + S[3][2]가 된다.

처음에는 A를 구하면 바로 그에 반대되는 B를 구해서 그 차이를 바로 계산했지만,
그렇게 계산하게되니 내가 짠 조합으로는 차이가 중복해서 2번씩 나타났다.
그 이유는 여기서 구해야 하는 것은 "음식의 맛의 차이"이므로 A:123 B:456의 차이와 A:456 B:123의 차이는 같기 때문이었다.

따라서 나는 시간을 줄이기 위해 중복이 없고 항상 다음 인덱스의 값이 크도록 N/2 길이의 조합을 만들어 냄과 동시에
그 조합을 통해 얻은 음식의 맛을 sum이라는 배열에 저장했다.

그리고 조합을 통해 얻은 모든 sum을 다 구하고 나서는
그 차이를 |sum[i] - sum[sum.size() - 1 - i]| 를 통해 구했고, 이중 최솟값을 myMin에 업데이트 하도록 구현했다.

다른 방법들이 많겠지만, 실행시간도 69ms로 짧게 나왔고,
구현 방법이 복잡하지 않아 만족스럽다!!!ㅎㅎㅎㅎ

*/

#include<iostream>
#include<cstdio>
#include<cstring>
#include<vector>

using namespace std;

const int MAX = 16 + 10;

int N;
int S[MAX][MAX];

int comb[MAX];
int myMin;

vector<int> sum;

void initialize() {
    scanf("%d", &N);
    for(int i=1; i<=N; i++) {
        for(int j=1; j<=N; j++) {
            scanf("%d", &S[i][j]);
        }
    }
    
    sum.clear();
    myMin = 987987987;
}

int getAbs(int x) {
    if(x > 0) return x;
    else return -x;
}

int getResult(int x) {
    int res = 0;
    for(int i=0; i<x; i++) {
        for(int j=0; j<x; j++) {
            if(i == j) continue;
            
            res += S[comb[i]][comb[j]];
        }
    }
    
    return res;
}

void getComb(int x) {
    if(x >= N/2) {
        sum.push_back(getResult(x));
    }
    else {
        for(int i=1; i<=N; i++) {
            if(x == 0 || comb[x-1] < i) {
                comb[x] = i;
                getComb(x+1);
            }
        }
    }
}

void solution() {
    getComb(0);
    
    for(int i=0; i<sum.size()/2; i++) {
        int diff = getAbs(sum[i] - sum[sum.size()-1-i]);
        
        if(myMin > diff) myMin = diff;
    }
}

int main(int argc, char** argv)
{
    int test_case;
    int T;

    cin>>T;

    for(test_case = 1; test_case <= T; ++test_case)
    {
        initialize();
        solution();
        
        printf("#%d %d\n", test_case, myMin);
    }
    return 0;//정상종료시 반드시 0을 리턴해야합니다.
}