// 소요시간: 1시간 9분
// 실행시간: 7ms

/*

시간 : 50개 테스트케이스를 합쳐서 C의 경우 3초 / C++의 경우 3초 / Java의 경우 3초 / Python의 경우 15초
메모리 : 힙, 정적 메모리 합쳐서 256MB 이내, 스택 메모리 1MB 이내
※ SW Expert 아카데미의 문제를 무단 복제하는 것을 금지합니다.

스마트폰을 무선 충전 할 때 최적의 BC (Battery Charger)를 선택하는 알고리즘을 개발하고자 한다. 
[그림 1]과 같이 가로 세로 10*10 영역의 지도가 주어졌을 때, 설치된 BC 정보는 다음과 같다.
               
                                                             [그림 1]


BC의 충전 범위가 C일 때, BC와 거리가 C 이하이면 BC에 접속할 수 있다. 
이때, 두 지점 A(XA, YA), B(XB, YB) 사이의 거리는 다음과 같이 구할 수 있다.

D = |XA – XB| + |YA – YB|

위의 [그림 1]에서 (4,3)과 (5,4) 지점은 BC 1과 BC 3의 충전 범위에 모두 속하기 때문에, 
이 위치에서는 두 BC 중 하나를 선택하여 접속할 수 있다.
              
                                                              [그림 2]
 

[그림 2]와 같이 사용자 A와 B의 이동 궤적이 주어졌다고 가정하자. 
T는 초(Second)를 의미한다. 
예를 들어 5초에 사용자 A는 (5, 2) 지점에, 사용자 B는 (6, 9) 지점에 위치한다.

매초마다 특정 BC의 충전 범위에 안에 들어오면 해당 BC에 접속이 가능하다. 
따라서 T=5에 사용자 A는 BC 3에, 사용자 B는 BC 2에 접속할 수 있다. 
이때, 접속한 BC의 성능(P)만큼 배터리를 충전 할 수 있다. 
만약 한 BC에 두 명의 사용자가 접속한 경우, 접속한 사용자의 수만큼 충전 양을 균등하게 분배한다.

BC의 정보와 사용자의 이동 궤적이 주어졌을 때, 
모든 사용자가 충전한 양의 합의 최댓값을 구하는 프로그램을 작성하라.
 

[그림 2]에서 T=11일 때, 사용자 A는 BC 1과 3 둘 중 하나에 접속이 가능하다. 
같은 시간에 사용자 B는 BC 1에 접속할 수 밖에 없다. 
따라서 사용자 A가 같은 BC 1에 접속한다면 충전되는 양를 반씩 나눠 갖게 되어 비효율적이다. 
따라서 사용자 A가 BC 3에 접속하는 것이 더 이득이다.
 
[표 1]


위 예제에서 매 초마다 충전한 양은 다음과 같다. 따라서 총 충전한 양의 총합은 720 + 480 = 1200 이다.

[표 2]

 

[제약사항]

1. 지도의 가로, 세로 크기는 10이다.
2. 사용자는 총 2명이며, 사용자A는 지도의 (1, 1) 지점에서, 사용자B는 지도의 (10, 10) 지점에서 출발한다.
3. 총 이동 시간 M은 20이상 100이하의 정수이다. (20 ≤ M ≤ 100)
4. BC의 개수 A는 1이상 8이하의 정수이다. (1 ≤ A ≤ 8)
5. BC의 충전 범위 C는 1이상 4이하의 정수이다. (1 ≤ C ≤ 4)
6. BC의 성능 P는 10이상 500이하의 짝수이다. (10 ≤ P ≤ 500)
7. 사용자의 초기 위치(0초)부터 충전을 할 수 있다.
8. 같은 위치에 2개 이상의 BC가 설치된 경우는 없다. 
   그러나 사용자A, B가 동시에 같은 위치로 이동할 수는 있다. 사용자가 지도 밖으로 이동하는 경우는 없다.
 

[입력]

입력의 맨 첫 줄에는 총 테스트 케이스의 개수 T가 주어지고, 그 다음 줄부터 T개의 테스트 케이스가 주어진다.
테스트 케이스의 첫 번째 줄에는 총 이동 시간(M), BC의 개수(A)가 주어진다.
그 다음 2개의 줄에는 각각 사용자 A와 B의 이동 정보가 주어진다.
한 사용자의 이동 정보는 M개의 숫자로 구성되며, 각각의 숫자는 다음과 같이 매초마다 이동 방향을 의미한다.
 
[표 3]


그 다음 줄에는 A개의 줄에 걸쳐 BC의 정보가 주어진다.
하나의 BC 정보는 좌표(X, Y), 충전 범위(C), 처리량(P)로 구성된다.

 

[출력]

출력은 "#t"를 찍고 한 칸 띄운 다음 정답을 출력한다. (t는 테스트 케이스의 번호를 의미하며 1부터 시작한다.)
정답은 모든 사용자의 충전량 합의 최대값을 출력한다.

입력
5				// 총 테스트 케이스 개수 T=5
20 3				// 첫 번째 테스트 케이스: M=20, A=3
2 2 3 2 2 2 2 3 3 4 4 3 2 2 3 3 3 2 2 3	// 사용자A의 이동 정보
4 4 1 4 4 1 4 4 1 1 1 4 1 4 3 3 3 3 3 3	// 사용자B의 이동 정보
4 4 1 100				// AP 1의 정보 (4, 4), C1=1, P1=100
7 10 3 40				// AP 2의 정보 (7, 10), C2=3, P2=40
6 3 2 70				// AP 3의 정보 (6, 3), C3=2, P3=70
…				// 나머지는 sample_input.txt 참조


출력
#1 1200
#2 3290
#3 16620
#4 40650
#5 52710

*/

/*

구현이 복잡해보이지만 복잡하게 생각하지 말고 천천히 조건에 맞춰서 구현한다면 어렵지 않은 시뮬레이션 문제.
핵심은 BC의 범위가 겹쳤을 때 어떻게 해결하느냐에 있다!

1) 맵을 2차원 배열으로 만들고, 그 배열 한 자리가 하나의 벡터로 이루어지게 설정한다.
    그리고 BC의 범위에 포함되는 지점에다가 BC의 인덱스를 넣어줌으로써
    맵의 한 지점에 어떤 BC가 존재하는지 표시한다.

2) 시간에 따라 플레이어를 이동시킨다.
    (이때 주의할 점은 t=0일 때도 충전을 할 수 있으므로,
    t=0일 때는 움직이지 않게끔 플레이어의 t=0의 이동 정보는 0이어야 한다.)

3) 매 초마다 플레이어의 방향에 따라 위치를 새로 계산하고, 해당 지점에서의 BC를 보면서
    각 플레이어가 사용할 BC(처리량이 최대인 것)를 따로 따로 찾는다.
    3-1) 만약 각자가 사용할 BC가 서로 다른 경우에는 서로의 처리량에 영향을 주지 않으므로 해당 처리량을 누적시킨다.
    3-2) 각자가 사용할 BC가 겹치는 경우에는 이중 반복문을 이용하여 처리량의 합이 가장 큰 경우를 찾는다.

위와 같은 방법을 이용하면, 어떤 플레이어가 충전을 할 수 있든 없든에 상관 없이
어떤 플레이어라도 충전을 할 수 있다면 최대 효율을 얻는 방법으로 무선 충전이 가능해진다.

실수하지 않기 위해 중간 중간에 선택되는 BC 또는 처리량을 출력하면서 구현했더니
예제 입력 및 히든 테스트 케이스 모두 한 번에 통과할 수 있었다!! (뿌듯!!!ㅎㅎㅎㅎㅎㅎ)

*/

#include<iostream>
#include<cstdio>
#include<vector>
#include<cstring>

using namespace std;

const int MAX = 10 + 10;
const int MAXM = 100 + 10;

int M, A;
vector <int> map[MAX][MAX];

int a[MAXM], b[MAXM];
vector <int> BC;

int dx[5] = {0, 0, 1, 0, -1};
int dy[5] = {0, -1, 0, 1, 0};

int getAbs(int x) {
    if(x > 0) return x;
    else return -x;
}

void setBC(int idx, int X, int Y, int C) {
    for(int i=1; i<=10; i++) {
        for(int j=1; j<=10; j++) {
            int D = getAbs(X - i) + getAbs(Y - j);
            if(D <= C) map[i][j].push_back(idx);
        }
    }
}

int moveAB() {
    int aSum = 0, bSum = 0;
    int aX = 1, aY = 1, bX = 10, bY = 10;
    for(int t=0; t<=M; t++) {
        // a와 b의 위치 계산
        aX += dx[a[t]];
        aY += dy[a[t]];
        bX += dx[b[t]];
        bY += dy[b[t]];
        
        // a가 사용할 BC 찾기
        int aBC = -1, bBC = -1;
        int aMax = 0, bMax = 0;
        for(int i=0; i<map[aX][aY].size(); i++) {
            if(aMax < BC[map[aX][aY][i]]) {
                aMax = BC[map[aX][aY][i]];
                aBC = map[aX][aY][i];
            }
        }
        
        // b가 사용할 BC 찾기
        for(int i=0; i<map[bX][bY].size(); i++) {
            if(bMax < BC[map[bX][bY][i]]) {
                bMax = BC[map[bX][bY][i]];
                bBC = map[bX][bY][i];
            }
        }
        
        if(aBC != bBC) { // 사용할 BC가 서로 다른 경우
            if(aBC != -1) aSum += aMax;
            if(bBC != -1) bSum += bMax;
        }
        else if(aBC != -1 && aBC == bBC) { // 사용할 BC가 서로 같은 경우
            int aTemp, bTemp;
            int myMax = 0;
            
            // 처리량의 합이 가장 큰 경우를 찾는다.
            for(int i=0; i<map[aX][aY].size(); i++) {
                for(int j=0; j<map[bX][bY].size(); j++) {
                    if(map[aX][aY][i] == map[bX][bY][j]) {
                        aTemp = BC[map[aX][aY][i]] / 2;
                        bTemp = BC[map[bX][bY][j]] / 2;
                    }
                    else {
                        aTemp = BC[map[aX][aY][i]];
                        bTemp = BC[map[bX][bY][j]];
                    }
                    
                    if(myMax < aTemp + bTemp) {
                        myMax = aTemp + bTemp;
                        aMax = aTemp;
                        bMax = bTemp;
                    }
                }
            }
            
            aSum += aMax;
            bSum += bMax;
        }
    }
    
    return aSum + bSum;
}

int main(int argc, char** argv)
{
    int test_case;
    int T;
    
    cin>>T;
    
    for(test_case = 1; test_case <= T; ++test_case)
    {
        a[0] = 0;
        b[0] = 0;
        BC.clear();
        for(int i=1; i<=10; i++) {
            for(int j=1; j<=10; j++) {
                map[j][i].clear();
            }
        }
        
        scanf("%d %d", &M, &A);
        for(int i=1; i<=M; i++) scanf("%d", &a[i]);
        for(int i=1; i<=M; i++) scanf("%d", &b[i]);
        
        for(int i=0; i<A; i++) {
            int X, Y, C, P;
            scanf("%d %d %d %d", &X, &Y, &C, &P);
            
            setBC(i, X, Y, C);
            BC.push_back(P);
        }
        
        printf("#%d %d\n", test_case, moveAB());
    }
    return 0;//정상종료시 반드시 0을 리턴해야합니다.
}