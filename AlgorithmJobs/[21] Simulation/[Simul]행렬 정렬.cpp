/*

시간제한 1초

문제
N * M 행렬이 주어진다. 해당 행렬은 다음과 같은 규칙이 적용된다.

현재 행렬의 상태에서 행의 개수가 열의 개수보다 크거나 같을 때, 행 정렬을 시행한다.
열의 개수가 행의 개수보다 클 때, 열 정렬을 시행한다.
이때, 행 정렬과 열 정렬은 일반적으로 알고 있는 정렬과 달리 숫자의 개수를 기준으로 정렬을 한다. 
단계별로 설명하면 다음과 같다.

1. 한 행이나 열에 존재하는 숫자들의 개수를 세어준다. 
예를 들어, 숫자가 1 1 3 2 2 5 1 이 있다고 하면, 1이 3개, 2가 2개, 3이 1개, 5가 1개 있다.

2. 숫자의 개수가 적은 순으로 정렬을 한다. 
만약, 숫자의 개수가 같다면 작은 숫자가 앞으로 간다. 
1번에서 본 예제를 정렬하면 (3, 1), (5, 1), (2, 2), (1, 3) 이다.

3. 정렬한 결과를 해당 행이나 열에 덮어씌운다. 
1 1 3 2 2 5 1 이였던 수열은 3 1 5 1 2 2 1 3 으로 바뀌게 된다. 
만약 수열의 길이가 100을 넘어간다면, 101번째 숫자부터는 버린다.

4. 모든 행(열)에 대해 정렬을 시행한다. 
만약 몇몇 행(열)이 최대 행(열)의 크기보다 숫자의 길이가 작은 경우 나머지 길이에 대해서는 0을 채운다.

5. 1~4의 과정을 마치면 1회 시행이 종료됐다고 정의한다.

N * M 행렬, 특정 원소 위치 r, c와 r행 c열에 나왔으면 하는 숫자 k 가 주어졌을때, 
최소 몇 회 시행을 해야되는지 알아보자.

예를 들어, 2 * 3의 행렬이 아래와 같이 주어지고, r=3, c=3, k=5 라고 하자.

1 1 2
5 2 1

현재 열의 개수가 행의 개수보다 크기때문에 열 정렬을 시행한다.
1열 - (1, 1), (5, 1), 2열 - (1, 1), (2, 1), 3열 - (1, 1), (2, 1)

1 1 1
1 1 1
5 2 2
1 1 1

행의 개수가 열의 개수보다 크기때문에 행 정렬을 시행한다.
1행 - (1, 3), 2행 - (1, 3), 3행 - (2, 2), (5, 1), 4행 - (1, 3)

1 3 0 0
1 3 0 0
5 1 2 2
1 3 0 0

행의 개수와 열의 개수가 같으므로 행 정렬을 시행한다.
1행 - (1, 1), (3, 1), 2행 - (1, 1), (3, 1), 3행 - (1, 1), (2, 2), (5, 1), 4행 - (1, 1), (3, 1)

1 1 3 1 0 0
1 1 3 1 0 0
1 1 5 1 2 2
1 1 3 1 0 0

이때, 행렬의 3행 3열의 값이 5가되므로 최소 시행 횟수는 3이된다.

 

입력
첫 번째 줄에 테스트 케이스의 개수 T가 주어진다. 
다음 줄부터 T개의 테스트 케이스에 대한 정보가 주어진다. 
각각의 테스트 케이스의 첫 번째 줄에 N, M, r, c, k 가 공백을 통해 구분하여 주어진다. 
두 번째 줄부터 N개의 줄에 걸쳐 한 줄에 M 개의 숫자가 공백을 통해 구분하여 주어진다. 
행렬로 주어지는 각각의 숫자는 100보다 작거나 같은 자연수이다. 
(3 ≤ N, M ≤ 5, 1 ≤ r, c, k ≤ 100)

 

출력
각 테스트 케이스에 대해 최소 시행 횟수를 출력한다. 
만약 최소 시행 횟수가 100을 초과할 경우 -1을 출력한다. 
각 테스트 케이스의 출력 양식은 "#t r"이다. 
t는 테스트 케이스의 번호이며, 1부터 시작한다. 
r은 문제에 대한 결과값을 뜻한다.

 

예제 입력
5
2 3 3 3 5
1 1 2
5 2 1
3 3 1 5 1
4 3 1 
3 2 4 
1 3 2 
4 4 2 3 5
5 5 1 4 
1 5 4 5 
1 5 4 3 
1 5 1 1 
3 3 4 2 1
4 5 3 
4 1 1 
2 5 1 
4 3 3 4 4
1 1 5 
2 5 3 
2 1 1 
4 5 4 
예제 출력
#1 3
#2 3
#3 -1
#4 3
#5 5

*/

/*

행 또는 열에 존재하는 숫자의 개수를 가지고 행 또는 열을 정렬하는 시뮬레이션 문제이다.
2차원 배열이 가로, 세로 최대 100까지밖에 늘어나지 않기 때문에 완전탐색으로 구현이 가능해서
구현 자체는 생각보다 쉬웠으나, 생각지도 못한 문제들 때문에 오류를 해결하느라 시간이 오래 걸렸다.

시뮬레이션이기 때문에 문제에 해당하는 규칙들은 코드에 주석으로 자세히 달아놓았다.
배열 초기화 문제나 빠뜨린 규칙은 오늘도 존재했으나... 출력을 통해 금방 문제점을 찾을 수 있었다.


오늘 가장... 해결하는데 오래 걸렸던 부분은 총 2가지 존재한다.

1. 최대 행(또는 열)의 크기를 저장해두는 부분에서,
   다음과 같이 벡터의 사이즈*2와 myMax를 비교해 더 큰 값을 myMax에 할당하도록 구현하고자 했다.

   maxCol = max(maxCol, v.size * 2);
   
   처음에는 maxCol의 초기값을 그동안 해왔던 것처럼 -987987987을 할당해놨는데,
   maxCol보다 v.size() * 2가 큼에도 바뀌지가 않았다.

   그 이유는 벡터의 사이즈와 int 변수를 비교하는 부분에서는 int 변수가 0 이상이어야 제대로 동작하기 때문이었다.
   초기값을 음수로 설정해주는 바람에 벡터 사이즈와 비교가 안돼서 변수 할당이 제대로 되지 않았던 것이다.
   왜 그런지는 잘 모르겠으나... maxCol을 처음부터 0으로 초기화 해주었더니 문제가 해결되었다.
   (또는 v.size() * 2를 다른 int 변수에 저장해두고, 그 변수와 비교해줘도 상관없다.)

2. 숫자 개수가 적은 순으로 정렬을 하기 이전에 벡터에 push_back을 하는 부분에서,
   반복문이 1부터 100으로 증가하는 순이기 때문에 비교하는 함수를 사용할 때, 
   이미 작은 숫자대로 정렬되어 있으니 추가적으로 숫자 개수만 비교하면 된다고 생각했다.

   그래서 비교 함수를 다음과 같이 작성했었다.

   bool comp(NUM &a, NUM &b) {
     return a.c < b.c;
   }

   하지만 확인해본 결과, vector의 크기가 작을 때는 제대로 push_back 및 sort가 되지만,
   vector의 크기가 클 때는(17이 넘어가면) push_back은 제대로 동작하나 sort가 부분적으로만 동작되어,
   숫자 크기 순으로 정렬되어 있던게 다 깨지게 되었다.

   따라서 숫자 개수가 같을 때는 숫자 크기가 작은 순으로 정렬이 되게끔

   bool comp(NUM &a, NUM &b) {
     if(a.c == b.c) return a.n < b.n;
     else return a.c < b.c;
   }

   위와 같이 바꿔 주었더니 문제를 해결할 수 있었다.


설계가 잘못 되었거나 구현에 실수가 있었던 건 아니라 안도했지만...
이게 시험이었다면 정말 멘붕이 왔을 것 같다 ㅎㅎㅎㅎ;;;;;
지금이라도 알게 되어서 다행이다... 아직 내가 모르는 게 더 많을텐데 무서워 죽겠다...ㄷㄷㄷ
그래도 시험 전까지 모르는 걸 최대한 없애기 위해서 많은 문제를 풀어봐야겠다!!

*/

#include <cstdio>
#include <vector>
#include <cstring>
#include <algorithm>

using namespace std;

const int MAX = 100 + 10;

int T;
int N, M, r, c, k;
int arr[MAX][MAX];

int cnt[MAX];

struct NUM {
  int n, c;
  
  NUM(int _n, int _c) {
    n = _n;
    c = _c;
  }
};

vector<NUM> v;

bool comp(NUM &a, NUM &b) {
  // 숫자의 개수가 적은 순으로 정렬을 한다. 만약, 숫자의 개수가 같다면 작은 숫자가 앞으로 간다. 
  if(a.c == b.c) return a.n < b.n;
  else return a.c < b.c;
}

void sortRows() {
  int maxCol = 0;
  for(int i=0; i<N; i++) {
    // 숫자 개수 저장하는 배열 및 벡터 초기화
    memset(cnt, 0, sizeof(cnt));
    v.clear();
    
    // 1. 한 행에 존재하는 숫자들의 개수를 세어준다. 
    for(int j=0; j<M; j++) cnt[arr[i][j]]++;
    
    // 행이 최대 행의 크기보다 숫자의 길이가 작은 경우를 대비해 미리 0을 채워둔다.
    for(int j=0; j<M; j++) arr[i][j] = 0;
    
    // 벡터에 (숫자, 숫자개수) 를 삽입한다.
    for(int j=1; j<=100; j++) {
      if(cnt[j] != 0) {
        v.push_back(NUM(j, cnt[j]));
      }
    }
    
    // 2. comp라는 비교 함수를 이용하여 숫자 개수를 오름차순으로 정렬하고,
    //     개수가 같은 경우에는 작은 숫자가 앞으로 오게 한다.
    sort(v.begin(), v.end(), comp);
    
    // 최대 행의 크기를 저장한다.
    maxCol = max(maxCol, v.size * 2);
    
    // 3. 정렬한 결과를 해당 행이나 열에 덮어씌운다. 
    //    만약 수열의 길이가 100을 넘어간다면, 101번째 숫자부터는 버린다.
    for(int j=0; j<v.size(); j++) {
      if(j*2 > 100) break;
      
      arr[i][j*2] = v[j].n;
      arr[i][j*2+1] = v[j].c;
    }
  }
  
  // 열의 개수를 바꿔준다. (단, 100을 넘어가지 않는 범위에서)
  M = min(100, maxCol);
}

void sortCols() {
  int maxRow = 0;
  for(int i=0; i<M; i++) {
    memset(cnt, 0, sizeof(cnt));
    v.clear();
    
    for(int j=0; j<N; j++) cnt[arr[j][i]]++;
    
    for(int j=0; j<N; j++) arr[j][i] = 0;
    
    for(int j=1; j<=100; j++) {
      if(cnt[j] != 0) {
        v.push_back(NUM(j, cnt[j]));
      }
    }
    
    sort(v.begin(), v.end(), comp);
    
    maxRow = max(maxRow, v.size() * 2);
    
    for(int j=0; j<v.size(); j++) {
      if(j*2 > 100) break;
      
      arr[j*2][i] = v[j].n;
      arr[j*2+1][i] = v[j].c;
    }
  }
  
  N = min(100, maxRow);
}

int solution() {
  int count = 0;
  while(arr[r-1][c-1] != k) {
    count++;
    if(count > 100) return -1;
    
    // 행의 개수와 열의 개수 비교
    if(N >= M) sortRows();
    else sortCols();
  }
  
  return count;
}

int main() {
  scanf("%d", &T);
  
  for(int t=1; t<=T; t++) {
    scanf("%d %d %d %d %d", &N, &M, &r, &c, &k);
    
    memset(arr, 0, sizeof(arr));
    
    for(int i=0; i<N; i++) {
      for(int j=0; j<M; j++) {
        scanf("%d", &arr[i][j]);
      }
    }
    
    printf("#%d %d\n", t, solution());
  }

  return 0;
}