# 0. 그래프 알고리즘 (Graph Algorithm)
    
* ### 최단 경로 알고리즘 (Shortest Path Finding Algorithm)  
    A에서 B까지 최단 경로를 구하는 알고리즘  

* ### 최소 신장 트리 (Minimum Spaning Tree)  
    간선 몇 개를 제거해서 트리를 만드는 알고리즘  

* ### SCC (Strongly Connected Componenet)  
    그래프 덩어리를 찾는 알고리즘  
<br>

# 1. 최단 경로 알고리즘 (Shortest Path Finding Algorithm)  

## 1.1. 최단경로 문제와 알고리즘  

### 1.1.1. 최단경로 문제란?  
어떤 정점에서 다른 정점까지 최단 거리로 이동하고 싶을 때, 어떤 경로로 이동해야 하느냐를 이해하는 문제  
`cost(weight) : 간선의 가중치`  
<br>

### 1.1.2. 최단경로 알고리즘의 종류
+ **다익스트라 알고리즘 (Dijkstra's Algorithm)**  

    하나의 정점에서 모든 정점까지 최단거리를 구하는 알고리즘    
    `(단, 간선의 가중치가 양수일 때만 사용할 수 있다.)`  

+ **플로이드 알고리즘 (Floyd Algorithm)**  

    모든 정점에서 모든 정점까지 최단거리를 구하는 알고리즘  
    `(모든에서 모든을 구하기 때문에 시간은 오래 걸린다.)`

+ **벨만포드 알고리즘 (Bellman-Ford Algorithm)**  

    하나에서 모든 정점까지 최단거리를 구하는 알고리즘  
    `(간선의 가중치에 음수가 섞여 있어도 상관 없다.)`  
<br>

## 1.2. 최단경로의 특징
정점 X까지 가기 위해서는 그 직전까지도 최단경로로 가야한다.  

예를 들어 목표지점 X에 연결되어 있는 노드 Y1, Y2, Y3가 있다고 하면,  
이 상황에서 X까지의 최단경로는 Y1, Y2, Y3까지 어떻게든 최단경로로 와서 X까지 갔을 때의 최솟값이다.  

`min(T[Y1] + cost1, T[Y2] + cost2, T[Y3] + cost3)`  
<br>


## 1.3. 다익스트라 알고리즘
하나의 정점에서 모든 정점까지 최단거리를 구하는 알고리즘  

기본 로직은 시작 정점을 기준으로 연결되어 있는 정점들로 뻗어 나가며 최단거리를 업데이트 하는 것이다.  
시작 정점의 최단거리는 0으로 시작하며, 그외 다른 정점들은 무한대로 시작한다.  

```cpp
T[i] = 정점 i까지 도달하기 위한 최단거리

1) 지금까지 방문 되지 않은 정점의 최단거리 중에서 최솟값을 찾는다.  
    if(!visited[j] && myMin > T[j]) myMin = T[j]

2) 그 최솟값을 방문 처리한 후에, 그 정점으로부터 다른 정점으로 뻗어 나가며 최단거리를 업데이트 시킨다.  
    T[nextNode] = min(T[nextNode], myMin + cost)
```  
<br>

# 2. 최소 신장 트리 (Minimum Spaning Tree)  

## 2.1. 스패닝 트리 (Spanning Tree)  

### 2.1.1. 스패닝 트리란?  
그래프의 모든 노드를 포함하는 트리  
`Tree : 사이클이 없는 그래프`  

한 가지 그래프가 있으면 여러 스패닝 트리가 존재할 수 있다.  
<br>

### 2.1.2. 최소 신장 트리란?  
간선의 가중치를 합하면 스패닝 트리의 weight를 알 수 있는데,  
이때 weight가 가장 작은(최소인) 트리가 `최소 신장 트리(MST)`이다.  
<br>

## 2.2. Cut Property  
두 개의 Tree를 연결하여 하나의 Tree를 만들어야 하는데,  
한 그래프에서 T1, T2의 트리가 있고, 그 사이에 연결되지 않은 간선이 있다면 T1은 그 그래프의 하나의 cut이다.  

이때 두 개의 cut을 가지고 MST를 만들고 싶다면 가장 가중치가 작은 간선을 잇는게 좋으며, 이것이 `Cut Property`이다.  
또한, 가장 가중치가 작은 이 간선은 추후 MST에 포함된다.  
<br>

## 2.3. 크루스칼 알고리즘 (Kruskal's Algorithm)
그래프에서 하나의 MST를 만들기 위해서는 각 정점을 하나의 MST로 시작한다.  
그리고 여러 개의 간선 중에 weight가 작은 것부터 연결해나간다.  
만약 연결하는 순간 사이클이 생긴다면 그 간선은 연결하지 않는다.  

하지만 크루스칼 알고리즘을 사용하기 위해서는 해결하기 힘든 2가지 issue가 존재한다.  

```cpp
1) 간선을 가중치 순으로 정렬하는 것이 어렵다.
2) 사이클을 판단하기가 어렵다.
```

1번의 경우 따로 비교함수를 만들어 sort함수를 사용하면 되지만, 2번은 어떻게 해결해야 할까?  
사이클을 판단하기 위해서는 먼저 사이클이 생기는 조건부터 알아야 한다.  
<br>

## 2.4. 사이클이 생기는 조건
사이클이 생기는 조건은 "하나의 트리 내에서 간선이 추가되었을 때" 이다.  
즉, 서로 다른 트리가 합쳐지면 사이클이 생기지 않지만,  
같은 트리에 포함되어 있는 간선이 연결되면 사이클이 생긴다는 것이다.  

따라서 사이클이 생기는지 생기지 않는지 판단하기 위해서는  
하나의 간선을 이을 때 연결되는 두 정점이 현재 같은 트리에 포함되어 있는지를 판단하면 된다.  
이를 위한 자료구조로 `Disjoint Set`이 존재한다.  
<br>

## 2.5. Disjoint Set
Disjoint Set은 2가지 연산으로 구성된다.  

```cpp
1) 두 정점이 같은 그룹에 속하는지 확인한다.
2) 두 정점을 하나의 그룹으로 묶는다.
```

이 자료구조를 크루스칼 알고리즘에 사용하기 위해 한가지 그룹을 한가지 트리로 나타내고,  
같은 트리인지 판단하기 위한 지표로 그룹의 대표를 트리의 root로 설정한다.  

이를 크루스칼 알고리즘에 적용하면,
```cpp
1) 두 정점의 대표(root)를 비교한다.
2) 서로 root가 다르다면 서로 다른 트리에 포함되어 있다는 뜻이므로 두 트리를 합친다.
    (합칠 때는 하나의 대표를 다른 대표의 자식노드로 만드는 방식을 사용한다.)
```  
<br>

## 2.6. 크루스칼 알고리즘의 구현
크루스칼 알고리즘은 각 노드를 하나의 MST로 시작하므로, 초기에 각 노드의 root를 자신으로 설정해준다.
```cpp
for(int i=1; i<=N; i++) root[i] = i;
```  
<br>

두 노드(트리)를 합치기 전에 root를 확인하는 방법으로는 재귀함수를 사용한다.  
자신이 root라면 자신을 반환하고, root가 아니라면 root를 찾을 때까지 위로 거슬러 올라간다.  
```cpp
int find(int node) {
  if(root[node] == node) return node;
  else return find(root[node]);
}
```  
<br>

루트가 같다면 함수를 종료하고, 같지 않다면 두 노드(트리)를 합친다.  
이때 트리를 합치기 위해서는 한 노드의 root를 다른 노드의 root로 바꿔주면 된다.  
```cpp
void union(int a, int b) {
  a = find(a);
  b = find(b);

  if(a == b) return;
  
  root[b] = a;
}
```  
<br>

# 3. SCC (Strongly Connected Component)  

## 3.1. SCC  

### 3.1.1. Connected Component  
Connected Component를 구하는 것은 한 그래프를 연결되어 있는 그래프끼리 나누는 것을 의미한다.  
이는 DFS나 BFS와 같은 그래프 순회로 해결할 수 있다.    
<br>

### 3.1.2. Strongly Connected Component  
하지만 'Connected'의 의미가 방향성 그래프에서는  
`A → B and B → A`처럼 항상 '두 노드 사이에 길이 있다'는 것을 의미한다.

따라서 노드 간의 이동이 항상 가능한 그룹(그래프)을 구하는 것이 `SCC`를 구하는 것이 된다.  
<br>

## 3.2. SCC를 찾는 방법   
SCC는 하나의 그룹을 하나의 정점으로 보는 `Meta-Graph`로 표현될 수 있다.  
Meta-Graph는 항상 cycle이 존재하지 않는다.  
(cycle이 있었다면 애초에 한 그룹으로 묶였어야 하기 때문)   
<br>

그럼 Meta-Graph를 활용하여 어떻게 SCC를 찾을 수 있을까?  

```cpp
Idea 1) SCC가 존재한다고 가정한다.
Idea 2) Meta-Graph의 가장 끝 노드를 찾는다.
Idea 3) 그 노드 안에 존재하는 노드 중 아무 노드 한 개를 시작으로 한 traverse는 하나의 그룹을 뽑아낼 수 있다.
        (그리고 이 그룹은 하나의 Meta-Node가 된다.)
```   

Idea 3)에 의해 그룹 안의 모든 노드를 구할 수 있고, 그 노드들을 그래프에서 지우는 과정을 반복하면  
최종적으로 SCC를 구할 수 있게 된다.  
<br>

하지만 어떻게 Meta-Node의 가장 끝 노드를 구하여 그 안의 vertex v를 잡을 수 있을까?  

```cpp
Idea 1) DFS를 통해서 부모-자식 관계를 파악할 수 있다.
Idea 2) 그래프의 간선 방향을 모두 뒤집는다.
```

Idea 1)에 의해 부모-자식 관계를 파악하면, 주어진 그래프는 방향성 그래프이기 때문에  
부모는 항상 모든 자식에게 갈 수 있지만 자신의 부모로는 갈 수 없다는 특성을 이용할 수 있다.  
즉, 그 노드는 Meta-Graph를 그렸을 때 자신보다 상위에 있는 Meta-Node에 해당하는 정점에는 갈 수 없게 된다.  

또한, Idea 2)에 의해 간선 방향을 뒤집으면, Meta-Graph에서 존재하던 자식이 안 보이게 된다.  
따라서 자신이 단말노드가 될 수 있으므로, 그 안에 있는 한 노드를 기준으로 순회하면 SCC를 얻을 수 있다.  
즉, 처음에 잡았던 노드에 해당하는 Meta-Node를 없앨 수 있게 되는 것이다.  
<br>

## 3.3. 코사라주 알고리즘 (Kosaraju Algorithm)  
3.2.에서 Meta-Node를 구하는 방법을 알아보았다.  
하지만 위와 같은 방법은 한 노드를 잡고, DFS를 돌리고, 간선의 방향을 뒤집는 과정이 여러 번 중복된다.  
Meta-Node을 조금 더 효율적으로 한 번에 구할 수는 없을까?  
이는 `코사라주 알고리즘`을 사용하면 가능하다!  

코사라주 알고리즘에서는 `"노드를 방문하면서 빠져나오는 시간을 따로 기록하는 것"`이 필요하다.  
즉, 한 노드를 기준으로 DFS를 돌려서 갈 수 있는 곳까지 간 다음  
그 마지막 노드부터 첫 노드까지 빠져나오는 시간을 기록하는 것이다.  

그렇게 되면 마지막 노드일 수록 작은 시간이 기록되기 때문에  
값이 큰 노드가 간선의 방향을 뒤집었을 때의 마지막 노드가 되며,  
그 노드부터 DFS를 돌리면 한 번에 여러 Meta-Node를 구할 수 있게 된다.  

위와 같은 방법을 사용하면 빠져나오는 시간을 얻기 위해 한 노드로 시작하는 DFS 1번,  
그리고 빠져나오는 시간이 큰 수로부터 시작하는 DFS 1번 총 2번의 DFS만으로 SCC를 구할 수 있게 되고,  
이에 따른 시간복잡도는 `O(V+E)`가 된다.  
<br>

## 3.4. 코사라주 알고리즘의 구현  
코사라주 알고리즘은 빠져나오는 시간을 필요로 하므로,  
방문하지 않은 노드부터 시작해서 DFS를 하면서 빠져나오는 순서대로 시간을 기록한다.  
그리고 이와 동시에 빠져나오는 순서대로 노드 번호도 함께 기록한다.

```cpp
void getTime(int node) {
  visited[node] = true;
  
  for(int i=0; i<graph[node].size(); i++) {
    int node2 = graph[node][i];
    
    if(!visited[node2]) getTime(node2);
  }
  
  time[node] = clock;
  clock++;
  
  order[orderLen++] = node; // 빠져나오는 시간이 작은 순서대로 기록될 것이다.
}
```  
<br>

이후 간선 방향을 뒤집는 것이 필요한데, 간선 방향을 뒤집는 과정을 추가적으로 거치는 것보다  
처음 input을 입력받을 때 간선 방향을 반대로 한 reverseGraph를 미리 구해놓는 것이 좋다.  

뒤집은 그래프에 대해서는 빠져나오는 시간이 큰 노드부터 순회해야 하는데,  
order에는 빠져나오는 시간이 작은 순서대로 기록되어 있기 때문에 맨 끝부터 반복문을 돌린다.  
이때 만나는 노드들은 모두 같은 그룹이 된다.  

그룹을 구하기 위한 순회는 다음과 같다.  
```cpp
void getMyGroup(int node) {
  visited2[node] = true;
  group[node] = groupCnt; // group[i] = 정점 i가 속한 그룹
  
  for(int i=0; i<reverseGraph[node].size(); i++) {
    int node2 = reverseGraph[node][i];
    
    if(!visited2[node2]) getMyGroup(node2);
  }
}
```  
<br>

위와 같은 과정을 모두 거치면 SCC가 되는 그룹이 몇 개인지를 알 수 있으며,  
각 노드가 어떤 그룹에 속하는지도 알 수 있게 된다.  
