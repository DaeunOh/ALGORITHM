# 0. 그래프 알고리즘 (Graph Algorithm)
    
* ### 최단 경로 알고리즘 (Shortest Path Finding Algorithm)  
    A에서 B까지 최단 경로를 구하는 알고리즘  

* ### 최소 신장 트리 (Minimum Spaning Tree)  
    간선 몇 개를 제거해서 트리를 만드는 알고리즘  

* ### SCC (Strongly Connected Componenet)  
    그래프 덩어리를 찾는 알고리즘  
<br>

# 1. 최단 경로 알고리즘 (Shortest Path Finding Algorithm)  

## 1.1. 최단경로 문제와 알고리즘  

### 1.1.1. 최단경로 문제란?  
어떤 정점에서 다른 정점까지 최단 거리로 이동하고 싶을 때, 어떤 경로로 이동해야 하느냐를 이해하는 문제  
`cost(weight) : 간선의 가중치`  
<br>

### 1.1.2. 최단경로 알고리즘의 종류
+ **다익스트라 알고리즘 (Dijkstra's Algorithm)**  

    하나의 정점에서 모든 정점까지 최단거리를 구하는 알고리즘    
    `(단, 간선의 가중치가 양수일 때만 사용할 수 있다.)`  

+ **플로이드 알고리즘 (Floyd Algorithm)**  

    모든 정점에서 모든 정점까지 최단거리를 구하는 알고리즘  
    `(모든에서 모든을 구하기 때문에 시간은 오래 걸린다.)`

+ **벨만포드 알고리즘 (Bellman-Ford Algorithm)**  

    하나에서 모든 정점까지 최단거리를 구하는 알고리즘  
    `(간선의 가중치에 음수가 섞여 있어도 상관 없다.)`  
<br>

## 1.2. 최단경로의 특징
정점 X까지 가기 위해서는 그 직전까지도 최단경로로 가야한다.  

예를 들어 목표지점 X에 연결되어 있는 노드 Y1, Y2, Y3가 있다고 하면,  
이 상황에서 X까지의 최단경로는 Y1, Y2, Y3까지 어떻게든 최단경로로 와서 X까지 갔을 때의 최솟값이다.  

`min(T[Y1] + cost1, T[Y2] + cost2, T[Y3] + cost3)`  
<br>


## 1.3. 다익스트라 알고리즘
하나의 정점에서 모든 정점까지 최단거리를 구하는 알고리즘  

기본 로직은 시작 정점을 기준으로 연결되어 있는 정점들로 뻗어 나가며 최단거리를 업데이트 하는 것이다.  
시작 정점의 최단거리는 0으로 시작하며, 그외 다른 정점들은 무한대로 시작한다.  

```cpp
T[i] = 정점 i까지 도달하기 위한 최단거리

1) 지금까지 방문 되지 않은 정점의 최단거리 중에서 최솟값을 찾는다.  
    if(!visited[j] && myMin > T[j]) myMin = T[j]

2) 그 최솟값을 방문 처리한 후에, 그 정점으로부터 다른 정점으로 뻗어 나가며 최단거리를 업데이트 시킨다.  
    T[nextNode] = min(T[nextNode], myMin + cost)
```  
<br>

# 2. 최소 신장 트리 (Minimum Spaning Tree)  

## 2.1. 스패닝 트리 (Spanning Tree)  

### 2.1.1. 스패닝 트리란?  
그래프의 모든 노드를 포함하는 트리  
`Tree : 사이클이 없는 그래프`  

한 가지 그래프가 있으면 여러 스패닝 트리가 존재할 수 있다.  
<br>

### 2.1.2. 최소 신장 트리란?  
간선의 가중치를 합하면 스패닝 트리의 weight를 알 수 있는데,  
이때 weight가 가장 작은(최소인) 트리가 `최소 신장 트리(MST)`이다.  
<br>

## 2.2. Cut Property  
두 개의 Tree를 연결하여 하나의 Tree를 만들어야 하는데,  
한 그래프에서 T1, T2의 트리가 있고, 그 사이에 연결되지 않은 간선이 있다면 T1은 그 그래프의 하나의 cut이다.  

이때 두 개의 cut을 가지고 MST를 만들고 싶다면 가장 가중치가 작은 간선을 잇는게 좋으며, 이것이 `Cut Property`이다.  
또한, 가장 가중치가 작은 이 간선은 추후 MST에 포함된다.  
<br>

## 2.3. 크루스칼 알고리즘 (Kruskal's Algorithm)
그래프에서 하나의 MST를 만들기 위해서는 각 정점을 하나의 MST로 시작한다.  
그리고 여러 개의 간선 중에 weight가 작은 것부터 연결해나간다.  
만약 연결하는 순간 사이클이 생긴다면 그 간선은 연결하지 않는다.  

하지만 크루스칼 알고리즘을 사용하기 위해서는 해결하기 힘든 2가지 issue가 존재한다.  

```cpp
1) 간선을 가중치 순으로 정렬하는 것이 어렵다.
2) 사이클을 판단하기가 어렵다.
```

1번의 경우 따로 비교함수를 만들어 sort함수를 사용하면 되지만, 2번은 어떻게 해결해야 할까?  
사이클을 판단하기 위해서는 먼저 사이클이 생기는 조건부터 알아야 한다.  
<br>

## 2.4. 사이클이 생기는 조건
사이클이 생기는 조건은 "하나의 트리 내에서 간선이 추가되었을 때" 이다.  
즉, 서로 다른 트리가 합쳐지면 사이클이 생기지 않지만,  
같은 트리에 포함되어 있는 간선이 연결되면 사이클이 생긴다는 것이다.  

따라서 사이클이 생기는지 생기지 않는지 판단하기 위해서는  
하나의 간선을 이을 때 연결되는 두 정점이 현재 같은 트리에 포함되어 있는지를 판단하면 된다.  
이를 위한 자료구조로 `Disjoint Set`이 존재한다.  
<br>

## 2.5. Disjoint Set
Disjoint Set은 2가지 연산으로 구성된다.  

```cpp
1) 두 정점이 같은 그룹에 속하는지 확인한다.
2) 두 정점을 하나의 그룹으로 묶는다.
```

이 자료구조를 크루스칼 알고리즘에 사용하기 위해 한가지 그룹을 한가지 트리로 나타내고,  
같은 트리인지 판단하기 위한 지표로 그룹의 대표를 트리의 root로 설정한다.  

이를 크루스칼 알고리즘에 적용하면,
```cpp
1) 두 정점의 대표(root)를 비교한다.
2) 서로 root가 다르다면 서로 다른 트리에 포함되어 있다는 뜻이므로 두 트리를 합친다.
    (합칠 때는 하나의 대표를 다른 대표의 자식노드로 만드는 방식을 사용한다.)
```  
<br>

## 2.6. 크루스칼 알고리즘의 구현
크루스칼 알고리즘은 각 노드를 하나의 MST로 시작하므로, 초기에 각 노드의 root를 자신으로 설정해준다.
```cpp
for(int i=1; i<=N; i++) root[i] = i;
```  
<br>

두 노드(트리)를 합치기 전에 root를 확인하는 방법으로는 재귀함수를 사용한다.  
자신이 root라면 자신을 반환하고, root가 아니라면 root를 찾을 때까지 위로 거슬러 올라간다.  
```cpp
int find(int node) {
  if(root[node] == node) return node;
  else return find(root[node]);
}
```  
<br>

루트가 같다면 함수를 종료하고, 같지 않다면 두 노드(트리)를 합친다.  
이때 트리를 합치기 위해서는 한 노드의 root를 다른 노드의 root로 바꿔주면 된다.  
```cpp
void union(int a, int b) {
  a = find(a);
  b = find(b);

  if(a == b) return;
  
  root[b] = a;
}
```
