/*

문제
농부 존은 소들의 저녁식사 줄 세우는 새로운 방법을 개발 했다. 
N(1~15)마리의 소들을 순서대로 세 워놓은 후, 
각 소들 사이에 +, - , . 셋 중 1가지가 써져있는 냅킨을 배치해서 
최종 결과가 0 이 되게 해야 하는 것이다. 
점(.)이 써져있는 냅킨을 통해 더 큰 수를 만들 수 있게 된다. 
아래와 같은 경우를 보자. (ps .이 써져있는 냅킨은 '공백'이라고 생각하면 된다.) 
1-2.3-4.5+6.7 이와 같은 배치는 1-23-45+67 을 나타낸다. 결과는 0 이다. 
10.11은 1011 로 해석된다.

 

입력
첫 째 줄에는 소들의 수 N(1 ≤ N ≤ 15)이 입력된다.

 

출력
처음 20줄에 대해 가능한 20가지 답을 출력하는데, 사전 순으로 앞선 것을 출력한다. 
순서는 +가 가장 앞서고 -와 . 이 순서대로 뒤따른다. 
답이 20개 이하라면 가능한 답을 각 숫자와 문자 사이에 공백을 두고 출력한다. 모두 출력한다. 
20개를 초과하는 경우 21번째 답부터는 출력하지 않는다. 
마지막 줄에는 가능한 답의 총 가지수를 출력한다.

 

예제 입력
7
예제 출력
1 + 2 - 3 + 4 - 5 - 6 + 7
1 + 2 - 3 - 4 + 5 + 6 - 7
1 - 2 + 3 + 4 - 5 + 6 - 7
1 - 2 - 3 - 4 - 5 + 6 + 7 
1 - 2 . 3 + 4 + 5 + 6 + 7 
1 - 2 . 3 - 4 . 5 + 6 . 7
6

*/

/*

중복이 가능한 조합을 짜는 것과, 
두 개 이상의 수를 하나의 수로 연결하는 것만 알면 해결하기 쉬운 문제이다.

조합을 짜는 것은 문제가 없었으나,
하나의 수로 연결하는 것이 가장 큰 고비였다.

이 문제에서는 다행히 N이 15이하였기 때문에
숫자를 연결할 때 자릿수를 맞춰주기 위해 100 또는 10만 곱해주면 됐다.

추가적으로, 인덱스를 0부터 다룰 것인지, 1부터 다룰 것인지 명확하게 집고 나가는 것이
문제를 푸는데 헷갈리지 않음을 깨달았다.

그동안 해온 방식을 벗어나지 않는 선에서
헷갈리지 않도록 짜기 위해 인덱스를 잘 정해줘야 할 것 같다.
(이 문제에서는 사용되는 숫자가 1부터 시작하기 때문에
부호를 저장하는 res 배열도 0보다는 1부터 시작하는 것이 덜 헷갈린다. 주의하자.)

*/

#include <stdio.h>
#include <vector>

using namespace std;

const int MAX = 20 + 10;
const int MAXN = 15 + 10;

int N;
char res[MAXN];
char napkin[3] = {'+', '-', '.'};
int cnt = 0;

void getResult(int x) {
  // x: 부호가 쓰여질 인덱스 (1부터 시작)
  if(x >= N) {
    vector<int> ans;
    for(int i=1; i<N; i++) {
      // 숫자의 뒤에 +나 -가 나오면, 숫자 그 자체가 뒤의 수와 더하거나 빼는 수이다.
      if(res[i] == '+' || res[i] == '-') ans.push_back(i);
      else {
        // .이 나오면 .으로 연결된 지점은 하나의 수로 이어준다.
        int cnt = 1; // .의 개수
        for(int j=i+1; j<N; j++) {
          if(res[j] != '.') break;
          else cnt++;
        }
        
        int num = i; // 하나의 수로 만들기 위한 맨 앞 숫자
        for(int j=1; j<=cnt; j++) {
          // 그 다음에 올 수의 자릿수만큼 왼쪽으로 이동한다.
          // ex) 8.9가 89가 되려면 8이 왼쪽으로 한 번 가야 하므로 * 10
          //     9.10이 910이 되려면 9가 왼쪽으로 두 번 가야 하므로 * 100
          if(i+j >= 10) num = num * 100 + i+j; // 그 다음수의 자릿수만큼 앞으로 이동해야 하므로
          else num = num * 10 + i+j;
        }
        
        ans.push_back(num);
        i += cnt;
      }
    }
    
    if(res[N-1] != '.') ans.push_back(N);
    
    // 부호에 맞춰서 더하거나 빼줌
    int sum = ans[0];
    int idx = 1;
    for(int i=1; i<N; i++) {
      if(res[i] == '+') {
        sum += ans[idx++];
      }
      else if(res[i] == '-') {
        sum -= ans[idx++];
      }
    }
    
    if(sum == 0) {
      cnt++;
      
      if(cnt <= 20) {
        for(int i=1; i<N; i++) {
          printf("%d %c ", i, res[i]);
        }
        printf("%d\n", N);
      }
    }
  }
  else {
    for(int i=0; i<3; i++) {
      res[x] = napkin[i];
      getResult(x+1);
    }
  }
}

int main() {
  scanf("%d", &N);
  
  getResult(1);
  printf("%d", cnt);

  return 0;
}