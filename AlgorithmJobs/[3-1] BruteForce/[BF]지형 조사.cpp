/*

문제
등산로를 조성하기 앞서 산의 지형 정보를 통해 오르막 및 내리막 구간 정보를 정리하려고한다. 
이때 기록하기되는 오르막 이나 내리막 구간은 길이 K 이상 이면서, 높이가 2이상 차이나야한다. 
예를 들어, 1 2 3 은 길이가 3인 오르막 구간이고, 4 5 6 7 8 은 길이가 5인 오르막 구간이다. 
앞서 나온 오르막 구간은 높이가 1씩 차이나므로 기록해야되는 오르막 구간이 아니다. 
2 5 8 은 높이차가 1씩 차이나지 않기 때문에 기록 대상인 오르막 구간이다.

주어진 지형의 가로 또는 세로 한 줄을 봤을때, 
오르막이나 내리막 구간이 존재하는지 확인해야한다. N * N의 지형 정보가 주어졌을때, 
몇 개의 가로 및 세로 줄에 오르막 혹은 내리막 구간이 존재하는지 구해보자.

예를 들어, N 이 7인 지형 정보는 다음과 같이 주어진다.

topographic_survey1
[그림 1]

이떄, 조사 대상의 구간 길이가 3일 경우 
마지막 가로줄에서 9, 6, 3 의 내리막 구간과 
3, 5, 9 의 오르막 구간이 확인되므로 해당 가로줄은 기록 대상이다. 
4번째 세로줄 또한 8, 4, 2 의 내리막 구간이 확인되므로 기록 대상이다.

기록 대상의 가로 및 세로 줄을 체크하면 총 5줄로 다음과 같다. 
구간의 개수가 아닌 가로 및 세로의 개수를 세어주는 것에 유의하자.

topographic_survey2
[그림 2]

입력
첫 번째 줄에 테스트 케이스의 개수 T가 주어진다. 
다음 줄부터 T개의 테스트 케이스에 대한 정보가 주어진다. 
각각의 테스트 케이스의 첫 번째 줄에 
지형의 크기 N 과 구간 길이 K 가 공백을 통해 구분하여 주어진다. 
두 번째 줄부터 N 개의 줄에 걸쳐 지형 정보가 주어진다. 
한 줄에 N개의 숫자가 공백을 통해 주어진다. 
지형 정보는 1부터 9까지이다. (5 ≤ N ≤ 100, 3 ≤ K ≤ 5)

출력
각 테스트 케이스에 대해 몇 개의 가로 및 세로 줄이 기록 대상인지 출력한다. 
각 테스트 케이스의 출력 양식은 "#t r"이다. 
t는 테스트 케이스의 번호이며, 1부터 시작한다. r은 문제에 대한 결과값을 뜻한다.

*/

#include <cstdio>
#include <cstring>

const int MAX = 110;

int T;
int N, K;
int map[MAX][MAX];

int main() {
  scanf("%d", &T);
  
  for(int t=1; t<=T; t++) {
    memset(map, 0, sizeof(map));
    
    scanf("%d %d", &N, &K);
    
    for(int i=0; i<N; i++) {
      for(int j=0; j<N; j++) {
        scanf("%d", &map[i][j]);
      }
    }
    
    int totalCnt = 0;
    // 가로줄 대소비교
    for(int i=0; i<N; i++) {
      int cnt = 0, flag = 0;
      
      for(int j=0; j<N-1; j++) {
        int gap = map[i][j] - map[i][j+1];
        
        if(gap >= -1 && gap <= 1) {
          cnt = 0;
          continue;
        }
        else {
          if(gap > 0) { // '>' 인 경우
            if(flag != -1) {
              flag = -1;
              cnt = 1;
            }
            else {
              cnt++;
            }
          }
          else { // '<' 인 경우
            if(flag != 1) {
              flag = 1;
              cnt = 1;
            }
            else {
              cnt++;
            }
          }
        }
        
        if(cnt >= K-1) {
          totalCnt++;
          break;
        }
      }
    }
    
    // 세로줄 대소비교
    for(int i=0; i<N; i++) {
      int cnt = 0, flag = 0;
      
      for(int j=0; j<N-1; j++) {
        int gap = map[j][i] - map[j+1][i];
        
        if(gap >= -1 && gap <= 1) {
          cnt = 0;
          continue;
        }
        else {
          if(gap > 0) { // '>' 인 경우
            if(flag != -1) {
              flag = -1;
              cnt = 1;
            }
            else {
              cnt++;
            }
          }
          else { // '<' 인 경우
            if(flag != 1) {
              flag = 1;
              cnt = 1;
            }
            else {
              cnt++;
            }
          }
        }
        
        if(cnt >= K-1) {
          totalCnt++;
          break;
        }
      }
    }
    
    printf("#%d %d\n", t, totalCnt);
  }

  return 0;
}

/* 

3
7 3
9 5 8 8 9 4 8 
1 3 1 4 5 5 3 
6 9 4 2 6 4 8 
2 1 8 5 4 2 1 
1 7 2 4 5 3 6 
3 5 5 3 2 8 1 
9 6 3 5 9 4 8
10 4
5 3 1 4 8 3 4 4 3 9 
5 9 7 3 1 5 6 1 2 7 
9 1 1 5 7 8 2 3 9 6 
4 2 3 6 3 7 5 1 8 4 
4 6 1 3 7 9 5 8 8 7 
3 4 7 9 3 3 1 2 8 6 
1 5 6 6 9 9 6 1 2 1 
3 7 9 8 6 3 3 9 8 5 
5 6 6 1 5 2 6 9 4 4 
4 1 8 6 7 4 3 7 7 6 
5 3
3 7 3 2 9 
2 2 8 7 3 
5 3 8 5 7 
2 3 6 2 4 
7 2 6 3 5 
------------------------
#1 5
#2 2
#3 1

*/