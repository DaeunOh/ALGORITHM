/*

시간제한 1초

문제
각 날에 자성이 있는 톱니바퀴가 4개가 아래와 같은 모양으로 눈 앞에 놓여있다.

gear_wheel1
[그림 1]

각 톱니바퀴를 시계 방향 혹은 반시계 방향으로 한 회당 한 칸씩 회전시킬 수 있다. 
회전시 톱니바퀴끼리 서로 맞닿아있는 날의 자성에 의해 인력과 척력에 의해 추가적으로 회전을 스스로 하게 된다. 
[그림 1]의 1번 톱니바퀴를 시계 방향으로 1회 회전할 경우 1번과 2번, 
1번과 3번에 형성되어 있는 인력에 의해 2번, 3번 톱니바퀴가 반시계 방향으로 회전하게 된다. 
또한, 2번과 3번 톱니바퀴와 인력이 작용하고 있는 4번 톱니바퀴도 시계 방향으로 회전하게 된다.

gear_wheel2
[그림 2]

이때, 한 번 더 1번 톱니바퀴를 시계 방향으로 1회 회전할 경우 
[그림 1]의 상황과 마찬가지로 2번, 3번 톱니바퀴는 반시계 방향으로, 4번 톱니바퀴는 시계 방향으로 회전하게 된다.

gear_wheel3
[그림 3]

다음으로, 한 번 더 1번 톱니바퀴를 시계 방향으로 1회 회전할 경우 
1번 톱니바퀴와 인력이 작용하고 있는 2번 톱니바퀴가 회전한다.

gear_wheel4
[그림 4]

[그림 5]의 경우 왼쪽의 상황에서 1번 톱니바퀴를 시계 방향으로 회전시켰을때, 
2번 톱니바퀴가 영향을 받아 회전하게 되고, 2번 톱니바퀴의 회전으로 인해 3번 톱니바퀴 또한 회전하게 된다.

gear_wheel5
[그림 5]

이처럼 톱니바퀴 사이에 인력이 작용하고 있는 톱니바퀴는 연쇄적으로 회전을 하게 된다. 
톱니바퀴의 회전은 순차적으로 일어나는 것이 아닌 동시에 일어나는 것에 주의해야한다.

gear_wheel6
[그림 6]

초기 톱니바퀴의 상태가 주어졌을때, 지시에 따라 회전한 후 
1번 톱니바퀴의 상단, 2번 톱니바퀴의 좌측, 3번 톱니바퀴의 우측, 4번 톱니바퀴의 하단의 극을 구해보자.

 

입력
첫 번째 줄에 테스트 케이스의 개수 T가 주어진다. 
다음 줄부터 T개의 테스트 케이스에 대한 정보가 주어진다. 
각각의 테스트 케이스의 첫 번째 줄에 회전 횟수 K가 주어진다. 
두 번째 줄에 K개의 회전 정보가 공백을 통해 구분하여 주어진다. 
회전 정보는 회전할 톱니바퀴의 번호, 회전 방향으로 이루어져있다. 
톱니바퀴의 번호는 1부터 4까지이며, 회전 방향은 시계 방향의 경우 "+", 반시계 방향의 경우 "-"로 주어진다. 
다음으로 4개의 줄에 걸쳐 톱니바퀴 날의 극이 주어진다. 
"0"은 S극, "1"은 N극이다. 
톱니바퀴의 최상단을 시작으로 시계 방향 순서대로 어떤 극이 주어진다. (1 ≤ K ≤ 20)

 

출력
각 테스트 케이스에 대해 지시에 따라 회전을 종료한 다음 
1번 톱니바퀴의 상단, 2번 톱니바퀴의 좌측, 
3번 톱니바퀴의 우측, 4번 톱니바퀴의 하단의 극을 
공백을 통해 구분하여 "0"은 S극, "1"은 N극으로 출력한다. 
각 테스트 케이스의 출력 양식은 "#t r"이다. 
t는 테스트 케이스의 번호이며, 1부터 시작한다. r은 문제에 대한 결과값을 뜻한다.

 

예제 입력
5
3
1+ 1+ 1+ 
1 1 1 0 0 1 1 0 
1 0 1 1 0 1 1 0 
0 1 1 0 0 1 1 1 
1 0 1 0 0 1 1 0
1
1+
1 0 1 1 1 0 0 1
1 1 0 1 1 0 1 0
1 0 0 1 1 1 0 1
1 0 1 0 0 1 1 0
3
3- 2- 4- 
0 1 0 1 1 0 1 1 
0 0 0 1 0 0 1 0 
0 1 1 0 0 0 1 1 
0 1 1 1 0 0 1 1 
2
4+ 3+ 
1 0 1 0 0 0 1 0 
0 1 0 1 0 0 0 1 
0 0 0 0 0 1 1 0 
0 1 0 1 1 0 1 1 
6
2- 2+ 1+ 4- 1- 1+ 
1 1 1 1 0 0 0 0 
0 1 1 0 1 0 1 0 
0 1 1 1 0 0 1 0 
1 0 1 1 0 1 0 1 

예제 출력
#1 1 0 0 1
#2 1 0 1 0
#3 1 1 1 0
#4 1 0 0 1
#5 1 0 1 0

*/

/*

문제에서 주어진 대로만 구현하면 되는 문제이다.
시계 방향과 반시계 방향으로의 구현과, 재귀 함수를 사용하는 것이 핵심이다.

나는 문제를 풀 때 같은 내용을 복사 붙여넣기 하여 코드가 길어졌지만,
어떻게 하면 짧게 짤 수 있을지도 고려해보면 좋을 것 같다.

또한, 같은 내용을 복사 붙여넣기 할 때, 여러 숫자가 혼재되어 있어
인덱스를 잘못 넣는 문제가 발생하기도 했었다.

이를 방지하기 위해서는 조금 전에 언급한 것과 같이 좀 더 효율적으로 코드를 짜던가,
시간이 여유 있다면 복사 붙여넣기를 하지 않고, 설계를 따라가며 코드를 짜는 것이 좋음을 깨달았다.

이 문제에서는 톱니바퀴가 4개로 고정되어 있어서 괜찮았지만,
만약 여러 개가 있었다면 풀기 어려웠을 것 같다.

*/

#include <cstdio>
#include <cstring>
#include <vector>

using namespace std;

const int MAX = 8 + 10;

int T;
int K;
vector<pair<int, int>> info;
int wheel[MAX][MAX];
int d[5];

void rotate() {
  for(int i=1; i<=4; i++) {
    if(d[i] == 1) { // 시계
      int temp = wheel[i][7];
      
      for(int j=7; j>=1; j--) {
        wheel[i][j] = wheel[i][j-1];
      }
      
      wheel[i][0] = temp;
    }
    else if(d[i] == -1) { // 반시계
      int temp = wheel[i][0];
      
      for(int j=0; j<=6; j++) {
        wheel[i][j] = wheel[i][j+1];
      }
      
      wheel[i][7] = temp;
    }
  }
}

void check(int num) {
  if(num == 1) {
    if(d[2] == 0 && wheel[1][5] != wheel[2][1]) {
      if(d[1] == 1) d[2] = -1;
      else d[2] = 1;
      
      check(2);
    }

    if(d[3] == 0 && wheel[1][3] != wheel[3][7]) {
      if(d[1] == 1) d[3] = -1;
      else d[3] = 1;
      
      check(3);
    }
  }
  else if(num == 2) {
    if(d[1] == 0 && wheel[2][1] != wheel[1][5]) {
      if(d[2] == 1) d[1] = -1;
      else d[1] = 1;
      
      check(1);
    }
    
    if(d[4] == 0 && wheel[2][3] != wheel[4][7]) {
      if(d[2] == 1) d[4] = -1;
      else d[4] = 1;
      
      check(4);
    }
  }
  else if(num == 3) {
    if(d[1] == 0 && wheel[3][7] != wheel[1][3]) {
      if(d[3] == 1) d[1] = -1;
      else d[1] = 1;
      
      check(1);
    }
    
    if(d[4] == 0 && wheel[3][5] != wheel[4][1]) {
      if(d[3] == 1) d[4] = -1;
      else d[4] = 1;
      
      check(4);
    }
  }
  else if(num == 4) {
    if(d[2] == 0 && wheel[4][7] != wheel[2][3]) {
      if(d[4] == 1) d[2] = -1;
      else d[2] = 1;
      
      check(2);
    }
    
    if(d[3] == 0 && wheel[4][1] != wheel[3][5]) {
      if(d[4] == 1) d[3] = -1;
      else d[3] = 1;
      
      check(3);
    }
  }
}

int main() {
  scanf("%d", &T);
  
  for(int t=1; t<=T; t++) {
    info.clear();
    memset(wheel, 0, sizeof(wheel));
    scanf("%d", &K);
    
    int num;
    char dir;
    for(int i=0; i<K; i++) {
      scanf("%1d %c", &num, &dir);
      
      if(dir == '+') info.push_back(make_pair(num, 1)); // 시계
      else info.push_back(make_pair(num, -1)); // 반시계
    }
    
    for(int i=1; i<=4; i++) {
      for(int j=0; j<8; j++) {
        scanf("%d", &wheel[i][j]);
      }
    }
    
    for(int i=0; i<K; i++) {
      memset(d, 0, sizeof(d));
      d[info[i].first] = info[i].second;
      check(info[i].first);
      rotate();
      
    }
    
    printf("#%d %d %d %d %d\n", t, wheel[1][0], wheel[2][6], wheel[3][2], wheel[4][4]);
  }
  
  return 0;
}