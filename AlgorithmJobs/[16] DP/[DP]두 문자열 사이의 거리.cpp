/*

문제
두 문자열 A, B 가 주어질 때, 두 문자열 사이의 거리를 구하려 한다. 
여기서 거리는 다음과 같이 정의된다. 
문자열 A가 주어질 때, 여기서 하나의 연산은 하나의 알파벳을 삽입 또는 삭제하는 것을 의미한다. 
문자열 A와 B 사이의 거리란, A에서 시작하여 B를 만들기 위한 최소 연산의 횟수로 정의된다. 
예를 들어, 문자열 A가 “abcabcd”이고, 문자열 B가 “abccabc” 라면, 문자열 A와 B 사이의 거리는 2가 된다. 
왜냐하면 문자열 A의 세 번째에 ‘c’를 삽입하고, 가장 마지막에 있는 ‘d’를 삭제하면 문자열 B를 얻기 때문이다. 
두 문자열이 주어질 때, 두 문자열 사이의 거리를 출력하는 프로그램을 작성하시오.

 

입력
첫 번째 줄과 두 번째 줄에 문자열이 주어지며, 이 문자열의 길이는 1000을 넘지 않는다. 
주어진 문자열은 대소문자가 섞여있다.  

출력
두 문자열 사이의 거리를 출력한다. 
(대문자 'A'와 소문자 'a'는 다른 문자로 취급한다.)

 

예제 입력
abcabcd
abccabc
예제 출력
2

*/

/*

이 문제는 여러 방법을 시도하다가, 마지막에는 예시를 통해서 점화식을 알아내게 된 문제이다.
이전에도 점화식이 전혀 떠오르지 않았을 때 예시를 통해 점화식을 유추했었는데, 그게 도움이 된 것 같다.


### 1. T[i][j] = A의 0부터 i까지의 범위에서 문자를 삽입 또는 삭제하여 B의 0부터 j까지를 만들어 내는데 필요한 최소 연산 횟수

i번째의 문자가 서로 같다면, T[i][j]는 삽입이나 삭제가 필요 없기 때문에 T[i-1][j-1]과 같다는 식은 쉽게 유추할 수 있었다.
하지만 이후 삽입이나 삭제가 필요한 경우에는 T[i][j]를 어떻게 정의해야 할지 감이 오지 않았다.
그래서 예시를 통해 유추해보면 어떨까 하는 생각에 노트에다 써내려가기 시작했다.


### 2. T[i][j] = if(A[i-1] == B[i-1]) T[i][j] = T[i-1][j-1], else T[i][j] = min(T[i][j-1], T[i-1][j]) + 1 (i는 1부터 시작)

그랬더니 A와 B의 문자가 같은 경우에는 왼쪽 위의 값이 그대로 이어졌고,
다른 경우에는 왼쪽의 값과 위쪽의 값 중 작은 값 + 1이 T[i][j]의 값이 되었다.
그리고 이를 통해 점화식을 세운 결과 위와 같은 점화식이 나온 것이다.


점화식에 i는 1부터 시작이라고 썼듯이, 점화식에서 중요한 것은 맨 처음 인덱스가 1부터 시작된다는 것이다.
i 또는 j가 0인 경우에는 기본적으로 특수한 값의 padding을 주는 것이 필요한데,
그 이유는 아무 것도 없는 A가 B로 바뀌기 위해선 B의 문자 수에 따라 0~strlen(B)번의 삽입이 필요하고,
어떤 문자가 있는 A가 아무 것도 없는 B로 바뀌기 위해선 A의 문자 수에 따라 0~strlen(A)번의 삭제가 필요하기 때문이다.

따라서 T[0][0] = 0을 시작으로 각 열에 이전 값+1을 더한 값을, 각 행에 이전 값+1을 더한 값을 미리 넣어두면
인덱스 범위를 벗어나는 것 없이 그대로 점화식을 사용할 수 있게 된다.

*/

#include <stdio.h>
#include <cstring>
#include <string.h>
#include <algorithm>

using namespace std;

const int MAX = 1000 + 10;

char A[MAX], B[MAX];
int T[MAX][MAX];

int main() {
  scanf("%s %s", A, B);
  memset(T, 0, sizeof(T));
  
  T[0][0] = 0;
  for(int i=1; i<=strlen(A); i++) T[i][0] = T[i-1][0] + 1;
  for(int j=1; j<=strlen(B); j++) T[0][j] = T[0][j-1] + 1;
  
  for(int i=1; i<=strlen(A); i++) {
    for(int j=1; j<=strlen(B); j++) {
      if(A[i-1] == B[j-1]) T[i][j] = T[i-1][j-1];
      else T[i][j] = min(T[i-1][j], T[i][j-1]) + 1;
    }
  }
  
  printf("%d\n", T[strlen(A)][strlen(B)]);
  
  return 0;
}