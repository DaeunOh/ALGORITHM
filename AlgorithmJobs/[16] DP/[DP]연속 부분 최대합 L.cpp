/*

문제
N개의 정수가 주어질 때, 연속된 부분을 선택하여 합을 최대화 하는 프로그램을 작성하시오. 
예를 들어, 아래와 같이 8개의 숫자가 있을 경우, 색칠된 부분을 선택했을 때 그 합이 가장 최대가 된다.
<그림>

 

입력
첫 번째 줄에 n이 주어진다. ( 1 ≤ n ≤ 1,000,000 ) 두 번째 줄에 n개의 정수가 주어진다.

출력
연속된 부분을 선택하였을 때의 최댓값을 출력한다.

 

예제 입력
8
2 3 -5 8 -3 4 2 -9
예제 출력
11 

예제 입력
5
-1 -2 3 -2 4
예제 출력
5

*/

/*

연속 부분 최대합 문제를 그동안 완전탐색, 분할정복법으로 풀어봤는데,
DP로 푸니까 그보다도 훨씬 빠른 시간내에, 그리고 간단하게 풀리는 것을 보고.. 깜짝 놀랐다.ㅎㅎ;;

시간초과가 날 때 문제 풀이의 핵심은 거의 이분탐색/DP에 있는 것 같다!!
이 점 유의해두고 시간초과가 날 것 같은 문제는 신경을 써야겠다 ㅎㅎ


### 1. T[i] = i번째 숫자를 오른쪽 끝으로 하는 연속 부분 최대합

인덱스 0부터 i까지의 합중에 가장 최댓값이 T[i]가 되도록 만든다면,
사실 n이 i라면 T[i]가 정답이 되는 것이다.
(하지만 여기서 T[i]는 작은 문제에서의 정답일 뿐 ㅎㅎㅎㅎㅎ)


### 2. T[i] = max(T[i-1] + data[i], data[i])

만약 1 2 -4 5 3 -2 9 10 에서의 연속 부분 최대합을 찾는다고 가정해보자.
아까 T[i]를 i번째 숫자를 오른쪽 끝으로 하는 연속 부분 최대합이라고 정의했기 때문에
T[3]은 3번째 숫자인 5를 오른쪽 끝으로 하는 연속 부분 최대합이다.

즉, 
          5 = 5
      -4 5 = 1
   2 -4 5 = 3
1 2 -4 5 = 4 중에서 최댓값이 T[3]이 되는 것이므로 T[3]은 5가 된다.

그런데 여기서 5가 쓰여있는 세로줄을 제외한 나머지를 자세히 보면,
이는 T[2]에서 최댓값을 구하기 위한 과정과 같고,
사실 -4와 2 -4는 1 2 -4보다 작으므로 그중 최댓값은 1 2 -4를 5와 더한 수가 될 수밖에 없다.
그리고 삼각형에 벗어나 있는 5는 i번째 숫자이므로
5를 오른쪽 끝으로 하는 연속 부분 최대합은 1+2+(-4)+5 또는 5 중에 최댓값이 되는 것이다.

이와 같은 방식을 사용하면 이전에 다른 방법보다 훨씬 쉽게 정답을 구할 수 있고,
시간복잡도가 O(n)밖에 되지 않으므로, n이 최대 1,000,000임에도 불구하고 엄청나게 빠른 시간 안에 풀 수 있게 된다.

*/

#include <stdio.h>
#include <algorithm>

using namespace std;

const int MAX = 1000000 + 10;

int n;
int data[MAX];
int T[MAX];

int main() {
  scanf("%d", &n);
  for(int i=0; i<n; i++) scanf("%d", &data[i]);
  
  T[0] = data[0];
  for(int i=1; i<n; i++) T[i] = max(T[i-1] + data[i], data[i]);
  
  int ans = -987987987;
  for(int i=0; i<n; i++) ans = max(ans, T[i]);
  
  printf("%d\n", ans);

  return 0;
}