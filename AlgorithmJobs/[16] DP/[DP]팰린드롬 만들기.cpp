/*

문제
팰린드롬이란, 앞으로 읽으나 뒤로 읽으나 똑같은 문자열을 말한다. 
예를 들어, “abcba”, “abccba” 등이 있을 수 있다. 
문자열이 주어질 때, 이를 팰린드롬으로 만들기 위하여 추가해야 하는 최소의 문자 개수를 출력하는 프로그램을 작성하시오. 
예를 들어, 문자열이 “abca” 로 주어질 경우, 
‘b’만 추가하면 “abcba” 를 만들 수 있으므로, 이 때는 1개의 문자만 추가하면 된다. 
또 다른 예로써, 문자열이 “adcba” 로 주어질 경우에는, 문자 2개를 추가해야 한다.

 

입력
첫 번째 줄에 문자열이 주어진다. 이 문자열의 길이는 1,000 을 넘지 않는다.  

출력
주어진 문자열을 팰린드롬으로 만들기 위해서 추가해야 하는 문자 개수의 최솟값을 출력한다.

 

예제 입력
adcba
예제 출력
2
 

예제 입력
abccbdbac
예제 출력
3

*/

/*

그동안 해왔던 DP와는 조금 다른 관점의 풀이이다.
입력이 2차원 배열이 필요하지 않음에도 테이블은 2차원 배열이 필요하기 때문이다..!


### 1. T[i][j] = i부터 j까지의 문자열을 팰린드롬으로 만들기 위해 추가해야 하는 문자 개수의 최솟값

abc라는 예시가 있을 때 T[0][2]는
0부터 2까지의 문자열(abc)을 팰린드롬으로 만들기 위해 추가해야 하는 문자 개수의 최솟값이다.
따라서 T[0][2] = 2가 된다.


### 2. T[i][j] = if(str[i] == str[j]) T[i][j] = T[i+1][j-1], else T[i][j] = min(T[i][j-1], T[i+1][j]) + 1

i번째의 문자와 j번째의 문자가 같다면 이는 서로 짝이라는 의미이므로 이미 팰린드롬이다.
따라서 그 안에있는 i+1부터 j-1까지의 문자열만 팰린드롬으로 만들어주면 되므로 위와 같은 식이 나타난다.

또한, 서로 같지 않다면 i-1에 j와 같은 문자를 추가하고(+1) i부터 j-1을 팰린드롬으로 만드는 것(T[i][j-1])과
j+1에 i와 같은 문자를 추가하고(+1) i+1부터 j를 팰린드롬으로 만드는 것(T[i+1][j]) 중에 최솟값이 T[i][j]가 될 수 있게 된다.


또한, 진행 방향은 T[i][j]를 구하기 위해서는 적어도 T[i+1][j-1], T[i][j-1], T[i+1][j]는 이미 존재해야 하므로
왼쪽 아래서부터 오른쪽 방향, 이후 위쪽 방향으로 올라가며 구하는 방식을 택해야 한다.
(이때 i <= j인 경우에만 T[i][j]가 정의됨을 유의하자!)

*/

#include <stdio.h>
#include <string.h>
#include <algorithm>

using namespace std;

const int MAX = 1000 + 10;

char str[MAX];
int T[MAX][MAX] = {0, };
int main() {
  scanf("%s", str);
  
  int strLen = strlen(str);
  
  for(int i=strLen-1; i>=0; i--) {
    for(int j=0; j<strLen; j++) {
      if(i >= j) continue;
      
      if(str[i] == str[j]) {
        T[i][j] = T[i+1][j-1];
      }
      else {
        T[i][j] = min(T[i][j-1], T[i+1][j]) + 1;
      }
    }
  }
  
  printf("%d\n", T[0][strLen-1]);

  return 0;
}