/*

문제
N x M 의 직사각형이 주어지며, 각 칸에는 정수가 들어있다. 
이제 Q개의 질문에 대하여 답을 해야 하며, 
각각의 질문은 (a, b)부터 (c, d)까지의 직사각형에 들어있는 정수의 합을 묻는다. 
예를 들어, 다음과 같이 5 x 5 의 직사각형이 주어질 때, 
(1, 2) 부터 (3, 3) 까지의 직사각형에 들어있는 정수의 합은 26 이다.

square_sum

 

입력
첫 번째 줄에 N, M, Q가 주어진다. ( 1 ≤ N, M ≤ 1,000, 1 ≤ Q ≤ 1,000,000 ) 
두 번째 줄부터 N x M 직사각형이 주어진다. 
직사각형 안의 숫자 S는 -100이상 100이하이다. 
그 후 Q개의 질문이 주어진다. 
각각의 질문은 “a b c d” 로 이루어 져 있으며, 
이는 (a, b) 부터 (c, d) 까지의 직사각형에 들어있는 정수의 합을 묻는다. 
(0 ≤ a ≤ c < N, 0 ≤ b ≤ d < M)  

출력
각 질문에 대한 답을 출력한다.

 

예제 입력
5 5 3
 1 -2 3 2 8
-8 -9 3 4 5
 2 4 7 8 2
 1 4 3 1 4
-1 2 5 -6 3
1 2 3 4
0 0 1 1
2 0 2 1
예제 출력
37
-18
6

*/

/*

처음에는 단순히 반복문으로 해당 범위를 다 더해가는 방식을 떠올렸다.
하지만 N과 M의 범위가 최대 1,000이고, Q또한 1,000,000이기 때문에
최악의 경우 1,000 * 1,000 * 1,000,000 번의 연산이 필요할 수도 있게 된다.

그래서 다른 방법을 생각해보던 도중,
미리 계산한 값을 이용하면 되지 않을까? 라는 생각을 했다.

구하는 면적이 직사각형이기 때문에, 직사각형 방식으로 계산하면 훨씬 직관적이지만,
중복으로 더해지는 부분이 있어 다시 빼줘야 하는 불편함이 있어서 나는 가로줄의 합을 미리 구하는 방식을 택했다.

즉 rowSum[0][0]에는 0번째 줄의 0번째까지의 합,
rowSum[0][1]에는 0번째 줄의 0번째부터 1번째까지의 합이 되는 것이다.
이렇게 한 줄마다 M-1번째까지 구하면 구하고자 하는 답을 위한 기반이 완성되는 것이다.

그 이후로는 각 행의 a부터 c까지 반복문을 돌면서
sum에 i행의 d번째 까지의 합 - i행의 b-1번째 까지의 합을 누적시켜 나가며 최종 값을 출력하도록 했다.
여기서 주의할 점은 인덱스 b-1에 접근할 때 범위를 넘어갈 수 있으므로,
b가 0일 때는 i행의 d번째까지의 합만 더하도록 했다.
(또는 처음에 map 자체에 여유롭게 padding을 주는 방법도 있다.)

DP를 이용하여 해결하는 문제인데, DP랑은 살짝 비슷하다
완벽하게 한 줄로 정의되는 점화식이 없어서 아쉬웠긴 했다.
점화식을 구하려면 아까 언급했던 직사각형 방식으로 해야할 것 같다.

*/

#include <stdio.h>

const int MAX = 1000 + 10;

int N, M, Q;
int map[MAX][MAX];

int rowSum[MAX][MAX];

int main() {
  scanf("%d %d %d", &N, &M, &Q);
  
  for(int i=0; i<N; i++) {
    for(int j=0; j<M; j++) {
      scanf("%d", &map[i][j]);
    }
  }
  
  for(int i=0; i<N; i++) rowSum[i][0] = map[i][0];
  
  for(int i=0; i<N; i++) {
    for(int j=1; j<M; j++) {
      rowSum[i][j] = rowSum[i][j-1] + map[i][j];
    }
  }
  
  for(int q=0; q<Q; q++) {
    int a, b, c, d;
    scanf("%d %d %d %d", &a, &b, &c, &d);
    
    int sum = 0;
    for(int i=a; i<=c; i++) {
      if(b == 0) sum += rowSum[i][d];
      else sum += rowSum[i][d] - rowSum[i][b-1];
    }
    
    printf("%d\n", sum);
  }

  return 0;
}