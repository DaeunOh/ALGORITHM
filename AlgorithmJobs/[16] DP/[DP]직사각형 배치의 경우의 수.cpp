/*

문제
2 x N 직사각형 모양의 칸이 있다. 이를 2 x 1 모양의 타일로 가득 채우려 한다. 
가능한 경우의 수를 출력하는 프로그램을 작성하시오. 
단, 가능한 경우의 수가 매우 많을 수 있으므로, 그 경우의 수를 1,000,007 로 나눈 나머지를 출력한다.

예를 들어, N = 3 일 경우에는 다음 세 가지의 가능한 경우가 존재한다.

tile

 

입력
첫 번째 줄에 N이 주어진다. ( 1 ≤ N ≤ 100 )  

출력
가능한 경우의 수를 1,000,007 로 나눈 나머지를 출력한다.

 

예제 입력
3
예제 출력
3
 

예제 입력
8
예제 출력
34
 

예제 입력
37
예제 출력
87896

*/

/*

## 1. T[i] = i개의 2 x 1 모양 타일로 2 x N 직사각형을 채우는 경우의 수를 1,000,007로 나눈 나머지

처음 접근은 최솟값을 대입해서 경우의 수를 찾아보는 것으로 시작했다.
1일 때는 1개가 나왔고, 2일 때는 2개가 나왔다.


## 2. T[i] = T[i-1] + T[i-2] (단, T[1] = 1, T[2] = 2)

3이상 부터는 맨 끝에 어떤 모양의 타일을 배치하느냐에 따라 그 경우의 수가 달라졌는데,
맨 끝에 2 x 1 세로 모양 1개가 배치된 경우는 그 앞에 나머지 2 x (i-1) 칸을 채워야 하는 문제가 되었다.
2 x (i-1)의 직사각형을 배치하는 경우는 T[i-1]이고,
이와 같은 방법으로 2 x 1 가로 모양 2개가 배치된 경우도 생각하면 T[i-2]가 되므로
T[i] = T[i-1] + T[i-2]라는 점화식을 세울 수 있게 된다.


그리고 이를 바탕으로 코딩하면 정답을 구할 수 있다.

*/

#include <stdio.h>

const int MAX = 100 + 10;

int N;
int T[MAX];

int main() {
  scanf("%d", &N);
  
  // 기저조건 설정
  T[1] = 1;
  T[2] = 2;
  
  // T[i] = i개의 2 x 1 모양 타일로 2 x N 직사각형을 채우는 경우의 수를 1,000,007로 나눈 나머지
  // T[i-1] = 2 x 1 세로 모양 1개로 끝나는 경우의 수
  // T[i-2] = 2 x 1 가로 모양 2개로 끝나는 경우의 수
  for(int i=3; i<=N; i++) T[i] = (T[i-1] + T[i-2]) % 1000007;
  
  printf("%d\n", T[N]);

  return 0;
}