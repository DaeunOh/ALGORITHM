/*

문제
철수에게는 빨간색, 초록색, 파란색 세 개의 버튼이 있다. 
버튼 하나를 누를 때 마다 특정 점수를 얻을 수 있으며, 철수는 1초에 한 번씩 버튼을 누를 수 있다. 
물론, 특정 시간에는 세 개의 버튼 중에서 한 개의 버튼만을 누를 수 있다. 
각 시간마다 특정 버튼을 눌렀을 때 얻는 점수는 모두 다를 수 있다. 
예를 들어, 시간 1에 빨간색, 초록색, 파란색 버튼에 대한 점수가 3, 5, 7 로 주어질 수 있다. 
이 경우에는 파란색을 누르는 것이 점수를 가장 많이 얻을 수 있다. 
물론, 시간 2에 각 버튼에 대한 점수는 또 다를 수 있다. 
버튼을 누를 때에는 한 가지 규칙이 있는데, 연속하여 색깔이 같은 버튼을 두 번 누를 수 없다는 것이다. 
예를 들어, 시간 1에 초록색 버튼을 눌렀다면, 시간 2에는 초록색 버튼을 누를 수 없다. 
이와 같은 규칙으로 각 시간마다 버튼을 누른다고 할 때, 
철수가 얻을 수 있는 점수의 최댓값을 출력하는 프로그램을 작성하시오.

 

입력
첫 번째 줄에 철수에게 주어진 시간 N이 주어진다. ( 1 ≤ N ≤ 100,000 ) 
두 번째 줄부터 N개의 시간에 대하여 빨간색, 초록색, 파란색 버튼을 눌렀을 때 얻을 수 있는 점수가 주어진다.

 

출력
철수가 얻을 수 있는 점수의 최댓값을 출력한다.

 

예제 입력
3
27 8 28
18 36 40
7 20 8
예제 출력
87

*/

/*

그동안의 DP문제들은 Table을 1차원 배열로 사용해 왔는데,
Table을 1차원 배열이 아니라 2차원 배열로 사용하는 방법이 익숙하지 않아 시간이 오래 걸린 문제.

1차원 배열으로 된 Table을 사용하고자 했을 때는
버튼이 이전과 같은 경우가 있을 때 이전의 버튼을 건드려야 하는 부분을 구현하기가 까다로웠는데,
애초에 Table을 2차원 배열으로 만들어 두고 버튼이 겹치지 않게 구현하니
이전 버튼을 건드리지 않아도 최댓값을 구할 수 있게 되었다.

즉, i번째 차례가 왔을 때 1) 빨간 버튼 누르는 경우 2) 파란 버튼 누르는 경우 3) 초록 버튼 누르는 경우
3가지로 고정시켜 놓고, 1)의 경우에는 i-1번째에서의 2) 3)을 확인 해서 최댓값을 구하고
자기 자신(num[i][1])을 더하면 그게 i번째에 빨간 버튼 눌렀을 때의 최댓값이 된다.

이렇게 쭉 N번째(정확히는 N-1번째)까지 반복문을 돌리고,
마지막에는 T[N-1][0] ~ T[N-1][2] 중에 최댓값을 구하면 그 값이 이 문제의 정답이 된다.

DP문제는 이전에 고정시켰던 것들을 바꾸려고 하는 경우는 거의 해결방법이 될 수 없는 것 같다.
나 또한, 이전 버튼들을 바꾸려 계속 시도했고 결과적으로는 정답이 아니었다...
차라리 배열이 2차원이 되더라도, i번째에는 항상 어떤 경우를 고정시키고,
이전의 값들에서도 고정시킨 경우를 사용하는 것이 좋다.

*/

#include <stdio.h>

const int MAX = 100000 + 10;

int N;
int num[MAX][3];

int T[MAX][3];

int main() {
  scanf("%d", &N);
  
  for(int i=0; i<N; i++) scanf("%d %d %d", &num[i][0], &num[i][1], &num[i][2]);
  
  T[0][0] = num[0][0];
  T[0][1] = num[0][1];
  T[0][2] = num[0][2];
  
  for(int i=1; i<N; i++) {
    for(int j=0; j<3; j++) {
      int myMax = -987987987;
      
      if(j == 0) {
        if(myMax < T[i-1][1]) myMax = T[i-1][1];
        if(myMax < T[i-1][2]) myMax = T[i-1][2];
      }
      else if(j == 1) {
        if(myMax < T[i-1][0]) myMax = T[i-1][0];
        if(myMax < T[i-1][2]) myMax = T[i-1][2];
      }
      else {
        if(myMax < T[i-1][0]) myMax = T[i-1][0];
        if(myMax < T[i-1][1]) myMax = T[i-1][1];
      }
      
      T[i][j] = myMax + num[i][j];
    }
  }
  
  int myMax = -987987987;
  for(int i=0; i<3; i++) {
    if(myMax < T[N-1][i]) myMax = T[N-1][i];
  }
  
  printf("%d\n", myMax);
  
  return 0;
}