/*

문제
N개의 카드가 주어지고, 각각은 자연수의 점수를 가진다. 
철수는 이제 이 카드를 가져감으로써 카드에 적혀있는 수 만큼의 점수를 얻는다. 
단, 카드를 가져갈 때 한가지 규칙이 있는데, 이는 연속하여 3개의 카드는 가져갈 수 없다는 것이다. 
예를 들어, 6개의 카드 “1 3 5 2 7 3”가 주어질 경우, 3+5+7+3 = 18 만큼의 점수를 얻는 것이 최대이다. 
N개의 카드가 주어질 때, 얻을 수 있는 점수의 최댓값을 출력하는 프로그램을 작성하시오.

 

입력
첫 번째 줄에 N이 주어진다. ( 1 ≤ N ≤ 100,000 ) 
두 번째 줄에 N개의 숫자가 주어지며, 이는 각 카드의 점수를 나타낸다.  

출력
얻을 수 있는 점수의 최댓값을 출력한다.

 

예제 입력
6
1 3 5 2 7 3
예제 출력
18

*/

/*

DP 문제를 많이 풀어보지 않았을 뿐더러, 점화식을 세운다는 것 자체가 익숙하지 않아서 그런지
코드 길이에 비해서 시간이 매우 매우 오래걸렸던 문제.
처음에는 완전탐색밖에 떠오르지 않았고, 이는 당연히 시간초과가 날 수밖에 없었다...

이 문제에서 핵심은 연속해서 3개의 카드는 가져갈 수 없기 때문에, 경우의 수가 3개로 좁혀진다는 것이다.
i번째 카드의 선택유무를 결정하는 차례가 왔을 때 크게는 i번째 카드를 선택 하지 않을 건지 / 할 건지 두 개로 나뉜다.
이후에는 i번째 카드를 선택하지 않았을 때 1) 이전에 i-2, i-1번째가 선택된 경우,
그리고 i번째 카드를 선택했을 때 2) 이전에 i-2번째가 선택된 경우, 3) 이전에 i-1번째가 선택된 경우 세 개로 나뉜다.

이를 수식으로 표현하게 되면,
1) T[i-1]
2) T[i-2] + card[i]
3) T[i-3] + card[i-1] + card[i]

가 되며, T[i]는 1) 2) 3) 중 최댓값이 차지하게 된다.

문제의 접근 방법을 깨닫고 나서도 3)의 수식을 생각하기가 쉽지는 않았다.
i-1번째가 선택된 경우를 T[i-1] + card[i]로 생각했기 때문이다.
하지만 i-2, i-1번째가 선택된 경우가 T[i-1]이기 때문에,
T[i-1] + card[i]는 i-2, i-1, i가 선택되는 경우라 주어진 규칙에 위배가 된다.
따라서 T[i-3]을 가져와서 i-1번째는 추가적으로 더해줘야 함을 캐치하는 것이 중요하다!
(만약 감이 오지 않는다면 예시를 들어가며 생각해보는 것도 좋은 방법 같다.)

또한, 문제를 좀 더 명확하게 하려면 i번째가 선택되는 경우 / 선택되지 않는 경우로 나누기 보다,
1) i번째가 선택되지 않는 경우
2) i-1번째가 선택되지 않는 경우
3) i-2번째가 선택되지 않는 경우
로 나누는 것이 좋다.

1)은 i-1번째는 선택되었고, i번째는 선택되지 않았다는 것이므로 T[i-1]이 되고,
2)는 i-2번째는 선택되었고, i번째는 선택됐다는 것이므로 T[i-2] + card[i]
3)은 i-3번째는 선택되었고, i-1번째, i번째도 선택됐다는 것이므로 T[i-3] + card[i-1] + card[i]
와 같이 조금 더 점화식을 세우기가 쉬워지기 때문이다.

하지만 이 문제를 풀며 가장 뼈저리게 느낀 건
DP문제는 풀기 전에 항!!상!! "점화식"부터 세우고 코딩을 해야한다는 것이었다.. 화이팅..!

*/

#include <stdio.h>

const int MAX = 100000 + 10;

int N;
int card[MAX] = {0, };

int T[MAX];

int getMax(int first, int second, int third) {
  if(first >= second && first >= third) return first;
  else if(second >= first && second >= third) return second;
  else return third;
}

int main() {
  scanf("%d", &N);
  for(int i=0; i<N; i++) scanf("%lld", &card[i]);

  T[0] = card[0];
  T[1] = card[0] + card[1];
  
  // case1 : i-2, i번째 카드 선택 -> T[i-2] + card[i]
  // case2 : i-1, i번째 카드 선택 -> T[i-3] + card[i-1] + card[i]
  // case3 : i-2, i-1번째 카드 선택 -> T[i-1]
  for(int i=2; i<N; i++) {
    T[i] = getMax(T[i-2] + card[i], T[i-3] + card[i-1] + card[i], T[i-1]);
  }
  
  printf("%lld\n", T[N-1]);

  return 0;
}