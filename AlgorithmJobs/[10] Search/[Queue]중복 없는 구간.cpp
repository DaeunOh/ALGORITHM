/*

문제
n개의 숫자가 주어지고, 이 중에서 r개의 연속된 숫자를 선택했을 때, 
이 연속 부분 내에는 숫자가 중복되지 않기를 원한다. 
예를 들어, 다음과 같이 10개의 숫자에서 3개의 연속된 숫자를 선택할 수 있다.

중복없는구간

이렇게 선택을 하면, 선택된 숫자들 사이에서는 중복이 존재하지 않는다. 
r의 최댓값을 구하는 프로그램을 작성하시오. 위의 경우, 
(4, 2, 1, 3)을 선택하면 되므로 r의 최댓값은 4이다. 
r이 5 이상이 될 경우, 중복 없이 연속 부분을 선택하는 것이 불가능하다.

 

입력
첫째 줄에는 숫자의 개수 n이 주어진다. ( 1 ≤ n ≤ 100,000 ) 
둘째 줄에 n개의 숫자가 주어진다. 
각 숫자는 항상 1보다 크거나 같고, n보다 작거나 같다.  

출력
r의 최댓값을 출력한다.

 

예제 입력
10
1 3 1 2 4 2 1 3 2 1
예제 출력
4
 

예제 입력
7
7 1 4 2 5 3 6
예제 출력
7

*/

/*

매개변수 탐색과 관련된 문제지만, 어떻게 해야할지 감이 안와서
Queue를 이용하여 문제를 풀었다.

1 3 1 2 4 2 1 3 2 1 을 예시로 들어보자.
앞에서부터 탐색을 시작한다면, 1을 기준으로 했을 때 가장 긴 길이는 2이다. (1 3)
그 이후로 부터는 아무리 해도 1을 기준으로는 2를 넘어갈 수 없다.
탐색에서 멈춘 원인이 1 3 1에서 나타난 "1" 이므로, 다음으로 넘어가기 위해서는 앞에서의 1을 제외시켜야 한다.
앞에서의 1을 제외 시키면 길이를 4까지 증가시킬 수 있다. (3 1 2 4)
이 이후부터는 "2" 때문에 다음으로 넘어갈 수 없다.
따라서 이번에도 앞에서의 2와, 그 이전까지의 수(3 1)를 모두 제외시킨다.
그러면 길이를 다시 4까지 증가시킬 수 있게 된다. (4 2 1 3)
매번 길이가 업데이트 될 때마다 max 또한 업데이트 시키고 이와 같은 방법으로 맨 끝까지 탐색을 끝내면 
max가 최대 길이가 될 수 있다.


구현에서 중요한 부분은 다음과 같다.
1) 방문하지 않은 수라면 queue에 그 수를 넣고, visited 배열을 인덱스로 표시한 후에 길이를 증가시킨다.
2) 이미 방문한 수라면 길이를 현재 인덱스(i)에서 중복된 수의 인덱스(visited[num[i]])로 바꾸고,
    queue에서 그 수가 나올 때까지 front를 보며 front의 visited를 0으로 초기화 시키고 pop한다.
    그리고 마지막으로 그 수를 pop함과 동시에 그 수를 다시 push해주고,
    visited 배열을 현재 인덱스로 업데이트 시켜준다.

처음에는 배열을 이용하여 구현했는데, 시간 초과가 났다.
하지만 queue를 이용하여 구현을 했더니 약 0.01초가 나왔다.
하지만 매개변수 탐색 파트인만큼, 매개변수 탐색으로도 다시 구현해봐야겠다.

*/

#include <stdio.h>
#include <queue>

using namespace std;

const int MAX = 100000 + 10;

int n;
int num[MAX];
int visited[MAX] = {0, };

int main() {
  scanf("%d", &n);
  
  for(int i=1; i<=n; i++) scanf("%d", &num[i]);

  queue<int> q;
  int len = 0, myMax = -987987987;
  for(int i=1; i<=n; i++) {
    if(!visited[num[i]]) {
      q.push(num[i]);
      visited[num[i]] = i;
      len++;
    }
    else {
      len = i - visited[num[i]];
      
      while(q.front() != num[i]) {
        visited[q.front()] = 0;
        q.pop();
      }
      
      q.pop();
      
      q.push(num[i]);
      visited[num[i]] = i;
    }

    if(len > myMax) myMax = len;
  }
  
  printf("%d\n", myMax);
  
  return 0;
}