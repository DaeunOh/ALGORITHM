/*

문제
KOI 부설 과학연구소에서는 많은 종류의 산성 용액과 알칼리성 용액을 보유하고 있다. 
각 용액에는 그 용액의 특성을 나타내는 하나의 정수가 주어져있다. 
산성 용액의 특성값은 1부터 1,000,000,000까지의 양의 정수로 나타내고, 
알칼리성 용액의 특성값은 -1부터 -1,000,000,000까지의 음의 정수로 나타낸다. 
같은 양의 두 용액을 혼합한 용액의 특성값은 혼합에 사용된 각 용액의 특성값의 합으로 정의한다. 
이 연구소에서는 같은 양의 두 용액을 혼합하여 특성값이 0에 가장 가까운 용액을 만들려고 한다. 
예를 들어, 주어진 용액들의 특성값이 [-2, 4, -99, -1, 98]인 경우에는 
특성값이 -99인 용액과 특성값이 98인 용액을 혼합하면 특성값이 -1인 용액을 만들 수 있고, 
이 용액이 특성값이 0에 가장 가까운 용액이다. 
참고로, 두 종류의 알칼리성 용액만으로나 혹은 두 종류의 산성 용액만으로 특성값이 0에 가장 가까운 혼합 용액을 만드는 경우도 존재할 수 있다. 
산성 용액과 알칼리성 용액의 특성값이 주어졌을 때, 
이 중 두 개의 서로 다른 용액을 혼합하여 특성값이 0에 가장 가까운 용액을 만들어내는 두 용액을 찾는 프로그램을 작성하시오.

 

입력
첫째 줄에는 전체 용액의 수 N이 입력된다. N은 2 이상 100,000 이하이다. 
둘째 줄에는 용액의 특성값을 나타내는 N개의 정수가 빈칸을 사이에 두고 주어진다. 
이 수들은 모두 -1,000,000,000 이상 1,000,000,000 이하이다. 
N개의 용액들의 특성값은 모두 다르고, 산성 용액만으로나 알칼리성 용액만으로 입력이 주어지는 경우도 있을 수 있다.  

출력
첫째 줄에 특성값이 0에 가장 가까운 용액을 만들어내는 두 용액의 특성값을 출력한다. 
출력해야하는 두 용액은 특성값의 오름차순으로 출력한다. 
특성값이 0에 가장 가까운 용액을 만들어내는 경우가 두 개 이상일 경우에는 특성값의 최솟값이 가장 작은 숫자를 출력한다. 
해당 경우에서 특성값의 최솟값이 같은 경우는 없다고 가정한다.  


예제 입력1
5
-2 4 -99 1 98
예제 출력1
-99 98

예제 입력2
3
2 -1 -2
예제 출력2
-2 2

*/

/*

### 두 번째 시도 ###
음수, 양수를 나누지 않고 한 배열에 입력받은 후 그 배열을 사용하는 방식으로 구현했다.
두 수의 합이 0에 가까운 수를 구하기 위해서는, 타겟으로 설정된 수의 보수가 나오면 된다.
즉, 9가 타겟이라면, -9가 나오는 것이 가장 이상적이다.

하지만 이 문제에서는 그의 보수가 항상 존재한다는 보장이 없으며,
수의 범위도 크기 때문에 완벽한 보수가 나올 확률이 적으며, -9에 가까운 -8, -10,
심하게는 10 또한 답이 될 수도 있다.

배열 안에 있는 수를 정렬하고 나면 자신의 왼쪽은 자신보다 작은 수가, 오른쪽은 자신보다 큰 수가 존재하게 된다.
이 특성을 이용하여 맨 앞의 수부터 맨 끝 직전까지 자신의 보수와 가장 가까운 수를 찾는다.
가까운 수를 찾을 때 범위는 자신의 이전 인덱스는 이미 이전에 타겟이 된 수들이 자신을 살펴봤기 때문에 살펴 볼 필요가 없다.
따라서 타겟이 된 수는 항상 자신의 다음 인덱스부터만 보면 된다.

이렇게 자신의 보수와 가장 가까운 수를 찾고, 그 차이를 살펴보며 가장 차이가 적은 수를 계속해서 업데이트 시킨다.
그리고 반복문이 끝난 시점에는 가장 차이가 적은(0에 가장 가까운) 수 2개가 답이 될 수 있다.

*/

#include <stdio.h>
#include <vector>
#include <algorithm>

using namespace std;

const int MAXN = 100000 + 10;

int N;
long long num[MAXN];

long long getAbs(long long x) {
  if(x >= 0) return x;
  else return -x;
}

long long getResult(long long value, int start, int end) {
  // start : value보다 작은 수를 가리킴
  // end   : value보다 크거나 같은 수를 가리킴
  if(start + 1 >= end) {
    // value에 더 가까운 수를 반환(value와의 차이가 더 적은 수를 반환)
    if(getAbs(value - num[start]) > getAbs(value - num[end])) return num[end];
    else return num[start];
  }
  else {
    int mid = (start + end) / 2;
    
    if(num[mid] < value) getResult(value, mid, end);
    else getResult(value, start, mid);
  }
}

int main() {
  scanf("%d", &N);
  for(int i=0; i<N; i++) scanf("%lld", &num[i]);
  
  // 오름차순 정렬
  sort(num, num + N);
  
  long long myMin = 9999999999;
  long long minA, minB;
  
  for(int i=0; i<N-1; i++) {
    long long res = getResult(-num[i], i+1, N-1);
    
    if(myMin > getAbs(-num[i] - res)) {
      myMin = getAbs(-num[i] - res);
      minA = num[i];
      minB = res;
    }
  }
  
  printf("%lld %lld\n", minA, minB);

  return 0;
}