/*

문제
2차식 f(x) = x*x+ x 가 있고, 숫자 a가 주어진다. 
우리는 f(x) = a 를 만족하는 x의 값을 찾고 싶지만, 보통 이 값은 정수로 떨어지지 않는 경우가 많다. 
예를 들어, f(x) = 20 을 풀고자 한다면, x = 4이기 때문에 이는 정수이지만, 
f(x) = 103 을 풀고자 한다면 이는 x = 9.6612... 로써 정수가 아니다.

이 문제에서는 x의 정수부분이 얼마인지를 구하는 프로그램을 작성하시오. 
단, x 는 음수를 제외한 정수이다. 
예를 들어, f(x) = 103 을 풀고자 한다면, x = 9.6612... 이기 때문에 정수부분은 9가 된다.

 

입력
첫 번째 줄에 숫자 a가 주어진다. ( 1 ≤ a ≤ 1,000,000,000,000,000,000 )  

출력
f(x) = a 를 만족하는 음수를 제외한 정수 x의 정수부분을 출력한다.  


예제 입력
103
예제 출력
9

*/

/*

x*x + x = a 의 해를 찾으면 되는 문제.

a의 범위가 최대 1,000,000,000,000,000,000으로, 매우 큰 수이기 때문에
int가 아닌 long long을 써야 한다는 것은 캐치했지만, 식에 거듭제곱이 들어가있기 때문에
초기 start를 0으로, end를 a로 하면 범위를 초과한다는 사실은 처음에 캐치하지 못했다.

따라서 end의 범위를 좁히거나, 더 큰수를 담을 타입을 써야했다.
처음에는 더 큰 수를 담을 타입을 찾아봤으나, 저렇게 큰 수를 담을 타입은 존재하지 않았고
그 이후에 범위를 좁히는 방식을 생각해보았다.

여러 방안을 생각한 끝에 해가 될 수 있는 수는 식 안에 거듭제곱이 존재하기 때문에
항상 1,000,000,000보다 작은 수여야 함을 알아냈다.

그렇기에 a가 1,000,000,000을 넘어가면, end를 a가 아닌 1,000,000,000으로 고정시켜 주었더니
범위 초과 이슈는 해결되었다.

또한, 구현을 하며 맨 마지막에 출력하는 부분에서, 처음에는 mid를 출력 했었는데
그러다 보니 해가 정수인 경우에는 잘 나왔으나, 실수인 경우에는 +1이 된 수가 나왔다.
이는 start와 end의 정의를 정확하게 내리지 않아서 생겼던 문제였다.

start의 정의를 해가 되는 수보다 항상 작거나 같은 수로,
(예를 들어 해가 4이면 start는 4가 되고, 해가 9.222면 start는 9가 된다.)
end의 정의를 해가 되는 수보다 항상 큰 수로 했더니 문제가 해결되었다.

항상 구현을 하기 전에 사용해야 할 변수의 정의는 확실하게 짚고 넘어가는 것이 좋음을 깨달았다.

*/

#include <stdio.h>

int main() {
  long long a;
  scanf("%lld", &a);
  
  long long end, start = 0;
  if(a > 1000000000) end = 1000000000;
  else end = a;
  
  
  long long mid;
  while(start + 1 < end) {
    mid = (start + end) / 2;
    
    if(mid * mid + mid > a) end = mid;
    else start = mid;
  }

  printf("%lld", start);
  
  return 0;
}