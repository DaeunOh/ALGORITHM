/*

문제
현재 몰입캠프를 수강하는 N 명의 학생이 코칭을 받기 위해 자리에 앉아있다. 
N 명의 학생들은 각자 질문을 준비해두고 있다. 
N 명의 학생 중 K 명을 선택하는 경우의 수 중 T 번째 경우에서 선택된 학생들의 질문 수 합을 구해보자.

coach-a.png

수강생 A 부터 F 까지 자리에 앉아있고, 각자 질문을 위와 같이 준비해왔다고 하자. 
6명의 수강생 중 3명의 선택하는 첫 번째 경우는 A, B, C이다. 이들의 질문 수 합은 10이다. 
두 번째 경우는 A, B, D, 세 번째 경우는 A, B, E 이다. 
이러한 순서로 10 번째 경우를 알아보면 A, E, F 인 것을 알 수 있다. 
이때의 질문 수의 합은 15이다.

입력
첫 번째 줄에 학생 수 N, 선택할 학생 수 K, 궁금한 경우의 번호 T 가 공백을 통해 구분하여 주어진다.

두 번째 줄에 N 개의 숫자가 주어진다. 
순차적으로 A 번 학생의 질문 수, B 번 학생의 질문 수, C 번 학생의 질문 수, ..., N번 학생의 질문 수를 의미한다.

(1 ≤ N ≤ 10, 1 ≤ K ≤ N, 1 ≤ T ≤ N! / {(N-K)! * K!}, 1 ≤ 질문 수 ≤ 10)

출력
T번째 경우에 선택된 학생들의 질문 수 합을 출력한다.


입력의 예 1
6 3 10
3 5 2 3 4 8
출력의 예 1
15

입력의 예 2
6 3 19
3 5 2 3 4 8
출력의 예 2
14

입력의 예 3
7 2 20
3 1 3 4 7 9 4
출력의 예 3
11

*/

/*

N명 중 K명이 선택 되는 조합을 짜면 되는 문제.

주의할 점은 예를 들어 3명이 선택되는 경우 A, B, C와 B, A, C가 같다는 점이다.
따라서 조건문에 중복되는 경우가 나오지 않도록 처리를 해주어야 한다.

*/

#include <stdio.h>

const int MAXNK = 10 + 10;

int N, K, T;
int ques[MAXNK] = {0, };

int cnt = 0;
int comb[MAXNK] = {0, };

void getComb(int x) {
  if(x >= K) {
    if(++cnt == T) {
      int ans = 0;
      for(int i=0; i<K; i++) ans += ques[comb[i]];
      
      printf("%d\n", ans);
    }
  }
  else {
    for(int i=1; i<=N; i++) {
      if(x == 0 || comb[x-1] < i) {
        comb[x] = i;
        getComb(x+1);
      }
    }
  }
}

int main() {
  scanf("%d %d %d", &N, &K, &T);
  
  for(int i=1; i<=N; i++) scanf("%d", &ques[i]);
  
  getComb(0);
  
  return 0;
}