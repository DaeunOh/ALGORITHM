/*

문제
alpha_yut_c
위와 같은 윷놀이 판에 말 1개가 이동한다. 
윷놀이 판에 존재하는 각 칸에는 점수가 적혀있다. 
윷을 N번 던져서 이동해야할 칸의 수가 각각 주어질때, 
이동하면서 밟게되는 칸의 점수를 모두 출력해보자.

말의 이동 시작점은 Start 이며, 도착지점은 End 이다. 
만약, 이동해야하는 칸이 도착 지점을 넘어서거나, 
도착 지점을 밟았을 경우 도착 지점의 점수를 얻고 해당 말은 판에서 제외된다. 
제외된 말은 더 이상 이동할 수 없다. 
50점과 75점 칸을 밟을 경우, 화살표가 가리키는 방향으로 움직여야한다. 
기본적으로 흰색 칸이 있는 경로로 이동한다.

 

입력
첫 번째 줄에 윷을 던진 횟수 N이 주어진다. 
두 번째 줄에 이동하는 칸의 개수 N개가 공백을 통해 구분하여 주어진다.
(1 ≤ N ≤ 10, 1 ≤ 이동하는 칸의 수 ≤ 5)

 

출력
첫 번째 줄에 이동하면서 밟게되는 칸의 점수를 공백을 통해 구분하여 모두 출력한다.

 

입력 예제 1
5
2 3 1 2 4
출력 예제 1
10 50 275 300 1000

입력 예제 2
5
5 5 5 5 5
출력 예제 2
50 175 95 1000

*/

/*

처음 코드를 짰을 때는 조건을 많이 걸어 가면서 풀었는데,
그러다 보니 빠뜨리는 부분이 생기고, 코드가 지저분해지는 단점이 있었다.

하지만 말이 가야할 위치를 직접 정해주는 하드코딩 방식으로 푼다면,
코드도 훨씬 간결해지고 명확해진다는 장점이 있었다.

하드코딩은 무조건 안좋은 것이라고 생각했는데,
때에 따라 하드코딩도 해줘야 함을 알게 되었다.

*/

#include <stdio.h>

const int MAX = 31 + 10;

int yut[MAX] = {
  0, 5, 10, 15, 20,
  50, 30, 35, 40, 45,
  100, 55, 60, 65, 70,
  75, 80, 85, 90, 95,
  500, 1000, 275, 250, 300, 
  150, 175, 150, 125, 350, 400
};

int moving[MAX][6];

int temp[15][6] = {
  {5, 22, 23, 24, 25, 26},
  {10, 27, 28, 24, 29, 30},
  {22, 23, 24, 25, 26, 15},
  {23, 24, 25, 26, 15, 16},
  {24, 29, 30, 20, 21, 21},
  {25, 26, 15, 16, 17, 18},
  {26, 15, 16, 17, 18, 19},
  {27, 28, 24, 29, 30, 20},
  {28, 24, 29, 30, 20, 21},
  {29, 30, 20, 21, 21, 21},
  {30, 20, 21, 21, 21, 21}
};

int cur = 0;

int main() {
  for(int i=0; i<11; i++) {
    for(int j=1; j<=5; j++) {
      moving[temp[i][0]][j] = temp[i][j];
    }
  }
  
  int N;
  scanf("%d", &N);
  
  for(int i=0; i<N; i++) {
    int num;
    scanf("%d", &num);
    
    bool flag = false;
    for(int i=0; i<11; i++) {
      if(cur == temp[i][0]) {
        flag = true;
        break;
      }
    }
    
    if(flag) {
      cur = moving[cur][num];
    }
    else {
      cur += num;
      if(cur > 21) cur = 21;
    }
    
    printf("%d ", yut[cur]);
    
    if(cur == 21) break;
  }
  
  return 0;
}