/*

문제
들판에 N x M 마리의 슬라임이 옹기종기 모여있습니다. 
슬라임은 서로의 존재를 보호하기 위해 서로 합쳐지는 것을 원하지않는 편입니다. 
하지만 성장기에 있는 슬라임은 상태가 불안정하여 달이 뜬 밤 질량이 X이상 Y이하인 슬라임끼리 합체가 일어납니다. 
다음날 아침이 되면 평균값으로 질량 크기를 나눠 가져서 다시 분리됩니다. (구한 평균값에서 나머지는 버립니다) 
합체는 성장기에 있는 슬라임 모두에게 일순간 동시에 일어납니다.

N x M 마리의 슬라임이 주어졌을 때 합쳐졌전 슬라임이 다음 날 아침 나눠 갖게 되는 무게를 알아내봅시다.

입력
첫 번째 줄에 들판의 크기 N, M이 주어집니다. 
두 번째 줄부터 N 개의 줄, M 개의 행에 걸쳐 NxM 마리의 슬라임 질량 K가 공백을 통해 구분하여 주어집니다. 
마지막 줄에 질량 크기 차이 범위값 X, Y가 주어집니다.
(1 ≤ N, M ≤ 50, 1 ≤ K ≤ 100, 1 ≤ X ≤ Y ≤ 100)

출력
합쳐졌전 슬라임이 다음 날 아침 나눠 갖게 되는 무게를 출력해봅시다. 
만약 합쳐지는 슬라임이 없다면 "-1"을 출력합니다.


입력 예제 1
2 2
40 70
60 30
20 50
출력 예제 1
35

입력 예제 2
2 2
40 20
20 40
20 50
출력 예제 2
30

입력 예제 3
3 3
15 22 78 
58 63 8 
7 52 6 
29 55
출력 예제 3
52

입력 예제 4
3 3
15 22 78 
58 43 8 
7 52 6 
79 81
출력 예제 4
-1

*/

#include <stdio.h>

const int MAXNM = 50 + 10;

int N, M;
int map[MAXNM][MAXNM] = {0, };
int X, Y;

int main() {
  scanf("%d %d", &N, &M);
  
  for(int i=0; i<N; i++) {
    for(int j=0; j<M; j++) {
      scanf("%d", &map[i][j]);
    }
  }
  
  scanf("%d %d", &X, &Y);
  
  int sum = 0, cnt = 0;
  for(int i=0; i<N; i++) {
    for(int j=0; j<M; j++) {
      if(X <= map[i][j] && map[i][j] <= Y) {
        sum += map[i][j];
        cnt++;
      }
    }
  }
  
  if(cnt == 0) printf("-1\n");
  else printf("%d\n", sum/cnt);
  
  return 0;
}