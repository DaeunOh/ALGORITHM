/*

문제
N * M 격자판에 D 개의 디퓨저 병이 놓여져있다. 
그 중 K개의 병을 선택하여 병의 뚜겅을 열 것이다. 
디퓨저 병의 뚜껑을 여는 경우의 수 중 T번째 경우가 궁금하다. 
선택된 디퓨저 병의 좌표를 출력하는 프로그램을 작성해보자.

diffuser-A
만약 위와 같이 디퓨저 병이 놓여있다고 하자. 
각각의 디퓨저 병의 좌표는 1번 - (1, 6), 2번 - (4, 2), 3번 - (5, 6) 이다. 
디퓨저 병을 고르는 순서는 병의 번호가 작은 순으로 선택한다. 
3개의 병 중 2개를 고르는 경우의 수는 (1번, 2번), (1번, 3번), (2번, 3번)로 총 3가지가 있다. 
T가 2일 경우 출력되는 값은 "1 6"과 "5 6"이다.

입력
첫 번째 줄에 격자판의 크기 N, M, 선택할 디퓨저 병의 수 K, 궁금한 경우의 번호 T가 공백을 통해 차례대로 주어진다.

두 번째 줄 부터 N개의 줄에 걸쳐 격자판의 정보가 주어진다. 
각각의 줄은 M개의 숫자로 이루어져 있으며, 0, 1, 2 중 하나이다. 
0은 아무것도 없음, 1은 장애물, 2는 디퓨저 병을 의미한다.

격자판의 왼쪽 상단의 좌표는 (1, 1)이다. 
디퓨저 병의 번호는 왼쪽 상단부터 오른쪽 하단까지 한 줄씩 읽었을때 발견되는 순서대로 매겨진다.

(3 ≤ N, M ≤ 100, 1 ≤ K ≤ D ≤ min(NM, 10), 1 ≤ T ≤ N!/((N-K)!K!))

출력
T번째 경우의 선택된 디퓨저 병 좌표를 한 줄에 하나씩 출력한다.

입력 예시 1
6 8 2 2
1 0 1 0 0 2 0 0 
0 0 0 1 0 1 1 0 
1 0 1 0 0 0 0 0 
0 2 0 0 0 1 0 0 
0 0 0 0 0 2 0 0 
0 0 1 0 0 1 0 0
출력 예시 1
1 6
5 6

입력 예시 2
4 6 3 5
0 0 2 1 2 0 
0 0 0 1 2 0 
1 1 0 0 1 1 
0 2 2 0 0 2
출력 예시 2
1 3
2 5
4 2

*/

/*

순열을 구하는 것이 핵심이며,
(1, 3)과 (3, 1)은 똑같은 것이기 때문에 이에 대한 제어도 필요하다.

*/

#include <stdio.h>
#include <vector>

using namespace std;

const int MAXNM = 100 + 10;
const int MAXK = 10 + 10;

int N, M, K, T;
int map[MAXNM][MAXNM] = {0, };
pair<int, int> D[MAXK];

int num = 0;
int comb[MAXK] = {0, };

int cnt = 0;

void getComb(int x) {
  if(x >= K) {
    cnt++;
    
    if(cnt == T) {
      for(int i=0; i<K; i++) {
        printf("%d %d\n", D[comb[i]].first, D[comb[i]].second);
      }
    }
  }
  else {
    for(int i=1; i<=num; i++) {
      if(x == 0 || comb[x-1] < i) {
        comb[x] = i;
        getComb(x+1);
      }
    }
  }
}

int main() {
  scanf("%d %d %d %d", &N, &M, &K, &T);
  
  for(int i=1; i<=N; i++) {
    for(int j=1; j<=M; j++) {
      scanf("%d", &map[i][j]);
      
      if(map[i][j] == 2) {
        D[++num] = make_pair(i, j);
      }
    }
  }
  
  getComb(0);
  
  return 0;
}