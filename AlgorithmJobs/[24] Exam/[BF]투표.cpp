// 소요시간: 30분

/*

문제
알고리즘랩스는 임직원의 수평적인 조직 문화와 화려한 근무복지 시설을 자랑한다. 
2020년을 맞아 직원 전용 풀장을 건설할지, 직원 전용 펜션을 건설할지 결정해야하는 문제가 생겼다. 
결정은 투표로 진행하게 되었는데 공정한 선정을 위해 모든 임직원이 투표에 참여하기로 하였다. 
투표는 비공개 투표로 진행된다. 직원들의 투표 가능 시간을 조사하였더니 투표 가능 시간이 겹치는 경우가 많았다. 
직원들의 소중한 시간을 보호해 주기 위해 대기시간을 없애 고자 하였고, 
그에 따라 알고리즘랩스에 투표 부스를 적절하게 설치해 직원들이 대기하는 시간이 없도록 만들고자 한다. 
투표에 참석하는 직원 수와 각 직원의 투표 가능 시간이 주어질 때, 설치해야 하는 최소 부스의 총 개수를 출력하시오.  

입력
​첫 번째 줄에는 직원의 수 N이 주어진다.
두 번째 줄부터 N 개의 줄만큼 각 직원이 투표 부스에 입장하는 시간 S 와 투표 부스에서 빠져나 올 시간 E 가 주어진다. 
투표 부스가 비는 순간 다음 직원이 들어갈 수 있다.
( 1 ≤ N ≤ 1000 , 0 ≤ S < E ≤ 150 )​ 

출력
​모든 직원이 대기시간 없이 투표 하는데 필요한 부스의 최소 개수를 정수로 출력하시오.​

 

예제 입력 1
3
0 10
10 15
20 30
예제 출력 1
1
 

예제 입력 2
2
5 15
0 10
예제 출력 2
2

*/

/*

모든 직원이 대기하는 경우가 없도록 설치해야 하는 최소 부스의 수를 구하는 문제.
처음에는 모든 입장 시간과 퇴장 시간을 보면서,
자신의 입장 시간 ~ 퇴장 시간 사이에 다른 누군가의 입장 시간이 끼어 있으면
적어도 그 시간대에는 그만큼의 부스가 필요한 줄 알았다.

하지만 해당 방법은 퇴장 시간이 기준 퇴장 시간보다 더 긴 경우에만 적용되는 것이고,
만약 기준 입장시간 ~ 퇴장시간 사이에 아예 포함되어 있으면서 겹치지 않는 시간대들이 존재한다면
정확한 답이 나오지 않는 문제가 있다.(겹치지 않으므로 그 시간대는 부스가 1개만 있어도 되는데, 2개라고 인식하는 경우가 생긴다)

그래서 해당 부분을 위배하지 않으면서 어떻게 필요한 부스의 수를 알 수 있을까 생각 하다가,
모든 입장시간과 퇴장시간을 수평선으로 한 줄씩 펼쳐놓는다고 하면,
어느 한 지점에 세로줄을 그었을 때 가장 많이 걸리는 라인 수가 필요한 최소 부스의 수임을 알게 되었다.

즉,
      -------------
-------------
   ---------    --
         ^

이런 경우가 있다면 어느 한 지점에 세로줄을 그었을 때가 그 시간대에서 필요한 부스의 개수가 되며,
^표시 한 곳에 세로줄을 그었을 때가 바로 최적화된 부스 개수라고 할 수 있다.(가장 많이 걸치는 경우)

해당 방법을 구현하기 위해 N명의 손님의 입장시간, 퇴장시간 - 1의 범위에 라인이 존재함을 나타내기 위해 +1을 해주었고,
누적된 라인을 보며 가장 큰 수를 출력하도록 했다.

*/

#include <iostream>
#include <algorithm>

using namespace std;

const int MAX = 1000 + 10;
const int MAXSE = 150 + 10;

int N;
int S[MAX], E[MAX];
int line[MAXSE] = {0, };
int myMax = -1;

int main() {
  ios_base::sync_with_stdio(0);
  cin.tie(0);
  
  cin >> N;
  for(int i=0; i<N; i++) {
    cin >> S[i] >> E[i];
  }
  
  for(int i=0; i<N; i++) {
    for(int j=S[i]; j<E[i]; j++) line[j]++;
  }
  
  for(int i=0; i<150; i++) myMax = max(myMax, line[i]);
  
  cout << myMax;

  return 0;
}