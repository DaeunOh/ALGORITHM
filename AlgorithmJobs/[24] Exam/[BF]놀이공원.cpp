// 소요시간: 35분

/*

문제
알랩놀이공원 입구에는 10개의 매표소가 있다. 놀이공원에 손님이 많지 않은 탓에 날마다 문을 여는 매표소의 개수는 다르다. 
1 개의 매표소에서 손님 1 명을 입장 시키는데 1 분이 걸린다.

경비원 유니는 입구에서 손님들이 올 때마다, 최대한 빠르게 입장할 수 있도록 줄을 적게 서있는 매표소로 안내하고 있다. 
단체손님은 같은 매표소로 안내해주며, 단체손님 또한 1명 당 1분의 입장시간이 소요된다. 
이 1분의 시간은 줄을 서는데 부터 입장하는데 까지 걸린 총 시간이다. 
유니가 줄을 배정하는데에는 시간이 소요되지 않는다고 가정한다.

손님 그룹의 개수, 문을 연 매표소의 수, 각 그룹 손님의 인원이 주어질 때 
가장 빠르게 입장시키는 방법의 소요시간을 출력하는 프로그램을 만드시오.
​ 

입력
​첫째 줄에 손님 그룹의 개수 N 과 문을 연 매표소 K 가 정수로 주어진다.
둘째 줄 부터 N 줄 만큼 각 그룹의 손님수가 유니에게 도착한 순서대로 주어진다. 그룹은 입력된 순서대로 매표소에 줄을 선다.
( 1 ≤ N ≤ 1,000 , 1 ≤ K ≤ 10 , 1 ≤ 각 그룹의 손님 수 ≤ 100 )

출력
​입장에 소요되는 최소 시간(분)을 출력 하시오.​

 

예제 입력 1
5 2
4
3
5
2
8
예제 출력 1
14

예제 입력 2
8 4
5
4
2
3
5
7
8
9
예제 출력 2
14

*/

/*

구현 자체는 어렵지 않은데 어떤 방법을 고를지 결정하는 게 오래 걸렸던 문제.
기존에 풀었던 방법처럼 비어있는 상점에 한 그룹씩 입장시키면서 시간을 증가시키고,
특정 시간이 되면 다른 그룹을 들여 보내는 방식을 사용해도 됐지만,
이 문제는 입장 시간이 따로 정해져있지 않기에 조금 더 쉽게 풀 수 있으리라 생각했다.

결과적으로 그 방법보다 훨씬 더 간결하고 쉬운 코드를 짤 수 있게 되었고, 수행 단계는 다음과 같다.

1) K개의 상점을 모두 보면서 비어있는 상점이 있다면 그룹 순서대로 해당 상점에 입장시킨다.
2) 또한, 각 상점에는 그룹의 수가 쓰여있는데, 모든 상점을 봄과 동시에 최솟값도 함께 찾는다.
3) 최솟값이 갱신이 되지 않았다면 상점이 모두 다 비어있고, 대기 손님이 없다는 의미이므로 while문을 빠져 나간다.
4) 최솟값이 갱신 되었다면 현재 시간을 최솟값만큼 증가시키고, 모든 상점에 있는 손님의 수를 최솟값만큼 감소시킨다.
5) 최솟값이 갱신 되지 않을 때까지 1~4를 반복한다.

*/

#include <iostream>

using namespace std;

const int MAX = 10 + 10;

int N, K;
int group[1010];
int store[MAX] = {0, };

int main() {
  ios_base::sync_with_stdio(0);
  cin.tie(0);
  
  cin >> N >> K;
  for(int i=0; i<N; i++) cin >> group[i];
  
  int idx = 0, t = 0;
  int myMin;
  while(1) {
    myMin = 987987987;
    
    for(int i=0; i<K; i++) {
      if(!store[i] && idx < N) {
        store[i] = group[idx++];
      }
      
      if(store[i] && myMin > store[i]) {
        myMin = store[i];
      }
    }
    
    if(myMin == 987987987) break;
    
    t += myMin;
    for(int i=0; i<K; i++) {
      if(store[i]) store[i] -= myMin;
    }
  }
  
  cout << t;

  return 0;
}