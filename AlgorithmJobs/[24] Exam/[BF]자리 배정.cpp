// 소요시간: 50분

/*

문제
알고리즘잡스 강남 센터에서는 개별적인 학습환경을 위해 책상을 일렬로 배치하였다. 
조용한 학습환경을 추구하는 코치는 수강생이 올 때마다 다른 학생과 가장 멀리 떨어진 자리에 앉도록 배정해 주었다. 
반복되는 학생들의 자리 배정에 효율적인 방법을 찾던 코치는 자동으로 자리를 배정해 주는 프로그램을 만들고자 한다.
우선 자리를 배정했을 때 다른 학생과의 거리를 계산하는 프로그램을 구현 중에 있다. 
책상의 개수와 현재 앉아 있는 수강생의 정보가 주어질 때, 
새로 온 학생이 다른 학생들로부터 가장 멀리 앉는 경우에서 가장 가까운 학생과의 거리를 출력하는 프로그램을 만드시오.

 

입력
​첫 번째 줄에는 책상의 개수 N 이 주어진다.
두 번째 줄에는 각 책상에 대한 정보가 공백으로 구분되어 주어진다.
책상에 대한 정보는 0과 1로만 이루어져 있다. 
1은 그 책상에 학생이 앉아 있는 것을 뜻하고 0은 해당 책상이 비어있는 것을 뜻한다. 
최소한 한 개의 빈자리와 한 명의 학생은 존재한다. ( 2 ≤ N ≤ 20,000 )​ 

출력
새로 온 학생이 다른 학생과 가장 멀리 떨어져 앉았을 때, 가장 가까운 학생과의 거리를 정수로 출력한다.
다른 학생과의 거리 는 | 앉은 자리 - 다른 학생의 자리 | 로 계산한다.​ 

예제 입력
7
1 0 1 0 0 0 1
예제 출력
2

*/

/*

조건을 명확히 정해주지 않으면 실수하기 쉬운 문제.

처음에는 학생 간의 거리를 모두 계산해서 가장 거리가 큰 학생들 사이에 배치한 후,
그 중 가까운 거리를 구하면 되겠다고 생각했다.
하지만 그렇게 구한 답은 자신의 양쪽에 두 명이 있는 경우는 고려했지만, 한 명만 있는 경우는 고려하지 않은 답이다.

따라서 자신의 양쪽에 학생이 있는 경우, 한쪽에만 있는 경우를 모두 고려해야 하며,
여기서 자신의 주위에 한 명만 있는 경우 중 가장 거리가 큰 경우는 가장 왼쪽에 있거나, 가장 오른쪽에 있는 경우이다.

즉, 새로운 학생이 있을 수 있는 위치는
1) 가장 왼쪽 2) 가장 오른쪽 3) 학생과 학생 사이
총 3가지로 나눌 수 있는 것이다.

가장 왼쪽 또는 오른쪽에 배치되는 경우가 가장 멀리 떨어져 앉는 경우라면,
이전에 구했던 최대 거리 그 자체가 이 문제에서 구하고자 하는 최소 거리가 된다. 

하지만 학생과 학생 사이에 배치되는 경우가 가장 멀리 떨어져 앉는 경우라면,
왼쪽 학생과의 거리, 오른쪽 학생과의 거리 중 더 작은 거리가 이 문제의 답이 된다.

*/

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int N;
bool deskInfo[20010] = { false, };

vector<int> st;
int minDist = 987987987;

int main() {
    ios_base::sync_with_stdio(0);
    cin.tie(0);

    cin >> N;
    for (int i = 0; i<N; i++) {
        cin >> deskInfo[i];

        if (deskInfo[i]) st.push_back(i);
    }

    int flag; 
    int maxDist = -1;
    int first, second;

    // 1) 가장 왼쪽에 위치하는 경우
    if (!deskInfo[0] && maxDist < st[0]) {
        flag = 1;
        maxDist = st[0];
    }
    
    // 2) 가장 오른쪽에 위치하는 경우
    if (!deskInfo[N-1] && maxDist < N - st[st.size() - 1] - 1) {
        flag = 2;
        maxDist = N - st[st.size() - 1] - 1;
    }

    // 3) 학생과 학생 사이에 위치하는 경우
    for (int i = 0; i<st.size() - 1; i++) {
        if (maxDist < st[i + 1] - st[i]) {
            flag = 3;
            maxDist = st[i + 1] - st[i];
            first = st[i];
            second = st[i + 1];
        }
    }

    if (flag == 1 || flag == 2) minDist = maxDist;
    else {
        int loc = (first + second) / 2;

        minDist = min(minDist, loc - first);
        minDist = min(minDist, second - loc);
    }

    cout << minDist;

    return 0;
}