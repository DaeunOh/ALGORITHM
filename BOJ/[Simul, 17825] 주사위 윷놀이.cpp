// 소요시간: 56분
// 실행시간: 68ms

/*

시간 제한	메모리 제한	제출	정답	맞은 사람	정답 비율
2 초	512 MB		3802	1440	858		33.243%

문제
주사위 윷놀이는 다음과 같은 게임판에서 하는 게임이다.
[그림]

- 처음에는 시작 칸에 말 4개가 있다.
- 말은 게임판에 그려진 화살표의 방향대로만 이동할 수 있다. 
  말이 파란색 칸에서 이동을 시작하면 파란색 화살표를 타야 하고, 
  이동하는 도중이거나 파란색이 아닌 칸에서 이동을 시작하면 빨간색 화살표를 타야 한다. 
  말이 도착 칸으로 이동하면 주사위에 나온 수와 관계 없이 이동을 마친다.
- 게임은 10개의 턴으로 이루어진다. 매 턴마다 1부터 5까지 한 면에 하나씩 적혀있는 5면체 주사위를 굴리고, 
  도착 칸에 있지 않은 말을 하나 골라 주사위에 나온 수만큼 이동시킨다.
- 말이 이동을 마치는 칸에 다른 말이 있으면 그 말은 고를 수 없다. 단, 이동을 마치는 칸이 도착 칸이면 고를 수 있다.
- 말이 이동을 마칠 때마다 칸에 적혀있는 수가 점수에 추가된다.

주사위에서 나올 수 10개를 미리 알고 있을 때, 얻을 수 있는 점수의 최댓값을 구해보자.

입력
첫째 줄에 주사위에서 나올 수 10개가 순서대로 주어진다.

출력
얻을 수 있는 점수의 최댓값을 출력한다.

*/

/*

◆ 풀이

주어진 주사위에 따라 맵에서 말을 이동시키며 해당 판에 있는 점수를 획득하고,
최종적으로는 최대가 되는 점수를 출력하는 시뮬레이션 문제.

이 문제의 핵심은 파란 지점으로 인해 가야 할 방향이 바뀌는 가운데 + 부분을 어떤 방식으로 이동하느냐 이다.

+ 부분을 제외한 나머지는 파란 지점에 도착하지만 않으면 그대로 빨간 화살표를 따라 이동하므로,
0부터 21까지의 인덱스를 통해 도착지점까지 도달할 수 있다.

하지만 + 부분은 중간에 파란 지점으로 인해 새로 나타난 지점들이 존재하므로,
22부터 32까지의 인덱스를 별도로 필요하며, 주사위 수에 따라 가야할 지점이 특정 숫자로 정해져 있다.

따라서 그 부분에 대해서는 해당 위치에 도착했을 때 어디로 가야하는지 별도로 지정해주는 것이 필요하다!

나는 이 부분을 해결하기 위해 맵에 존재하는 모든 지점에 번호를 붙이고,
+ 부분에 대해서는 dst라는 2차원 배열을 사용하여 { 특정 지점, 주사위1, 주사위2, ..., 주사위5 }와 같이 사용했다.
즉, 특정 지점에 도착했을 때 나오는 주사위의 수에 따라 그 뒷 지점이 결정되는 것이다.

이렇게 가야할 곳을 하드코딩한 이후에는 각 지점에 대한 이동이 쉽게 이루어지도록
moving이라는 2차원 배열을 사용하여 moving[특정 지점][1 ~ 5]에 가야할 지점을 넣어주었다.
(dst는 14개의 행으로 이루어져 있고, moving은 모든 특정 지점을 인덱스로 가질 수 있는 33개 이상의 행으로 이루어져 있다.)

그리고 0번 말부터 4번 말으로 총 10번의 턴이 진행되므로, 해당 턴에 어떤 말을 움직일지 구하기 위해
0~4로 이루어져 있으며 길이가 10이 되는 조합을 구한 후에 해당 조합으로 10번의 턴을 진행하도록 했다.

10번의 턴은 해당 턴의 주사위 수에 따라 말이 이동하도록 구현했으며,
말이 존재하는 위치에 따라 moving을 기반으로 이동할지, 기존 방식대로 이동할지 결정이 된다.

moving을 기반으로 이동하는 부분은 그 위치가 1이상 15이하의 수 중에 5로 나눈 나머지가 0이거나 21보다 큰 경우이고,
그 외에는 기존 방식대로 이동하는 부분이 된다.
(기존 방식은 그냥 해당 위치에 주사위의 수를 더해주면 되지만, 21이 넘어가는 경우에는 반드시 21로 고정해준다.)

그리고 그 위치에 따라 해당 조합으로의 점수가 계속해서 누적이 되고,
도착지점이 아닌 말들에 대해 말이 겹치는 경우나 도착지점에 있는 말이 뽑히는 경우에는
해당 조합으로는 게임이 진행될 수 없다는 뜻이므로 게임을 즉시 종료시킨다.

만약 게임이 종료되지 않고 최종 점수가 구해진 상태라면,
그 값과 기존의 최댓값을 비교하여 업데이트 시킬지 말지를 결정함으로써 이 문제의 정답을 구한다.


◆ 후기

사실 이 문제는 학원에서 이미 풀었던 문제였다.
그때 걸렸던 시간을 조금 단축해보고 싶어서 다시 복습겸 도전했던 문제인데,
코드는 간결하나 방법이 잘 생각이 안나서 생각보다 시간 절약이 많이 이루어지지 않았다 ㅎㅎ..ㅠㅠ

그때 풀고나서 며칠 뒤에 다시 풀어봤어야 했는데, 그러지 않아서 그런 것 같다..!
새로운 문제를 푸는 것만큼 복습도 정말 중요한데..!

2번을 푼 문제지만, 가야 할 지점을 배열을 통해 하드코딩 해주는 방식은 아직도 익숙하지 않은 것 같다.
시뮬레이션 문제에서는 특히 이런 종류의 연결(?)이 중요한 것 같으니(워프라던가...)
익숙해지기 전까지 연습을 조금 더 해봐야겠다!

*/

#include <iostream>
#include <cstring>

using namespace std;

const int MAX = 33 + 10;

int scores[MAX] = {
    0, 2, 4, 6, 8, 10,
    12, 14, 16, 18, 20,
    22, 24, 26, 28, 30,
    32, 34, 36, 38, 40,
    0, 13, 16, 19, 25,
    22, 24, 28, 27, 26, 
    30, 35
};

int dst[14][6] = {
    {5, 22, 23, 24, 25, 31},
    {10, 26, 27, 25, 31, 32},
    {15, 28, 29, 30, 25, 31},
    {22, 23, 24, 25, 31, 32},
    {23, 24, 25, 31, 32, 20},
    {24, 25, 31, 32, 20, 21},
    {25, 31, 32, 20, 21, 21},
    {26, 27, 25, 31, 32, 20},
    {27, 25, 31, 32, 20, 21},
    {28, 29, 30, 25, 31, 32},
    {29, 30, 25, 31, 32, 20},
    {30, 25, 31, 32, 20, 21},
    {31, 32, 20, 21, 21, 21},
    {32, 20, 21, 21, 21, 21}
};

int moving[MAX][6];
int seq[10];

int comb[10];
int loc[4];

int answer = 0;

bool playGame() {
    memset(loc, 0, sizeof(loc));
    int sum = 0;

    // 10번의 턴을 시작한다.
    for (int i = 0; i < 10; i++) {
        int n = comb[i];

        if (loc[n] == 21) return false; // 도착 지점에 있는 말이 뽑힌 경우

        if ((loc[n] && loc[n] < 20 && loc[n] % 5 == 0) || loc[n] > 21) { // moving에 따라 이동
            loc[n] = moving[loc[n]][seq[i]];
        }
        else { // 기존 순서대로 이동
            loc[n] += seq[i];
            if (loc[n] > 21) loc[n] = 21;
        }

        sum += scores[loc[n]]; // 점수 계산

        if (loc[n] == 21) continue;

        for (int j = 0; j < 4; j++) {
            if (j != n && loc[n] == loc[j]) return false; // 말이 겹치는 경우
        }
    }

    if (sum > answer) answer = sum;

    return true;
}

void getComb(int x, int k) {
    if (x >= k) {
        playGame();
    }
    else {
        for (int i = 0; i < 4; i++) {
            comb[x] = i;
            getComb(x + 1, k);
        }
    }
}

int main() {
    ios_base::sync_with_stdio(0);
    cin.tie(0);

    for (int i = 0; i < 10; i++) cin >> seq[i];

    for (int i = 0; i < 14; i++) {
        for (int j = 1; j <= 5; j++) {
            moving[dst[i][0]][j] = dst[i][j];
        }
    }

    getComb(0, 10);

    cout << answer;

    return 0;
}