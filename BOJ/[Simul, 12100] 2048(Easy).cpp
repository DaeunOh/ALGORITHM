// 소요시간: 59분, 1시간 23분
// 실행시간: 12ms

/*

시간 제한	메모리 제한	제출	정답	맞은 사람	정답 비율
1 초	512 MB	30095	7467	4347	23.367%

문제
2048 게임은 4×4 크기의 보드에서 혼자 즐기는 재미있는 게임이다.
이 게임에서 한 번의 이동은 보드 위에 있는 전체 블록을 상하좌우 네 방향 중 하나로 이동시키는 것이다. 
이때, 같은 값을 갖는 두 블록이 충돌하면 두 블록은 하나로 합쳐지게 된다. 
한 번의 이동에서 이미 합쳐진 블록은 또 다른 블록과 다시 합쳐질 수 없다. 
(실제 게임에서는 이동을 한 번 할 때마다 블록이 추가되지만, 이 문제에서 블록이 추가되는 경우는 없다)
		
<그림 1>	<그림 2>	<그림 3>
<그림 1>의 경우에서 위로 블록을 이동시키면 <그림 2>의 상태가 된다. 
여기서, 왼쪽으로 블록을 이동시키면 <그림 3>의 상태가 된다.
			
<그림 4>	<그림 5>	<그림 6>	<그림 7>
<그림 4>의 상태에서 블록을 오른쪽으로 이동시키면 <그림 5>가 되고, 
여기서 다시 위로 블록을 이동시키면 <그림 6>이 된다. 
여기서 오른쪽으로 블록을 이동시켜 <그림 7>을 만들 수 있다.
	
<그림 8>	<그림 9>
<그림 8>의 상태에서 왼쪽으로 블록을 옮기면 어떻게 될까?
2가 충돌하기 때문에, 4로 합쳐지게 되고 <그림 9>의 상태가 된다.
			
<그림 10>	<그림 11>	<그림 12>	<그림 13>
<그림 10>에서 위로 블록을 이동시키면 <그림 11>의 상태가 된다. 
<그림 12>의 경우에 위로 블록을 이동시키면 <그림 13>의 상태가 되는데, 
그 이유는 한 번의 이동에서 이미 합쳐진 블록은 또 합쳐질 수 없기 때문이다.
	
<그림 14>	<그림 15>
마지막으로, 똑같은 수가 세 개가 있는 경우에는 이동하려고 하는 쪽의 칸이 먼저 합쳐진다. 
예를 들어, 위로 이동시키는 경우에는 위쪽에 있는 블록이 먼저 합쳐지게 된다. 
<그림 14>의 경우에 위로 이동하면 <그림 15>를 만든다.

이 문제에서 다루는 2048 게임은 보드의 크기가 N×N 이다. 
보드의 크기와 보드판의 블록 상태가 주어졌을 때, 
최대 5번 이동해서 만들 수 있는 가장 큰 블록의 값을 구하는 프로그램을 작성하시오.


입력
첫째 줄에 보드의 크기 N (1 ≤ N ≤ 20)이 주어진다. 
둘째 줄부터 N개의 줄에는 게임판의 초기 상태가 주어진다. 
0은 빈 칸을 나타내며, 이외의 값은 모두 블록을 나타낸다. 
블록에 쓰여 있는 수는 2보다 크거나 같고, 1024보다 작거나 같은 2의 제곱꼴이다. 
블록은 적어도 하나 주어진다.

출력
최대 5번 이동시켜서 얻을 수 있는 가장 큰 블록을 출력한다.


예제 입력 1 
3
2 2 2
4 4 4
8 8 8
예제 출력 1 
16

예제 입력 2
4
2 4 16 8
8 4 0 0
16 8 2 0
2 8 2 0
예제 출력 2
32

예제 입력 3
3
0 8 1024
4 0 4
0 1024 32
예제 출력 3
2048

*/

/*

배열 안에서 블록을 이동시키고 합치는 것을 구현해야 하는 시뮬레이션 문제.

나는 5번이라는 이동 횟수가 고정되어 있고, 그 횟수가 크지 않기 때문에
0 0 0 0 0부터 3 3 3 3 3까지 조합을 만들어 그 조합에 따라 이동하도록 구현했다.
(하지만, 만약 5번보다 큰 이동 횟수가 주어진다면 모든 조합 별로 처음부터 이동시키는 것이 아닌,
중간에 맵을 복사해놓고 다시 맵을 원상복구 시켜주는 방법을 사용해야 시간적인 면에서 좋을 것 같다!
다음에는 그런 방식으로 다시 구현해봐야겠다!!)

조합을 구하고 나서는 방향에 따른 블록 이동이 필요하다.
조건문을 여러개 나누지 않고 하나로 구현하고 싶었지만... 머리의 한계로 인해 각 방향별로 따로 구현할 수밖에 없었다 ㅠㅠ
그래도 하나하나 예시를 들어가며 설계를 했더니 블록 이동 부분에서는 막힘이 없어서 좋았다 ㅎ_ㅎ

블록 이동의 핵심은 1) 해당 방향의 맨 끝 벽부터 시작하는 것과, 2) 한 번 합쳐진 블록이 다시 합쳐지지 않도록 하는 것이다.
예를 들면, 블록이 이동해야 하는 방향이 '위쪽'이라면 위쪽 벽부터 시작해서 아래 블록으로 스캔이 이루어진다.
즉, 1행 1열, 1행 2열, ... 1행 N열 순이다. (0행, N+1행, 0열, N+1열에 해당하는 부분은 패딩을 주기 위해 1로 고정시켰다.)

자신보다 위쪽에 있는 것과 비교하여 위에 있는 수가 0이면 반복문을 다음으로 넘기고
0이 아니라면 자신과 같은 수인지, 다른 수인지 확인하고 나서 반복문을 종료시킨다.
자신과 같은 수면서 이전에 합쳐진 적이 없다면 그 두개의 수를 합치고,
자신과 같은 수지만 이전에 합쳐진 적이 있거나 자신과 다른 수라면 그 자리의 아래로 자신을 옮겨야 한다.

이러한 과정을 상하좌우 모든 벽에 대해서 시행하면, 블록의 이동은 쉽게 구현할 수 있다!
5번의 이동과정을 거치고 나서는
맵에 존재하는 수들 중 가장 큰 수를 계속해서 업데이트 시켜나감으로써 가장 큰 수의 블록을 구한다.

*/

#define _CRT_SECURE_NO_WARNINGS

#include <cstdio>
#include <cstring>
#include <vector>

using namespace std;

const int MAX = 20 + 10;

int N;
int map[MAX][MAX];
int temp[MAX][MAX];
bool visited[MAX][MAX];

int comb[10];
int myMax;

void moveBlock(int d) {
    memset(visited, 0, sizeof(visited));

    if (d == 0) {
        for (int i = 1; i <= N; i++) {
            for (int j = 1; j <= N; j++) {
                if (!map[j][i]) continue;

                for (int k = j - 1; k >= 0; k--) {
                    // 1. 위에 있는 수가 0인 경우 --> 그 자리로 이동
                    // 2. 위에 있는 수가 0이 아닌 경우 (break시점)
                    //    2-1. 자신과 같으면서 !visited 인 경우
                    //    2-2. 자신과 같으면서 visited인 경우, 자신과 다른 경우
                    if (!map[k][i]) continue;

                    if (map[k][i] == map[j][i] && !visited[k][i]) {
                        visited[k][i] = true;
                        map[k][i] *= 2;
                        map[j][i] = 0;
                    }
                    else {
                        int temp = map[j][i];
                        map[j][i] = 0;
                        map[k + 1][i] = temp;
                    }

                    break;
                }
            }
        }
    }
    else if (d == 1) {
        for (int i = 1; i <= N; i++) {
            for (int j = N; j >= 1; j--) {
                if (!map[j][i]) continue;

                for (int k = j + 1; k <= N+1; k++) {
                    if (!map[k][i]) continue;

                    if (map[k][i] == map[j][i] && !visited[k][i]) {
                        visited[k][i] = true;
                        map[k][i] *= 2;
                        map[j][i] = 0;
                    }
                    else {
                        int temp = map[j][i];
                        map[j][i] = 0;
                        map[k - 1][i] = temp;
                    }

                    break;
                }
            }
        }
    }
    else if (d == 2) {
        for (int i = 1; i <= N; i++) {
            for (int j = 1; j <= N; j++) {
                if (!map[i][j]) continue;

                for (int k = j - 1; k >= 0; k--) {
                    if (!map[i][k]) continue;

                    if (map[i][k] == map[i][j] && !visited[i][k]) {
                        visited[i][k] = true;
                        map[i][k] *= 2;
                        map[i][j] = 0;
                    }
                    else {
                        int temp = map[i][j];
                        map[i][j] = 0;
                        map[i][k + 1] = temp;
                    }

                    break;
                }
            }
        }
    }
    else if (d == 3) {
        for (int i = 1; i <= N; i++) {
            for (int j = N; j >= 1; j--) {
                if (!map[i][j]) continue;

                for (int k = j + 1; k <= N + 1; k++) {
                    if (!map[i][k]) continue;

                    if (map[i][k] == map[i][j] && !visited[i][k]) {
                        visited[i][k] = true;
                        map[i][k] *= 2;
                        map[i][j] = 0;
                    }
                    else {
                        int temp = map[i][j];
                        map[i][j] = 0;
                        map[i][k - 1] = temp;
                    }

                    break;
                }
            }
        }
    }
}

int getMax() {
    int subMax = 0;
    for (int i = 1; i <= N; i++) {
        for (int j = 1; j <= N; j++) {
            if (subMax < map[i][j]) subMax = map[i][j];
        }
    }

    return subMax;
}

void getComb(int x) {
    if (x >= 5) {
        for (int i = 1; i <= N; i++) {
            for (int j = 1; j <= N; j++) {
                map[i][j] = temp[i][j];
            }
        }

        for (int i = 0; i < 5; i++) moveBlock(comb[i]);

        int subMax = getMax();
        if (myMax < subMax) myMax = subMax;
    }
    else {
        for (int i = 0; i < 4; i++) {
            comb[x] = i;
            getComb(x + 1);
        }
    }
}

int main()
{
    memset(map, 1, sizeof(map));
    myMax = 0;

    scanf("%d", &N);

    for (int i = 1; i <= N; i++) {
        for (int j = 1; j <= N; j++) {
            scanf("%d", &map[i][j]);
            temp[i][j] = map[i][j];
        }
    }

    getComb(0);

    printf("%d", myMax);
}