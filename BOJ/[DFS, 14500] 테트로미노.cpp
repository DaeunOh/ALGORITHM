// 소요시간: 50분
// 실행시간: 72ms

/*

시간 제한	메모리 제한	제출	정답	맞은 사람	정답 비율
2 초	512 MB		25469	9130	5896	33.947%

문제
폴리오미노란 크기가 1×1인 정사각형을 여러 개 이어서 붙인 도형이며, 다음과 같은 조건을 만족해야 한다.
- 정사각형은 서로 겹치면 안 된다.
- 도형은 모두 연결되어 있어야 한다.
- 정사각형의 변끼리 연결되어 있어야 한다. 즉, 꼭짓점과 꼭짓점만 맞닿아 있으면 안 된다.
정사각형 4개를 이어 붙인 폴리오미노는 테트로미노라고 하며, 다음과 같은 5가지가 있다.

<그림>

아름이는 크기가 N×M인 종이 위에 테트로미노 하나를 놓으려고 한다. 
종이는 1×1 크기의 칸으로 나누어져 있으며, 각각의 칸에는 정수가 하나 쓰여 있다.
테트로미노 하나를 적절히 놓아서 테트로미노가 놓인 칸에 쓰여 있는 수들의 합을 최대로 하는 프로그램을 작성하시오.
테트로미노는 반드시 한 정사각형이 정확히 하나의 칸을 포함하도록 놓아야 하며, 회전이나 대칭을 시켜도 된다.


입력
첫째 줄에 종이의 세로 크기 N과 가로 크기 M이 주어진다. (4 ≤ N, M ≤ 500)
둘째 줄부터 N개의 줄에 종이에 쓰여 있는 수가 주어진다. 
i번째 줄의 j번째 수는 위에서부터 i번째 칸, 왼쪽에서부터 j번째 칸에 쓰여 있는 수이다. 
입력으로 주어지는 수는 1,000을 넘지 않는 자연수이다.

출력
첫째 줄에 테트로미노가 놓인 칸에 쓰인 수들의 합의 최댓값을 출력한다.


예제 입력 1 
5 5
1 2 3 4 5
5 4 3 2 1
2 3 4 5 6
6 5 4 3 2
1 2 1 2 1
예제 출력 1 
19

예제 입력 2 
4 5
1 2 3 4 5
1 2 3 4 5
1 2 3 4 5
1 2 3 4 5
예제 출력 2 
20

예제 입력 3 
4 10
1 2 1 2 1 2 1 2 1 2
2 1 2 1 2 1 2 1 2 1
1 2 1 2 1 2 1 2 1 2
2 1 2 1 2 1 2 1 2 1
예제 출력 3 
7

*/

/*

처음에는 어떻게 풀어야 할지 감이 오지 않아 막막했던 문제..
테트로미노의 예시 모양이 주어져 있어서 맵의 모든 부분에 테트로미노를 하나씩 끼워 가며 최댓값을 찾아야 하나...?
라는 생각이 가장 먼저 들었다..ㅋㅋㅎㅎㅎ;;;

그런데 맵의 크기가 최대 500x500이고, 테트로미노가 회전이나 대칭이 가능하기 때문에 고려해야 할 요소들이 너무 많았다.
왠지 이 방법은 아닌 것 같아.. 어떻게 하면 쉽게 풀 수 있을지 생각해보다가,
정사각형의 변끼리 연결되어 있어야 한다는 점을 이용하면 DFS로 해결이 가능할 것이라는 생각이 갑자기 들었다!

즉, 테트로미노 모양 자체에 구애 받지 않고, 한 정사각형을 시작으로 자신의 상하좌우에 있는 숫자 중
방문되지 않은 가장 큰 수를 골라서 그 부분으로 가는 식으로 총 4개의 정사각형을 찾는 것이다!

그런데 여기서 고려하지 못했던 점 하나가... 예제 입력 3를 하면서 발견됐다 ㅎㅎㅎ;;
바로 가운데 손가락 모양(?)은 왔던 지점을 한번 더 지나가야 하기 때문에 DFS로 해결이 되지 않는다.

나는 이 부분을 해결해주기 위해 한 정사각형을 기준으로 상하좌우의 있는 숫자들을 벡터에 넣어놓고,
벡터의 크기가 3이상이라면 크기순으로 정렬을 해서 자신 + 큰 값 3개만 포함하는 방식으로 구현했다.
구현하고 나서 이제 정답이겠지...하고 제출을 했는데, 틀렸다고 나왔다 ...

처음에는 뭐가 문제인지 찾지 못했는데.. 다시 코드를 보니
크기순으로 정렬을 한 것이 오름차순임을 깜빡했다 ㅎㅎㅎㅎ;;
그래서 정렬을 위한 벡터를 넣을 때 -를 붙여서 넣은 다음,
나중에 더할 때는 더하지 않고 빼주는 방식으로 했더니 통과할 수 있었다 ㅎㅎㅎ

문제를 풀면서 여러 해프닝이 많았던 문제.... sort 함수는 오름차순임을 잊지 말자!!!!!

*/

#define _CRT_SECURE_NO_WARNINGS

#include <cstdio>
#include <queue>
#include <algorithm>
#include <vector>

using namespace std;

const int MAX = 500 + 10;

int N, M;
int map[MAX][MAX];
bool visited[MAX][MAX] = { 0, };
int myMax = -1;

int dy[4] = { -1, 1, 0, 0 };
int dx[4] = { 0, 0, -1, 1 };

void getResult(int y, int x, int cnt, int sum) {
    if (cnt >= 3) {
        if (myMax < sum) myMax = sum;
        return;
    }

    visited[y][x] = true;

    int maxY, maxX, subMax = -1;
    for (int i = 0; i < 4; i++) {
        int ny = y + dy[i];
        int nx = x + dx[i];

        if (ny < 0 || ny > N - 1 || nx < 0 || nx > M - 1) continue;

        if (!visited[ny][nx] && subMax < map[ny][nx]) {
            maxY = ny;
            maxX = nx;
            subMax = map[ny][nx];
        }
    }

    getResult(maxY, maxX, cnt + 1, sum + subMax);

    visited[y][x] = false;
}

void getResult2(int y, int x) {
    vector<int> num;

    for (int i = 0; i < 4; i++) {
        int ny = y + dy[i];
        int nx = x + dx[i];

        if (ny < 0 || ny > N - 1 || nx < 0 || nx > M - 1) continue;

        num.push_back(-map[ny][nx]);
    }

    if (num.size() >= 3) {
        
        sort(num.begin(), num.end());

        int sum = map[y][x];
        for (int i = 0; i < 3; i++) sum -= num[i];

        if (myMax < sum) myMax = sum;
    }
}

int main() {
    scanf("%d %d", &N, &M);

    for (int i = 0; i < N; i++) {
        for (int j = 0; j < M; j++) {
            scanf("%d", &map[i][j]);
        }
    }

    for (int i = 0; i < N; i++) {
        for (int j = 0; j < M; j++) {
            getResult(i, j, 0, map[i][j]);
            getResult2(i, j);
        }
    }

    printf("%d", myMax);

    return 0;
}