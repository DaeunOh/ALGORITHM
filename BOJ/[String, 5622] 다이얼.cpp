// 소요시간: 15분

/*

시간 제한	메모리 제한	제출	정답	맞은 사람	정답 비율
1 초		128 MB		25590	14605	13298		57.838%


문제
상근이의 할머니는 아래 그림과 같이 오래된 다이얼 전화기를 사용한다.

<dial>

전화를 걸고 싶은 번호가 있다면, 숫자를 하나를 누른 다음에 금속 핀이 있는 곳 까지 시계방향으로 돌려야 한다. 
숫자를 하나 누르면 다이얼이 처음 위치로 돌아가고, 다음 숫자를 누르려면 다이얼을 처음 위치에서 다시 돌려야 한다.

숫자 1을 걸려면 총 2초가 필요하다. 
1보다 큰 수를 거는데 걸리는 시간은 이보다 더 걸리며, 한 칸 옆에 있는 숫자를 걸기 위해선 1초씩 더 걸린다.

상근이의 할머니는 전화 번호를 각 숫자에 해당하는 문자로 외운다. 
즉, 어떤 단어를 걸 때, 각 알파벳에 해당하는 숫자를 걸면 된다. 예를 들어, UNUCIC는 868242와 같다.

할머니가 외운 단어가 주어졌을 때, 이 전화를 걸기 위해서 필요한 시간을 구하는 프로그램을 작성하시오.

입력
첫째 줄에 알파벳 대문자로 이루어진 단어가 주어진다. 단어는 2글자~15글자로 이루어져 있다.

출력
첫째 줄에 다이얼을 걸기 위해서 필요한 시간을 출력한다.

예제 입력 1 
UNUCIC
예제 출력 1 
36

*/

/*

주어진 알파벳에 따라 숫자를 잘 매칭시키고 시간을 계산하는 문제.

나는 문자 그대로를 사용하는 방법을 선호하지 않기 때문에, 항상 문자에서 'A'를 빼주고 A를 0으로 보는 방법을 사용한다.
이 문제에서는 문자별로 매칭된 숫자가 고정되어 있기 때문에 A부터 Z까지 해당 숫자+1을 시간에 더해주었다.

처음에는 모든 알파벳이 숫자당 3개로 고정되어 있다고 생각해서, /3을 하고 + 3을 해주는 방식을 사용했는데,
알고보니 숫자당 3개뿐만 아니라 4개인 경우도 존재했다.. ㄷㄷ;;
그래서 각 문자별로 1차원 배열에 더해줄 값을 미리 고정시켜 놓고 시간을 누적시켰더니 해결완료!

문제를 풀고나서 또 다른 방법은 없는지 다른 사람의 코드를 참고했는데, 
어차피 문자들에 연결되어 있는 숫자들이 연속적이기 때문에 (ABC는 333, DEF는 444...)
앞에서 부터 조건문으로 해당 문자가 'C'보다 같거나 작으면 +3, 'F'보다 같거나 작으면 +4 해주는 방식이 있었다.

내 방법 같은 경우는 알파벳의 범위보다 더 넓은 경우에는(매칭 시킬 숫자가 많은 경우) 적합하지 않지만, (이 문제까지는 괜찮)
만약 문자별로 연속된 숫자가 매칭되어 있는게 아니라 문자들이 뒤죽박죽 엉켜있을 경우에는 더 좋은 것 같다!

상황에 따라 적합한 알고리즘을 사용하면 될 것 같다! ㅎㅎ


*/

#include <iostream>
#include <string>

using namespace std;

int dial[26] = {
    3, 3, 3, 4, 4, 4, 5, 5, 5,
    6, 6, 6, 7, 7, 7, 8, 8, 8, 8,
    9, 9, 9, 10, 10, 10, 10
};

int main() {
    ios_base::sync_with_stdio(0);
    cin.tie(0);

    string str;
    cin >> str;

    int t = 0;
    for (int i = 0; i < str.size(); i++) {
        t += dial[str[i] - 'A'];
    }

    cout << t;

    return 0;
}