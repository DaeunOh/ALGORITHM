// 소요시간: 20분
// 실행시간: 16ms

/*

시간 제한	메모리 제한	제출	정답	맞은 사람	정답 비율
1 초		512 MB	1941	882	600	43.956%

문제
인체에 치명적인 바이러스를 연구하던 연구소에 승원이가 침입했고, 바이러스를 유출하려고 한다. 
승원이는 연구소의 특정 위치에 바이러스 M개를 놓을 것이고, 승원이의 신호와 동시에 바이러스는 퍼지게 된다.
연구소는 크기가 N×N인 정사각형으로 나타낼 수 있으며, 정사각형은 1×1 크기의 정사각형으로 나누어져 있다. 
연구소는 빈 칸, 벽으로 이루어져 있으며, 벽은 칸 하나를 가득 차지한다.
일부 빈 칸은 바이러스를 놓을 수 있는 칸이다. 바이러스는 상하좌우로 인접한 모든 빈 칸으로 동시에 복제되며, 1초가 걸린다.

예를 들어, 아래와 같이 연구소가 생긴 경우를 살펴보자. 0은 빈 칸, 1은 벽, 2는 바이러스를 놓을 수 있는 칸이다.

2 0 0 0 1 1 0
0 0 1 0 1 2 0
0 1 1 0 1 0 0
0 1 0 0 0 0 0
0 0 0 2 0 1 1
0 1 0 0 0 0 0
2 1 0 0 0 0 2

M = 3이고, 바이러스를 아래와 같이 놓은 경우 6초면 모든 칸에 바이러스를 퍼뜨릴 수 있다. 
벽은 -, 바이러스를 놓은 위치는 0, 빈 칸은 바이러스가 퍼지는 시간으로 표시했다.

6 6 5 4 - - 2
5 6 - 3 - 0 1
4 - - 2 - 1 2
3 - 2 1 2 2 3
2 2 1 0 1 - -
1 - 2 1 2 3 4
0 - 3 2 3 4 5

시간이 최소가 되는 방법은 아래와 같고, 5초만에 모든 칸에 바이러스를 퍼뜨릴 수 있다.

0 1 2 3 - - 2
1 2 - 3 - 0 1
2 - - 2 - 1 2
3 - 2 1 2 2 3
3 2 1 0 1 - -
4 - 2 1 2 3 4
5 - 3 2 3 4 5

연구소의 상태가 주어졌을 때, 모든 빈 칸에 바이러스를 퍼뜨리는 최소 시간을 구해보자.

입력
첫째 줄에 연구소의 크기 N(5 ≤ N ≤ 50), 놓을 수 있는 바이러스의 개수 M(1 ≤ M ≤ 10)이 주어진다.
둘째 줄부터 N개의 줄에 연구소의 상태가 주어진다. 0은 빈 칸, 1은 벽, 2는 바이러스를 놓을 수 있는 칸이다. 
2의 개수는 M보다 크거나 같고, 10보다 작거나 같은 자연수이다.

출력
연구소의 모든 빈 칸에 바이러스가 있게 되는 최소 시간을 출력한다. 
바이러스를 어떻게 놓아도 모든 빈 칸에 바이러스를 퍼뜨릴 수 없는 경우에는 -1을 출력한다.

예제 입력 1 
7 3
2 0 0 0 1 1 0
0 0 1 0 1 2 0
0 1 1 0 1 0 0
0 1 0 0 0 0 0
0 0 0 2 0 1 1
0 1 0 0 0 0 0
2 1 0 0 0 0 2
예제 출력 1 
5

예제 입력 2 
7 3
2 0 2 0 1 1 0
0 0 1 0 1 2 0
0 1 1 2 1 0 0
2 1 0 0 0 0 2
0 0 0 2 0 1 1
0 1 0 0 0 0 0
2 1 0 0 2 0 2
예제 출력 2 
5

예제 입력 3 
7 4
2 0 2 0 1 1 0
0 0 1 0 1 2 0
0 1 1 2 1 0 0
2 1 0 0 0 0 2
0 0 0 2 0 1 1
0 1 0 0 0 0 0
2 1 0 0 2 0 2
예제 출력 3 
4

예제 입력 4 
7 5
2 0 2 0 1 1 0
0 0 1 0 1 2 0
0 1 1 2 1 0 0
2 1 0 0 0 0 2
0 0 0 2 0 1 1
0 1 0 0 0 0 0
2 1 0 0 2 0 2
예제 출력 4 
3

예제 입력 5 
7 3
2 0 2 0 1 1 0
0 0 1 0 1 0 0
0 1 1 1 1 0 0
2 1 0 0 0 0 2
1 0 0 0 0 1 1
0 1 0 0 0 0 0
2 1 0 0 2 0 2
예제 출력 5 
7

예제 입력 6 
7 2
2 0 2 0 1 1 0
0 0 1 0 1 0 0
0 1 1 1 1 0 0
2 1 0 0 0 0 2
1 0 0 0 0 1 1
0 1 0 0 0 0 0
2 1 0 0 2 0 2
예제 출력 6 
-1

예제 입력 7 
5 1
2 2 2 1 1
2 1 1 1 1
2 1 1 1 1
2 1 1 1 1
2 2 2 1 1
예제 출력 7 
4

*/

/*

바이러스가 존재 가능한 곳에 M개의 바이러스를 배치하고, 모든 빈칸에 바이러스를 퍼뜨리는 최소 시간을 구하는 BFS 문제.

바이러스가 존재 가능한 위치를 벡터에 저장해 놓고, 그 번호를 이용하여 조합을 만든 후 바이러스를 퍼뜨리면 된다.
만약 퍼뜨린 바이러스가 모든 칸에 퍼져있다면 최소 시간을 업데이트 하고, 그렇지 않다면 -1을 출력한다.

자세한 수행 과정은 다음과 같다.

1) map이 2(바이러스가 존재 가능한 위치)인 위치를 벡터에 저장한다.
2) 벡터의 번호를 이용하여 조합을 구한다. (조합의 길이는 M이고, 중복되지 않아야 한다.)
3) 바이러스를 복제한다.
4) 모든 칸에 바이러스가 퍼져 있다면 최소 시간을 업데이트 한다.
5) 최소 시간이 업데이트 되었다면 그 시간을 출력하고, 그렇지 않다면 -1을 출력한다.

*/

#define _CRT_SECURE_NO_WARNINGS

#include <cstdio>
#include <queue>
#include <vector>
#include <cstring>
#include <algorithm>

using namespace std;

const int MAX = 50 + 10;

int N, M;
int map[MAX][MAX];
vector<pair<int, int>> virus;

int comb[20];
int visited[MAX][MAX];

int dy[4] = { -1, 1, 0, 0 };
int dx[4] = { 0, 0, -1, 1 };

int myMin = 987987987;

void spread() {
    memset(visited, 0, sizeof(visited));

    queue<pair<int, int>> q;
    for (int i = 0; i < M; i++) {
        visited[virus[comb[i]].first][virus[comb[i]].second] = 1;
        q.push(make_pair(virus[comb[i]].first, virus[comb[i]].second));
    }
        
    while (!q.empty()) {
        pair<int, int> front = q.front();
        q.pop();

        for (int i = 0; i < 4; i++) {
            int ny = front.first + dy[i];
            int nx = front.second + dx[i];

            if (ny < 0 || ny > N - 1 || nx < 0 || nx > N - 1) continue;

            if (!visited[ny][nx] && map[ny][nx] != 1) {
                visited[ny][nx] = visited[front.first][front.second] + 1;
                q.push(make_pair(ny, nx));
            }
        }
    }

    int myMax = -1;
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < N; j++) {
            if (map[i][j] == 1) continue;
            if (!visited[i][j]) return;
            
            myMax = max(myMax, visited[i][j]);
        }
    }

    myMin = min(myMin, myMax);
}

void getComb(int x) {
    if (x >= M) {
        spread();
    }
    else {
        for (int i = 0; i < virus.size(); i++) {
            if (x == 0 || comb[x - 1] < i) {
                comb[x] = i;
                getComb(x + 1);
            }
        }
    }
}

int main() {
    scanf("%d %d", &N, &M);
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < N; j++) {
            scanf("%d", &map[i][j]);

            if (map[i][j] == 2) virus.push_back(make_pair(i, j));
        }
    }

    getComb(0);

    if (myMin == 987987987) printf("-1\n");
    else printf("%d\n", myMin - 1);

    return 0;
}