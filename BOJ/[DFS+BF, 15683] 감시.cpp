// 소요시간: 1시간 15분
// 실행시간: 12ms

/*

시간 제한	메모리 제한	제출	정답	맞은 사람	정답 비율
1 초	512 MB		15192	6567	3864	39.741%


문제
스타트링크의 사무실은 1×1크기의 정사각형으로 나누어져 있는 N×M 크기의 직사각형으로 나타낼 수 있다. 
사무실에는 총 K개의 CCTV가 설치되어져 있는데, CCTV는 5가지 종류가 있다. 
각 CCTV가 감시할 수 있는 방법은 다음과 같다.

<그림>

1번 CCTV는 한 쪽 방향만 감시할 수 있다. 
2번과 3번은 두 방향을 감시할 수 있는데, 2번은 감시하는 방향이 서로 반대방향이어야 하고, 3번은 직각 방향이어야 한다. 
4번은 세 방향, 5번은 네 방향을 감시할 수 있다.

CCTV는 감시할 수 있는 방향에 있는 칸 전체를 감시할 수 있다. 
사무실에는 벽이 있는데, CCTV는 벽을 통과할 수 없다. CCTV가 감시할 수 없는 영역은 사각지대라고 한다.

CCTV는 회전시킬 수 있는데, 회전은 항상 90도 방향으로 해야 하며, 감시하려고 하는 방향이 가로 또는 세로 방향이어야 한다.

0 0 0 0 0 0
0 0 0 0 0 0
0 0 1 0 6 0
0 0 0 0 0 0

지도에서 0은 빈 칸, 6은 벽, 1~5는 CCTV의 번호이다. 
위의 예시에서 1번의 방향에 따라 감시할 수 있는 영역을 '#'로 나타내면 아래와 같다.

0 0 0 0 0 0	0 0 0 0 0 0	0 0 # 0 0 0	0 0 0 0 0 0
0 0 0 0 0 0	0 0 0 0 0 0	0 0 # 0 0 0	0 0 0 0 0 0
0 0 1 # 6 0	# # 1 0 6 0	0 0 1 0 6 0	0 0 1 0 6 0
0 0 0 0 0 0	0 0 0 0 0 0	0 0 0 0 0 0	0 0 # 0 0 0
      →		      ←		      ↑		      ↓

CCTV는 벽을 통과할 수 없기 때문에, 1번이 → 방향을 감시하고 있을 때는 6의 오른쪽에 있는 벽을 감시할 수 없다.

0 0 0 0 0 0
0 2 0 0 0 0
0 0 0 0 6 0
0 6 0 0 2 0
0 0 0 0 0 0
0 0 0 0 0 5

위의 예시에서 감시할 수 있는 방향을 알아보면 아래와 같다.

0 0 0 0 0 #	0 0 0 0 0 #	0 # 0 0 0 #	0 # 0 0 0 #
# 2 # # # #	# 2 # # # #	0 2 0 0 0 #	0 2 0 0 0 #
0 0 0 0 6 #	0 0 0 0 6 #	0 # 0 0 6 #	0 # 0 0 6 #
0 6 # # 2 #	0 6 0 0 2 #	0 6 # # 2 #	0 6 0 0 2 #
0 0 0 0 0 #	0 0 0 0 # #	0 0 0 0 0 #	0 0 0 0 # #
# # # # # 5	# # # # # 5	# # # # # 5	# # # # # 5
왼쪽 상단 2: ↔, 	왼쪽 상단 2: ↔,	왼쪽 상단 2: ↕,	왼쪽 상단 2: ↕,
오른쪽 하단 2: ↔	오른쪽 하단 2: ↕	오른쪽 하단 2: ↔	오른쪽 하단 2: ↕

CCTV는 CCTV를 통과할 수 있다. 아래 예시를 보자.

0 0 2 0 3
0 6 0 0 0
0 0 6 6 0
0 0 0 0 0

위와 같은 경우에 2의 방향이 ↕ 3의 방향이 ←와 ↓인 경우 감시받는 영역은 다음과 같다.

# # 2 # 3
0 6 # 0 #
0 0 6 6 #
0 0 0 0 #

사무실의 크기와 상태, 그리고 CCTV의 정보가 주어졌을 때, 
CCTV의 방향을 적절히 정해서, 사각 지대의 최소 크기를 구하는 프로그램을 작성하시오.

입력
첫째 줄에 사무실의 세로 크기 N과 가로 크기 M이 주어진다. (1 ≤ N, M ≤ 8)
둘째 줄부터 N개의 줄에는 사무실 각 칸의 정보가 주어진다. 
0은 빈 칸, 6은 벽, 1~5는 CCTV를 나타내고, 문제에서 설명한 CCTV의 종류이다. 
CCTV의 최대 개수는 8개를 넘지 않는다.

출력
첫째 줄에 사각 지대의 최소 크기를 출력한다.


예제 입력 1 
4 6
0 0 0 0 0 0
0 0 0 0 0 0
0 0 1 0 6 0
0 0 0 0 0 0
예제 출력 1 
20

예제 입력 2 
6 6
0 0 0 0 0 0
0 2 0 0 0 0
0 0 0 0 6 0
0 6 0 0 2 0
0 0 0 0 0 0
0 0 0 0 0 5
예제 출력 2 
15

예제 입력 3 
6 6
1 0 0 0 0 0
0 1 0 0 0 0
0 0 1 0 0 0
0 0 0 1 0 0
0 0 0 0 1 0
0 0 0 0 0 1
예제 출력 3 
6

예제 입력 4 
6 6
1 0 0 0 0 0
0 1 0 0 0 0
0 0 1 5 0 0
0 0 5 1 0 0
0 0 0 0 1 0
0 0 0 0 0 1
예제 출력 4 
2

예제 입력 5 
1 7
0 1 2 3 4 5 6
예제 출력 5 
0

예제 입력 6 
3 7
4 0 0 0 0 0 0
0 0 0 2 0 0 0
0 0 0 0 0 0 4
예제 출력 6 
0

*/

/*

CCTV의 종류에 따라 여러 방향으로 바꿔가며 사각지대의 최소 개수를 구하는 DFS+완전탐색 문제.

조건문을 잘 이용하면 카메라 방향 세팅을 미리 해두지 않아도 되지만,
방법이 빠르게 생각이 안났고 방향의 경우가 많지 않아 직접 값을 대입하는 방식을 사용했다.
(조금 귀찮을 수 있으나 오류가 발생하는 일이 거의 없고 코드가 굉장히 직관적이라는 장점이 있다)

또한, 나는 조합을 구하는 방법을 DFS라고 따로 명칭을 붙이진 않지만, (재귀함수를 사용하면 보통 DFS라고 부르더라...)
어쨌든 재귀함수를 사용한 DFS를 통해 감시카메라 종류에 따른 방향 개수만큼 반복문을 돌려 조합을 구했고,
그 조합의 길이가 주어진 CCTV의 개수가 됐을 때 0의 개수(사각지대의 개수)를 구하는 방식을 사용했다.

방향에 따라 감시카메라를 작동시키는 부분은 turnOn()함수를 통해 구현하였으며,
감시가 되는 부분은 -1으로 체크해두었다.

그리고 사실 이번에는 저번에 사용해보고 싶은 방법(조합이 확정되면 맵을 미리 바꿔놓는 형식)을 사용하여 구현해봤다!
그래서 이전 맵을 미리 저장해둘 temp라는 2차원 배열을 하나 사용했고,
새로운 조합이 생성될 때마다 temp에 저장해둔 맵을 map에 다시 옮겨줬다.

아예 조합을 구한 마지막에 감시카메라를 작동시키면 실행시간이 어느정도 될 지는 모르겠지만,
그래도 한 번 구현에 사용해보고자 했던 방법을 적용시킬 수 있어서 매우 뿌듯했다! ㅎㅎㅎ

*/

#define _CRT_SECURE_NO_WARNINGS

#include <cstdio>
#include <vector>

using namespace std;

const int MAX = 10;

int N, M;
int map[MAX][MAX];
int myMin;

vector<int> D[MAX][MAX];
int sizeD[MAX] = { 0, 4, 2, 4, 4, 1 };

int dy[4] = { -1, 1, 0, 0 };
int dx[4] = { 0, 0, -1, 1 };

struct CCTV {
    int y, x, n;

    void create(int _y, int _x, int _n) {
        y = _y;
        x = _x;
        n = _n;
    }
};

vector<CCTV> info;

void turnOn(int idx, int dir) {
    int y = info[idx].y;
    int x = info[idx].x;
    int n = info[idx].n;
    
    for (int i = 0; i < D[n][dir].size(); i++) {
        if (D[n][dir][i] == 0) { // 상
            for (int i = y - 1; i >= 0; i--) {
                if (map[i][x] == 6) break;
                
                if (map[i][x] == 0) map[i][x] = -1;
                else continue;
            }
        }
        else if (D[n][dir][i] == 1) { // 하
            for (int i = y + 1; i < N; i++) {
                if (map[i][x] == 6) break;

                if (map[i][x] == 0) map[i][x] = -1;
                else continue;
            }
        }
        else if (D[n][dir][i] == 2) { // 좌
            for (int i = x - 1; i >= 0; i--) {
                if (map[y][i] == 6) break;

                if (map[y][i] == 0) map[y][i] = -1;
                else continue;
            }
        }
        else { // 우
            for (int i = x + 1; i < M; i++) {
                if (map[y][i] == 6) break;

                if (map[y][i] == 0) map[y][i] = -1;
                else continue;
            }
        }
    }
}

void getArea() {
    // 사각지대의 개수를 반환
    int cnt = 0;
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < M; j++) {
            if (map[i][j] == 0) cnt++;
        }
    }

    if (cnt < myMin) myMin = cnt;
}

void getComb(int x) {
    if (x >= info.size()) {
        getArea();
    }
    else {
        // 맵 복사
        int temp[MAX][MAX];
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < M; j++) {
                temp[i][j] = map[i][j];
            }
        }

        int n = info[x].n;
        for (int k = 0; k < sizeD[n]; k++) {
            // 감시카메라 작동
            turnOn(x, k);
            getComb(x + 1);

            // 맵 원상복구
            for (int i = 0; i < N; i++) {
                for (int j = 0; j < M; j++) {
                    map[i][j] = temp[i][j];
                }
            }
        }
    }
}

int main()
{
    myMin = 987987987;
    scanf("%d %d", &N, &M);
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < M; j++) {
            scanf("%d", &map[i][j]);

            if (1 <= map[i][j] && map[i][j] <= 5) {
                CCTV ct;
                ct.create(i, j, map[i][j]);
                info.push_back(ct);
            }
        }
    }

    // CCTV 종류에 따른 카메라 방향 세팅
    D[1][0].push_back(0);
    D[1][1].push_back(1);
    D[1][2].push_back(2);
    D[1][3].push_back(3);

    D[2][0].push_back(2); D[2][0].push_back(3);
    D[2][1].push_back(0); D[2][1].push_back(1);

    D[3][0].push_back(0); D[3][0].push_back(3);
    D[3][1].push_back(1); D[3][1].push_back(3);
    D[3][2].push_back(1); D[3][2].push_back(2);
    D[3][3].push_back(0); D[3][3].push_back(2);

    D[4][0].push_back(0); D[4][0].push_back(2); D[4][0].push_back(3);
    D[4][1].push_back(0); D[4][1].push_back(1); D[4][1].push_back(3);
    D[4][2].push_back(1); D[4][2].push_back(2); D[4][2].push_back(3);
    D[4][3].push_back(0); D[4][3].push_back(1); D[4][3].push_back(2);

    D[5][0].push_back(0); D[5][0].push_back(1); D[5][0].push_back(2); D[5][0].push_back(3);

    // 조합 구하기
    getComb(0);

    printf("%d", myMin);

    return 0;
}