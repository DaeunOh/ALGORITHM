/*

시간 제한	메모리 제한	제출	정답	맞은 사람	정답 비율
1 초		512 MB		10821	5842	3835		51.449%

문제
드래곤 커브는 다음과 같은 세 가지 속성으로 이루어져 있으며, 이차원 좌표 평면 위에서 정의된다. 
좌표 평면의 x축은 → 방향, y축은 ↓ 방향이다.
1. 시작 점
2. 시작 방향
3. 세대

0세대 드래곤 커브는 아래 그림과 같은 길이가 1인 선분이다. 아래 그림은 (0, 0)에서 시작하고, 
시작 방향은 오른쪽인 0세대 드래곤 커브이다.

[그림1-1]

1세대 드래곤 커브는 0세대 드래곤 커브를 끝 점을 기준으로 시계 방향으로 90도 회전시킨 다음 
0세대 드래곤 커브의 끝 점에 붙인 것이다. 끝 점이란 시작 점에서 선분을 타고 이동했을 때, 가장 먼 거리에 있는 점을 의미한다.

[그림1-2]

2세대 드래곤 커브도 1세대를 만든 방법을 이용해서 만들 수 있다. (파란색 선분은 새로 추가된 선분을 나타낸다)

[그림2-1]

3세대 드래곤 커브도 2세대 드래곤 커브를 이용해 만들 수 있다. 아래 그림은 3세대 드래곤 커브이다.

[그림2-2]

즉, K(K > 1)세대 드래곤 커브는 K-1세대 드래곤 커브를 끝 점을 기준으로 90도 시계 방향 회전 시킨 다음, 
그것을 끝 점에 붙인 것이다.

크기가 100×100인 격자 위에 드래곤 커브가 N개 있다. 
이때, 크기가 1×1인 정사각형의 네 꼭짓점이 모두 드래곤 커브의 일부인 정사각형의 개수를 구하는 프로그램을 작성하시오. 
격자의 좌표는 (x, y)로 나타내며, 0 ≤ x ≤ 100, 0 ≤ y ≤ 100만 유효한 좌표이다.

입력
첫째 줄에 드래곤 커브의 개수 N(1 ≤ N ≤ 20)이 주어진다. 둘째 줄부터 N개의 줄에는 드래곤 커브의 정보가 주어진다. 
드래곤 커브의 정보는 네 정수 x, y, d, g로 이루어져 있다. 
x와 y는 드래곤 커브의 시작 점, d는 시작 방향, g는 세대이다. (0 ≤ x, y ≤ 100, 0 ≤ d ≤ 3, 0 ≤ g ≤ 10)

입력으로 주어지는 드래곤 커브는 격자 밖으로 벗어나지 않는다. 드래곤 커브는 서로 겹칠 수 있다.
방향은 0, 1, 2, 3 중 하나이고, 다음을 의미한다.
0: x좌표가 증가하는 방향 (→)
1: y좌표가 감소하는 방향 (↑)
2: x좌표가 감소하는 방향 (←)
3: y좌표가 증가하는 방향 (↓)

출력
첫째 줄에 크기가 1×1인 정사각형의 네 꼭짓점이 모두 드래곤 커브의 일부인 것의 개수를 출력한다.

예제 입력 1 
3
3 3 0 1
4 2 1 3
4 2 2 1
예제 출력 1 
4
예제 입력 2 
4
3 3 0 1
4 2 1 3
4 2 2 1
2 7 3 4
예제 출력 2 
11
예제 입력 3 
10
5 5 0 0
5 6 0 0
5 7 0 0
5 8 0 0
5 9 0 0
6 5 0 0
6 6 0 0
6 7 0 0
6 8 0 0
6 9 0 0
예제 출력 3 
8
예제 입력 4 
4
50 50 0 10
50 50 1 10
50 50 2 10
50 50 3 10
예제 출력 4 
1992

힌트
[그림3]

*/

/*

그동안 문제를 풀어 오면서 수학적 지식이 요구되는 문제는 거의 없었는데,
회전변환 개념이 갑자기 나와버려서... 매우 당황했던 문제 ㄷㄷㄷ

처음에는 회전변환 없이 진행해보려 했는데, 회전변환 말고는 어떻게 풀어야 할지 전혀 감이 오지 않아서
결국 구글의 도움으로 회전변환 식을 알아냈다고 한다 하하하~~~

(0, 0)을 중심점으로 했을 때, 반시계 방향의 회전변환을 통해 얻은 새로운 x좌표와 y좌표를 x', y'이라 한다면,
x' = xcosΘ - ysinΘ, y' = xsinΘ + ycosΘ가 되는데, 이 문제에서 원하는 값은 (0, 0)이 중심점이 아닌 (a, b)가 중심점이다.
따라서 (a, b)를 (0, 0)으로 옮겨준 후에 회전을 거치고, 다시 (a, b)로 중심점을 옮겨주는 과정이 필요하다.
즉, x' = (x-a)cosΘ - (y-b)sinΘ + a, y' = (x-a)sinΘ + (y-b)cosΘ + b가 되는 것이다.

그런데, 여기서 헷갈리지 말아야 할 부분은, 회전 변환이 본래 반시계방향으로의 회전이지만,
여기서는 시계 방향으로 회전하기 때문에 방향이 다른건 아닐까?라고 생각할 수도 있는데,(그게 나다...)
여기서 사용하는 좌표 평면은 일반적인 좌표 평면이 아닌, y축이 반대 방향으로 되어있는 좌표 평면이다.
따라서 일반 좌표 평면에서의 반시계방향은, 해당 문제에서는 시계방향이 되는 것이므로 회전변환을 그대로 사용해도 된다.
그러므로 문제에 나와있는대로 Θ에 90도를 넣어서 계산해주면, x' = -y + b + a, y' = x - a + b가 된다.

또한, 드래곤 커브를 만들 때 벡터에 커브의 점이 차곡차곡 들어가도록 해야하는데,
드래곤 커브를 잘 보면, 드래곤 커브의 시작점이 다음 커브에서는 끝 점으로 바뀌는 것을 알 수 있다.
따라서 새로운 커브는 드래곤 커브의 끝에서 2번째 있는 점부터 첫번째 있는 점까지 차례대로 90도 회전되도록 구현해야 한다.

그리고 주어진 드래곤 커브를 다 생성했다면, map의 모든 지점을 보면서
네 꼭짓점이 드래곤 커브의 일부분인 지점이 있는지 확인하여 그 갯수를 세어주면 된다.

수학적 개념이 나온 것이 가장 충격이었고, 회전변환의 개념을.. 까먹었단 것 자체가 두번째 충격이었던 문제..ㅋㅋ
역시 수학 개념은... 알아두면 여러모로 참 유용할 때가 많다 ㅋㅋㅋㅋ 잊어버리지 말자!!!!

*/

#include <iostream>
#include <vector>

using namespace std;

const int MAX = 100 + 10;

int N;
int map[MAX][MAX] = { 0, };
int cnt = 0;

struct CURVE {
    int x, y;
};

vector<CURVE> C;

int dx[4] = { 1, 0, -1, 0 };
int dy[4] = { 0, -1, 0, 1 };

void createCurve() {
    // 벡터의 끝 부분을 제외한 나머지 점들을 끝에서 부터 시계 방향으로 90도 회전시킨다.
    // 그리고 이 때의 중심점(끝 점)은 항상 벡터의 끝 부분에 있다.
    int a = C.back().x;
    int b = C.back().y;
    int CSize = C.size();

    for (int i = CSize - 2; i >= 0; i--) {
        int nx = -C[i].y + b + a;
        int ny = C[i].x - a + b;

        C.push_back({ nx, ny });
        map[ny][nx]++; // 해당 위치에 점이 있음을 표시한다.
    }
}

int main() {
    ios_base::sync_with_stdio(0);
    cin.tie(0);

    cin >> N;

    for (int i = 0; i < N; i++) {
        int x, y, d, g;
        cin >> x >> y >> d >> g;

        C.push_back({ x, y }); // 0세대 드래곤 커브 시작 점
        C.push_back({ x + dx[d], y + dy[d] }); // 0세대 드래곤 커브 끝 점
        map[C[0].y][C[0].x]++;
        map[C[1].y][C[1].x]++;

        while (g--) createCurve(); // g세대가 될 때까지 드래곤 커브를 생성한다.

        C.clear();
    }

    for (int i = 0; i < 100; i++) {
        for (int j = 0; j < 100; j++) {
            // map의 모든 지점을 보면서 네 꼭짓점이 드래곤 커브의 일부분인 지점이 있는지 확인한다.
            if (map[i][j] && map[i][j + 1] && map[i + 1][j] && map[i + 1][j + 1]) cnt++;
        }
    }

    cout << cnt;

    return 0;
}