// 소요시간: 13분
// 실행시간: 0ms

/*

시간 제한	메모리 제한	제출	정답	맞은 사람	정답 비율
1 초	128 MB		22886	12493	8518		53.840%

문제
독일 로또는 {1, 2, ..., 49}에서 수 6개를 고른다.
로또 번호를 선택하는데 사용되는 가장 유명한 전략은
49가지 수 중 k(k>6)개의 수를 골라 집합 S를 만든 다음 그 수만 가지고 번호를 선택하는 것이다.

예를 들어, k=8, S={1,2,3,5,8,13,21,34}인 경우 이 집합 S에서 수를 고를 수 있는 경우의 수는 총 28가지이다. 
([1,2,3,5,8,13], [1,2,3,5,8,21], [1,2,3,5,8,34], [1,2,3,5,13,21], ..., [3,5,8,13,21,34])

집합 S와 k가 주어졌을 때, 수를 고르는 모든 방법을 구하는 프로그램을 작성하시오.

입력
입력은 여러 개의 테스트 케이스로 이루어져 있다. 각 테스트 케이스는 한 줄로 이루어져 있다. 
첫 번째 수는 k (6 < k < 13)이고, 다음 k개 수는 집합 S에 포함되는 수이다. S의 원소는 오름차순으로 주어진다.
입력의 마지막 줄에는 0이 하나 주어진다. 

출력
각 테스트 케이스마다 수를 고르는 모든 방법을 출력한다. 이때, 사전 순으로 출력한다.
각 테스트 케이스 사이에는 빈 줄을 하나 출력한다.

*/

/*

◆ 풀이

오름차 순으로 정렬되어 있는 K개의 수 중에 6개를 뽑아서 나열하는 완전탐색 문제.
여기서 중요한 점은 숫자의 순서는 고려되지 않는다는 것이다.
즉, {1, 2, 3, 4, 5, 6}과 {6, 5, 4, 3, 2, 1}은 동일하게 취급된다.

조합을 구하기 위해 check라는 배열을 사용하여
i를 0부터 K-1까지 증가시키면서 S[i]에 할당되어 있는 숫자가 쓰였는지의 여부를 확인하면서 조합을 구해도 되지만,
어차피 각 숫자는 오름차순으로 정렬되어 있고, 최대 1개밖에 존재하지 않으므로
매번 반복문의 i를 0이 아닌 s부터 시작하는 방법을 사용하는 것이 연산 횟수를 줄이는 데에 더 도움이 된다.

즉, 조합을 구하기 위해 사용하는 재귀 함수를 호출할 때,
x의 인덱스를 1 증가시켜 주는 것뿐만 아니라, 현재 위치(i) + 다음(1) 부터 탐색할 수 있도록 s를 i + 1로 바꿔주는 것이다.

이렇게 하면 반복문의 횟수를 최대한 줄이면서 중복되지 않는 모든 경우를 다 구할 수 있다.


◆ 후기

처음에는 이 문제를 풀기 위해 이미 사용한 숫자는 사용하지 않도록 check라는 배열을 사용해야 하나? 싶었는데,
구현하다 보니 check라는 배열을 사용하지 않아도, 반복문의 시작 위치를 업데이트해주는 것만으로
모든 조합을 구할 수 있음을 깨닫게 되었다.

이 방법은 특히 길이가 긴 조합을 구해야 할 때, 필요 없는 반복문을 최대한 줄여주는 방법으로 자주 사용된다.
예전에도 다른 문제에서 인덱스를 늘 0부터 확인하는 방법을 사용하여 구현한 적이 있었는데,
결국 너무 많은 연산으로 인해 시간초과가 났던 경험이 있다.

잘 기억해두도록 하자! ^_^

*/

#include <iostream>

using namespace std;

const int MAX = 13 + 10;

int K;
int S[MAX];

int comb[MAX];

void getComb(int x, int s) {
    if (x >= 6) {
        for (int i = 0; i < 6; i++) cout << comb[i] << " ";
        cout << "\n";
    }
    else {
        for (int i = s; i < K; i++) {
            comb[x] = S[i];
            getComb(x + 1, i + 1);
        }
    }
}

int main() {
    ios_base::sync_with_stdio(0);
    cin.tie(0);

    while (1) {
        cin >> K;
        if (K == 0) break;

        for (int i = 0; i < K; i++) cin >> S[i];

        getComb(0, 0);

        cout << "\n";
    }

    return 0;
}