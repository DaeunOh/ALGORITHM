// 소요시간: 30분
// 실행시간: 0ms

/*

시간 제한	메모리 제한	제출	정답	맞은 사람	정답 비율
1 초	4 MB (하단 참고)	12765	4587	3512		36.132%

문제
N줄에 0 이상 9 이하의 숫자가 세 개씩 적혀 있다. 
내려가기 게임을 하고 있는데, 이 게임은 첫 줄에서 시작해서 마지막 줄에서 끝나게 되는 놀이이다.

먼저 처음에 적혀 있는 세 개의 숫자 중에서 하나를 골라서 시작하게 된다. 
그리고 다음 줄로 내려가는데, 다음 줄로 내려갈 때에는 다음과 같은 제약 조건이 있다. 
바로 아래의 수로 넘어가거나, 아니면 바로 아래의 수와 붙어 있는 수로만 이동할 수 있다는 것이다. 
이 제약 조건을 그림으로 나타내어 보면 다음과 같다.
[그림]

별표는 현재 위치이고, 그 아랫 줄의 파란 동그라미는 원룡이가 다음 줄로 내려갈 수 있는 위치이며, 
빨간 가위표는 원룡이가 내려갈 수 없는 위치가 된다. 숫자표가 주어져 있을 때, 
얻을 수 있는 최대 점수, 최소 점수를 구하는 프로그램을 작성하시오. 점수는 원룡이가 위치한 곳의 수의 합이다.

입력
첫째 줄에 N(1 ≤ N ≤ 100,000)이 주어진다. 
다음 N개의 줄에는 숫자가 세 개씩 주어진다. 숫자는 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 중의 하나가 된다.

출력
첫째 줄에 얻을 수 있는 최대 점수와 최소 점수를 띄어서 출력한다.

*/

/*

◆ 풀이

이전에 풀었던 숫자 만들기와 거의 유사한 내용의 DP문제.....이지만..!!!
복습을 안했더니 기억이 1도 안났던 문제이다 ㅎㅎ..

DP문제는 1차원 테이블을 사용하는 경우와 2차원 테이블을 사용하는 경우 두 가지로 나뉜다.
이 문제는 후자에 해당하는 문제로, i번째까지 온 경로가 i+1번째에서는 최선이 아닐 수 있으므로,
항상 i-1번째에 대한 정보들을 모두 기억하고 있어야 한다는 것이 핵심이다.

또한, i-1번째까지만 기억하면 되므로, 이전의 모든 정보들은 계속 기억해둘 필요는 없다.
(여기에서 메모리를 최대 4MB로 잡아놨기 때문에, 모든 정보를 저장한다면 문제를 통과할 수 없다.)

그럼 i-1번째를 사용해서 i번째의 답은 어떻게 구할 수 있을까?

초기 테이블은 이전의 정보가 없으므로 그 숫자 자체가 min, max가 된다.
그리고 i가 1이상 부터는 i-1번째의 정보를 활용하게 되는데,
i번째에서 최솟값을 찾기 위해서는 i-1번째의 가능한 경우들 중 최솟값을 구해야 하고,
그 최솟값에 자신을 더한 값이 해당 숫자를 선택했을 때의 최솟값이 된다.
그리고 최댓값도 역시 i-1번째의 가능한 경우들 중 최댓값을 구하고, 그 최댓값에 자신을 더한 값이 최댓값이 된다.

이렇게 매번 각 숫자를 선택했을 때의 최솟값, 최댓값을 업데이트 시킴으로써
가장 마지막 N번째 숫자까지 거치고 나서의 최솟값, 최댓값 중 가장 최솟값, 최댓값이 이 문제의 답이 되는 것이다.


◆ 후기

사실 처음에는 오늘 배웠던 슬라이딩 윈도우를 사용하기 위해서 일부러 슬라이딩 윈도우 카테고리의 문제를 푼건데,
갑자기 DP 개념이 나와서 깜짝 놀랐다...

폭이 3인 창문이 이동하면서 계속 최솟값, 최댓값을 업데이트 시키기 때문에
메모리를 효율적으로 사용하는 면에서 슬라이딩 윈도우 기법이라고 할 수는 있겠지만, 
나는 s와 e의 포인터를 옮겨 가면서 푸는 문제를 원했기 때문에 
굳이 정의하자면 이 문제는 DP 문제라고 생각하는 편이 조금 더 낫겠다고 생각했다!

어쨌든, DP는 항상 보면 점화식만 세우면 끝나는 문제인데, 그 점화식을 세우는 것이 어렵다는게 가장 슬프다..ㅎㅎㅋㅋㅋ
이 문제에서는 i번째까지 온 경로가 i+1번째에서는 최선이 아닐 수 있다는 점 때문에
어떻게 풀어야할지가 처음에 가장 막막했는데, 오히려 그 부분이 다시 개념을 알고 풀 때는 힌트였다는 게 가장 당황스러웠다..ㅋㅋㅋ

아 그리고, 코드에서는 미리 점수들을 scores라는 배열에 저장해두고 사용했는데,
사실 저장해두지 않아도 바로 바로 입력 받음과 동시에 계산도 가능한 문제이므로
굳이 약 30만개의 메모리를 사용하지 않아도 됐다.

문제를 풀 때는 메모리를 얼만큼 할당하든 그 문제만 풀리면 상관 없긴 하지만,
실제 회사에서는 이런 메모리 관리도 중요하다고 하니(메모리가 곧 돈ㄷㄷ)
앞으로 쓸데없는 메모리 할당은 굳이 하지 않도록 신경 써야겠다.

*/

#include <iostream>
#include <algorithm>

using namespace std;

const int MAX = 100000 + 10;

int N;
int scores[MAX][3];

int prevMin[3];
int prevMax[3];

int main() {
    ios_base::sync_with_stdio(0);
    cin.tie(0);

    cin >> N;
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < 3; j++) {
            cin >> scores[i][j];
        }
    }

    for (int i = 0; i < 3; i++) {
        prevMin[i] = scores[0][i];
        prevMax[i] = scores[0][i];
    }

    int myMin[3], myMax[3];
    for (int i = 1; i < N; i++) {
        myMin[0] = min(prevMin[0], prevMin[1]);
        myMin[1] = min(myMin[0], prevMin[2]);
        myMin[2] = min(prevMin[1], prevMin[2]);

        myMax[0] = max(prevMax[0], prevMax[1]);
        myMax[1] = max(myMax[0], prevMax[2]);
        myMax[2] = max(prevMax[1], prevMax[2]);
        
        for (int j = 0; j < 3; j++) {
            prevMin[j] = myMin[j] + scores[i][j];
            prevMax[j] = myMax[j] + scores[i][j];
        }
    }

    cout << max(max(prevMax[0], prevMax[1]), prevMax[2]) << " ";
    cout << min(min(prevMin[0], prevMin[1]), prevMin[2]);

    return 0;
}