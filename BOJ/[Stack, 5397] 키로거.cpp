/*

시간 제한	메모리 제한	제출	정답	맞은 사람	정답 비율
1 초		256 MB		16312	4065	2570	23.535%
문제
창영이는 강산이의 비밀번호를 훔치기 위해서 강산이가 사용하는 컴퓨터에 키로거를 설치했다. 며칠을 기다린 끝에 창영이는 강산이가 비밀번호 창에 입력하는 글자를 얻어냈다.

키로거는 사용자가 키보드를 누른 명령을 모두 기록한다. 따라서, 강산이가 비밀번호를 입력할 때, 화살표나 백스페이스를 입력해도 정확한 비밀번호를 알아낼 수 있다.

강산이가 비밀번호 창에서 입력한 키가 주어졌을 때, 강산이의 비밀번호를 알아내는 프로그램을 작성하시오.

입력
첫째 줄에 테스트 케이스의 개수가 주어진다. 각 테스트 케이스는 한줄로 이루어져 있고, 강산이가 입력한 순서대로 길이가 L인 문자열이 주어진다. (1 ≤ L의 길이 ≤ 1,000,000) 강산이가 백스페이스를 입력했다면, '-'가 주어진다. 이때 커서의 바로 앞에 글자가 존재한다면, 그 글자를 지운다. 화살표의 입력은 '<'와 '>'로 주어진다. 이때는 커서의 위치를 움직일 수 있다면, 왼쪽 또는 오른쪽으로 1만큼 움직인다. 나머지 문자는 비밀번호의 일부이다. 물론, 나중에 백스페이스를 통해서 지울 수는 있다. 만약 커서의 위치가 줄의 마지막이 아니라면, 그 문자를 입력하고, 커서는 오른쪽으로 한 칸 이동한다.

출력
각 테스트 케이스에 대해서, 강산이의 비밀번호를 출력한다. 비밀번호의 길이는 항상 0보다 크다.

예제 입력 1 
2
<<BP<A>>Cd-
ThIsIsS3Cr3t
예제 출력 1 
BAPC
ThIsIsS3Cr3t

*/

/*

처음에 떠오르는 생각은 당연히 문자를 삽입하고, 지우는 방법이겠지만 이 문제의 풀이 방법은 스택을 2개 이용하는 것이다.

여러 개의 테스트케이스가 존재하고, 문자열의 길이가 최대 100만이기 때문에
삽입, 삭제를 할 때마다 O(N)이 걸리는 방법은 시간 제한이 1초인 이 문제에서 사용할 수 없다.
(사실 스택 문제 풀라고 찾은 문제였는데, 너무 어처구니 없이 시간복잡도 계산하지 않고 해당 방법으로 구현했었다;;;ㅋㅋㅋ;;)

스택을 이용하여 해결하는 방법은, 문자를 저장할 스택(s1) 1개와 화살표에 따른 문자를 저장할 스택(s2) 1개 총 2개가 필요하다.
그리고 앞에서부터 한 글자씩 읽어가면서 나오는 문자에 대해 다음과 같이 처리한다.
1) 문자인 경우
    s1에 그 문자를 push 한다.
2) 백스페이스인 경우
    s1이 비어있지 않다면, s1을 pop한다.
3) '<'인 경우
    s1이 비어있지 않다면, s2에 s1의 top을 push하고, s1을 pop한다.
4) '>'인 경우
    s2가 비어있지 않다면, s1에 s2의 top을 push하고, s2를 pop한다.

위처럼 구현하면 s2가 실제로 커서를 옮기는 역할을 하게 되고, s1에서의 삽입, 삭제에 대한 시간은 O(1)이 된다.
화살표 처리도 push 1번, pop 1번이면 가능하므로 빠른 시간내에 해결이 가능하다.


그런데 이 문제를 풀면서, 그동안 써왔던 입출력 형식을 바꿀 필요성을 느꼈다.
scanf, printf가 cin, cout보다 훨씬 빠르다는 얘기를 들어왔기 때문에, 항상 어떤 문제든 scanf, printf로 풀려고 노력해왔다.

그래서 해당 문제를 풀 때도 테스트케이스가 여러 개 주어지고, 문자열이 최대 100만이기 때문에
scanf를 이용하여 입력을 받으려면 크기가 100만 이상인 문자열을 미리 선언해주고 그 문자열을 사용했다.

그런데 백준에서는(다른 환경에서도 그런진 모르겠지만) 크기가 100만인 배열을 전역변수로 선언한 후
그걸 입출력에 사용하려고 하면 시간초과가 난다. (지역변수에 선언하면 그냥 스택 자체가 터져버린다..ㄷㄷ)

시간초과가 나는 이유를 정확히 몰랐을 때는 여러 시도를 해보다가
혹시나 하는 마음에 문자열을 받기 위한 방법으로 배열이 아니라 string을 사용했는데,
cin cout과 함께 string을 사용했을 때에는 시간초과 없이 해결됐다.

그리고 이후, cin cout의 속도를 줄이기 위해
ios_base::sync_with_stdio(0);
cin.tie(0);
를 코드에 추가했더니 더 빨라졌다.

실제로 싱크를 맞춰주는 방법을 사용하면, scanf printf보다 cin cout이 더 빠르다고 한다.
https://www.acmicpc.net/blog/view/56
https://www.acmicpc.net/blog/view/57

저번에도 문자를 받을때 시간초과가 난 이유중 하나가 배열 크기 문제였는데 (최대 크기를 잘못 설정해줘서긴 하지만..)
혹시나 나중에도 배열 크기 자체때문에 시간초과가 날 일이 생길 수도 있으니까
그냥 이제부터 싱크를 맞춰준 cin, cout을 사용하려고 한다! (단, scanf, printf를 함께 쓰면 안된다.)

그리고 실제로 string을 사용했을 때 더 편리한 함수들도 많다 ㅎㅎ 화이팅~!

*/

#include <iostream>
#include <stack>
#include <string>
#include <algorithm>

using namespace std;

int main() {
    ios_base::sync_with_stdio(0);
    cin.tie(0);

    int T;
    cin >> T;

    while (T--) {
        string str;
        cin >> str;

        stack<char> s1, s2;

        for (int i = 0; i < str.length(); i++) {
            if (str[i] == '<') {
                if (!s1.empty()) {
                    s2.push(s1.top());
                    s1.pop();
                }
            }
            else if (str[i] == '>') {
                if (!s2.empty()) {
                    s1.push(s2.top());
                    s2.pop();
                }
            }
            else if (str[i] == '-') {
                if (!s1.empty()) {
                    s1.pop();
                }
            }
            else {
                s1.push(str[i]);
            }
        }

        while (!s2.empty()) {
            s1.push(s2.top());
            s2.pop();
        }

        string res;
        while (!s1.empty()) {
            res += s1.top();
            s1.pop();
        }

        reverse(res.begin(), res.end());
        cout << res << "\n";
    }

    return 0;
}