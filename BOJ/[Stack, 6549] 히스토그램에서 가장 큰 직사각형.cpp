/*

시간 제한	메모리 제한	제출	정답	맞은 사람	정답 비율
1 초		256 MB	16723	3987	2588	25.229%

문제
히스토그램은 직사각형 여러 개가 아래쪽으로 정렬되어 있는 도형이다. 
각 직사각형은 같은 너비를 가지고 있지만, 높이는 서로 다를 수도 있다. 
예를 들어, 왼쪽 그림은 높이가 2, 1, 4, 5, 1, 3, 3이고 너비가 1인 직사각형으로 이루어진 히스토그램이다.

<그림>

히스토그램에서 가장 넓이가 큰 직사각형을 구하는 프로그램을 작성하시오.

입력
입력은 테스트 케이스 여러 개로 이루어져 있다. 
각 테스트 케이스는 한 줄로 이루어져 있고, 직사각형의 수 n이 가장 처음으로 주어진다. (1 ≤ n ≤ 100,000) 
그 다음 n개의 정수 h1, ..., hn (0 ≤ hi ≤ 1,000,000,000)가 주어진다. 
이 숫자들은 히스토그램에 있는 직사각형의 높이이며, 왼쪽부터 오른쪽까지 순서대로 주어진다. 
모든 직사각형의 너비는 1이고, 입력의 마지막 줄에는 0이 하나 주어진다.

출력
각 테스트 케이스에 대해서, 히스토그램에서 가장 넓이가 큰 직사각형의 넓이를 출력한다.

예제 입력 1 
7 2 1 4 5 1 3 3
4 1000 1000 1000 1000
0
예제 출력 1 
8
4000

*/

/*

해당 문제는 스택으로도, 세그먼트 트리를 이용한 분할 정복법으로 해결 가능하지만,
개인적으로 아이디어 자체가 떠오르지 않아 엄청나게 고생한 문제이다...

이 문제가 스택과 관련된 문제에 들어있었기 때문에 첫 1시간 동안은 스택을 이용해서 계속 도전해봤다. 
(그러나 어떻게 해봐도 아이디어가 도무지 떠오르지 않아 실패...)

1시간이 지나고 나서는 세그먼트 트리, 스택으로 해결이 가능하다는 정보를 입수했지만,
세그먼트 트리는 아예 생소한 개념이라 세그먼트 트리에 대한 공부가 필요했다.
공부를 하고 나서는 다시 어떻게 적용할 수 있을 지에 대해 고민해보는 시간을 가졌다.
(이 때의 나는 두 가지의 개념을 모두 사용해야 하는 줄 알았다. ㅎㅎㅎ;;;)

그러나 세그먼트 트리를 어떻게 응용하여 해당 문제에 적용할 수 있을지,
또 스택은 어떻게 사용해야 할지가 전혀 감이 잡히지 않아 결국에는 처음으로 백준님의 포스팅을 참고하게 되었다. ㄷㄷㄷ
(이 포스팅을 보고 나서야 세그먼트 트리를 이용한 분할 정복법 / 스택 두 가지 방법으로 구현이 가능하다는 것을 알게됨....ㅠ)

그런데 사실 .... 풀이를 봐도 이해가 한 번에 되지는 않았다.. 이해하기 위해 몇 번은 되풀이해서 읽은 것 같다. ㅜㅜ..
그리고 풀이를 이해하고 나서는 그 풀이를 기반으로 새로 설계를 하고, 다시 구현을 하려고 했는데
일단 오늘은 스택이랑 조금 더 친해지기(?) 위해 이 문제에 도전했던 터라 스택을 이용한 구현만 먼저 끝냈다.
(세그먼트 트리를 이용한 분할 정복법은 다시 한 번 세그먼트 트리에 대해 완벽하게 공부하고 다른 문제와 함께 구현할 것이다!)

스택을 사용하여 구현하는 방법은 코드에 주석으로 자세히 달아 놓았다.
다음에 다시 풀었을 때 해당 코드를 다시 보는 일은 없기를!

*/

#define _CRT_SECURE_NO_WARNINGS

#include <cstdio>
#include <stack>
#include <algorithm>

using namespace std;

const int MAX = 100000 + 10;

int n;
long long h[MAX];
stack<int> s;

int main() {
    while (1) {
        scanf("%d", &n);
        if (n == 0) break;
        
        for (int i = 0; i < n; i++) scanf("%lld", &h[i]);
        long long myMax = -987987987;

        // 모든 막대 x에 대해 x를 높이로 하면서 만들 수 있는 가장 큰 직사각형을 찾아야 한다.
        // left: x 왼쪽 막대 중 x보다 높이가 작은 첫 번째 막대
        // right: x 오른쪽 막대 중 x보다 높이가 작은 첫 번째 막대

        // 스택이 비었다면 막대 x를 스택에 넣고, 
        // 비지 않았다면 막대를 스택에 넣기 전 top과 현재 막대 x를 비교한다.
            // 만약 top의 높이가 x의 높이보다 크다면 top 높이 직사각형은 x를 지나갈 수 없다.
            // 따라서 right = x-1이 되고, left = 스택의 top 다음이 된다.
        for (int x = 0; x < n; x++) {
            while (!s.empty() && h[s.top()] > h[x]) {
                long long height = h[s.top()];
                s.pop();

                int width = x; // 기본 width는 0부터 x-1까지의 길이이다.
                if(!s.empty()) width = x - 1 - s.top(); // right - left

                myMax = max(myMax, width * height);
            }
            s.push(x);
        }

        // 여기까지 와서 스택이 비지 않은 경우는 right = n-1인 경우이다.
        // 따라서 스택이 빌 때까지 top 막대로 만들 수 있는 큰 직사각형을 만든다.
        while (!s.empty()) {
            long long height = h[s.top()];
            s.pop();

            int width = n; // 기본 width는 0부터 n-1까지의 길이이다.
            if (!s.empty()) width = n - 1 - s.top();

            myMax = max(myMax, width * height);
        }

        printf("%lld\n", myMax);
    }

    return 0;
}