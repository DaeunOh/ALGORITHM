// 소요시간: 12분
// 실행시간: 0ms

/*

시간 제한	메모리 제한	제출	정답	맞은 사람	정답 비율
0.5 초	128 MB		14015		6829	4674		50.497%

문제
N개의 수로 된 수열 A[1], A[2], …, A[N] 이 있다. 
이 수열의 i번째 수부터 j번째 수까지의 합 A[i]+A[i+1]+…+A[j-1]+A[j]가 M이 되는 경우의 수를 구하는 프로그램을 작성하시오.

입력
첫째 줄에 N(1≤N≤10,000), M(1≤M≤300,000,000)이 주어진다. 
다음 줄에는 A[1], A[2], …, A[N]이 공백으로 분리되어 주어진다. 각각의 A[x]는 30,000을 넘지 않는 자연수이다.

출력
첫째 줄에 경우의 수를 출력한다.

*/

/*

◆ 풀이

슬라이딩 윈도우를 사용하지 않으면 시간 복잡도가 O(N^2)이지만,
슬라이딩 윈도우를 사용하면 O(N)만에 해결할 수 있는 문제.

슬라이딩 윈도우를 사용하기 위해서는 시작 지점을 가리키는 s와 끝 지점을 가리키는 e 총 2개의 포인터가 필요하다.
s와 e의 초기값은 0이며, s가 가리키는 수는 포함하도록, e가 가리키는 수는 포함하지 않도록 정의한다.
(초기값은 둘 다 0이므로, 계산되는 결과도 처음엔 0으로 본다.)

그리고 포인터 e를 계속 이동시키다가, 특정 조건을 만족시키지 않는 경우가 생기면
그 조건을 다시 만족시키기 위해 S를 이동하는 방식을 계속 사용하는 것이 바로 슬라이딩 윈도우이다.

이를 이 문제에 적용해보면, 문제에서 구하는 것은 i번째부터 j번째까지 수의 합이 M이 되는 개수를 구하는 것이므로,
sum을 누적시켜 나가면서, sum >= M인 경우에는 s를 이동시키면서 그 인덱스에 해당하는 값을 sum에서 빼줘야 하며,
sum < M인 경우에는 e를 이동시키면서 그 인덱스에 해당하는 값을 sum에 더해줘야 한다.

또한, 이러한 과정이 끝나는 시점은 e가 가장 끝에 도달했으며, s가 더이상 움직이지 않을 때까지 이므로,
while문 안에서 조건을 확인하기 위해서는
1) sum >= M인지, 2) e == N인지, 3) sum < M인지 차례대로 확인해줘야 한다. (if, else if, else)
만약 1)과 3)사이에 2)를 넣지 않는다면, s가 이동할 수 있는지와 상관 없이 e가 끝에 도달하는 즉시 반복문이 끝나므로
반드시 1)과 3)사이에 2를 넣어주도록 한다.

그리고 구해진 sum이 M과 같은 경우에는 정답을 1 증가시켜주도록 한다.


◆ 후기

오늘 카카오 코딩테스트를 보면서 슬라이딩 윈도우 문제가 나왔는데,
이전에 슬라이딩 윈도우 개념을 대충 보고 넘어간 탓에 이번 문제를 풀 때 바로 생각이 안나는 참사가 일어났었다..ㅎㅎ;;

효율성 문제가 포함되었기 때문에 기본 시간 복잡도인 O(N^2)만에는 해결할 수 없고,
슬라이딩 윈도우를 사용해서 O(N)으로 줄여야만 통과가 가능한 문제였다. ㅠㅠㅠ

그리고 사실 슬라이딩 윈도우는 저번 다른 기업 코테에서도 나왔던 문제기 때문에
이번에는 제대로 정리해두고 넘어가야지!란 생각에 이 문제를 풀게 되었다.

풀이에서 언급했던 2)를 1)과 3) 사이에 넣지 않고, 맨 마지막에 넣어서 첫 시도는 실패했지만,
그 실패로 인해 s의 특성을 정확히 이해할 수 있었고, 슬라이딩 윈도우가 끝나는 시점도 정확하게 알 수 있었다.

아무리 아는 개념이라고 해도, 완벽하게 자신의 것으로 만들었느냐는 질문에 대해서 "그렇다"라고 말하기 위해서는
정말 많은 노력이 필요한 것 같다. (사실 요즘 문제를 풀 때뿐만 아니라 내 삶에 비춰도 이와 관련해선 많은 생각이 든다.)
이미 알고 있는 개념이라도 항상 처음이라는 생각으로 매 순간 열심히 살아보자!^_^

*/

#include <iostream>

using namespace std;

const int MAX = 10000 + 10;

int N, M;
int A[MAX];
int answer = 0;

int main() {
    ios_base::sync_with_stdio(0);
    cin.tie(0);

    cin >> N >> M;
    for (int i = 0; i < N; i++) cin >> A[i];

    int s = 0, e = 0; // s는 포함, e는 미포함
    int sum = 0;

    while (1) {
        if (sum >= M) sum -= A[s++];
        else if (e == N) break; // e가 끝에 도달했더라도 s는 움직일 수 있으므로, s를 가장 먼저 확인 후 e를 확인한다.
        else if (sum < M) sum += A[e++];

        if (sum == M) answer++;
    }

    cout << answer;

    return 0;
}