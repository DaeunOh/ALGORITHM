// 소요시간: 45분
// 실행시간: 0ms

/*

시간 제한	메모리 제한	제출	정답	맞은 사람	정답 비율
2 초	512 MB		11648		6021	4357		52.973%

문제
크기가 N×N인 지도가 있다. 지도의 각 칸에는 그 곳의 높이가 적혀져 있다. 
오늘은 이 지도에서 지나갈 수 있는 길이 몇 개 있는지 알아보려고 한다. 
길이란 한 행 또는 한 열 전부를 나타내며, 한쪽 끝에서 다른쪽 끝까지 지나가는 것이다. 

다음과 같은 N=6인 경우 지도를 살펴보자.
[그림1-1]

이때, 길은 총 2N개가 있으며, 아래와 같다.
[그림1-2]

길을 지나갈 수 있으려면 길에 속한 모든 칸의 높이가 모두 같아야 한다. 
또는, 경사로를 놓아서 지나갈 수 있는 길을 만들 수 있다. 경사로는 높이가 항상 1이며, 길이는 L이다. 
또, 개수는 매우 많아 부족할 일이 없다. 경사로는 낮은 칸과 높은 칸을 연결하며, 아래와 같은 조건을 만족해야한다.
- 경사로는 낮은 칸에 놓으며, L개의 연속된 칸에 경사로의 바닥이 모두 접해야 한다.
- 낮은 칸과 높은 칸의 높이 차이는 1이어야 한다.
- 경사로를 놓을 낮은 칸의 높이는 모두 같아야 하고, L개의 칸이 연속되어 있어야 한다.

아래와 같은 경우에는 경사로를 놓을 수 없다.
- 경사로를 놓은 곳에 또 경사로를 놓는 경우
- 낮은 칸과 높은 칸의 높이 차이가 1이 아닌 경우
- 낮은 지점의 칸의 높이가 모두 같지 않거나, L개가 연속되지 않은 경우
- 경사로를 놓다가 범위를 벗어나는 경우

L = 2인 경우에 경사로를 놓을 수 있는 경우를 그림으로 나타내면 아래와 같다.
[그림2-1]

경사로를 놓을 수 없는 경우는 아래와 같다.
[그림2-2]

위의 그림의 가장 왼쪽부터 1번, 2번, 3번, 4번 예제라고 했을 때, 1번은 높이 차이가 1이 아니라서, 
2번은 경사로를 바닥과 접하게 놓지 않아서, 3번은 겹쳐서 놓아서, 4번은 기울이게 놓아서 불가능한 경우이다.

가장 위에 주어진 그림 예의 경우에 지나갈 수 있는 길은 초록색으로, 
지나갈 수 없는 길은 빨간색으로 표시되어 있으며, 아래와 같다. 경사로의 길이 L = 2이다.
[그림2-3]

지도가 주어졌을 때, 지나갈 수 있는 길의 개수를 구하는 프로그램을 작성하시오.

입력
첫째 줄에 N (2 ≤ N ≤ 100)과 L (1 ≤ L ≤ N)이 주어진다. 둘째 줄부터 N개의 줄에 지도가 주어진다. 
각 칸의 높이는 10보다 작거나 같은 자연수이다.

출력
첫째 줄에 지나갈 수 있는 길의 개수를 출력한다.

*/

/*

◆ 풀이

주어진 조건에 따라 필요한 경우 경사로를 놓음으로써 지나갈 수 있는 길을 만드는 시뮬레이션 문제이다.

이 문제를 처음 접한 건 SWEA에서 였는데, 그때 당시 너무 오래걸렸던(거의 2시간) 문제라
다시 풀어야지 생각만 하고 풀지 않고 있었는데, 오늘에서야 풀게 되었다.. ㅎㅎ;;

그때는 문제를 제대로 이해하지 못한 상태에서 설계를 시작했기 때문에 빠뜨린 조건이 많았는데,
이번엔 그와 같은 실수를 반복하지 않기 위해 최대한 꼼꼼하게 문제를 이해하고, 설계를 진행했다!

가장 중요한 규칙 3가지는 다음과 같다.
- 경사로는 항상 낮은 칸에 놓으며, 그 낮은 칸의 높이가 L개 연속되어 있어야 한다.
- 낮은 칸과 높은 칸의 높이 차이는 2가 넘어가면 안된다.
- 경사로를 놓을 때, 겹치게 놓거나 범위가 넘어가게 놓으면 안된다.

그리고 코드의 전체적인 진행 과정은 다음과 같다.

1) 한 행(또는 열)을 보면서 높이 차이를 계산한다.

2) 높이 차이를 계산할 때, 차이가 나지 않으면 그 개수를 센다.
    이 개수는 이후 두 높이를 비교했을 때 오른쪽의 높이가 큰 경우 경사로를 놓을 수 있는지 판단할 수 있는 중요한 단서가 된다.

3) 왼쪽이 오른쪽보다 높이가 1 작은 경우, 누적된 개수를 보고 L 이상인지 확인한다.
    만약 L 이상이라면, 경사로를 놓을 수 있다는 뜻이므로 경사로를 놓는다.

4) 왼쪽이 오른쪽보다 높이가 1 큰 경우, 누적된 개수가 아닌 앞에 L개의 낮은 칸이 유지되는지 확인한다.
    만약 L개의 낮은 칸이 유지된다면, 경사로를 놓을 수 있다는 뜻이므로 경사로를 놓는다.
    또한, 경사로를 놓은 지점은 다시 볼 필요가 없으므로 탐색 위치를 경사로의 끝지점부터 시작하도록 설정한다.
    (만약 경사로의 끝지점이 아닌 그 이후의 지점으로 옮기게 된다면 그 끝지점에서 낮아지는 경우가 있을 때를 확인할 수 없다)

5) 만약 높이 차이가 2이상인 경우에는 해당 길은 지나갈 수 없게 된다.


◆ 후기

이전에 구현할 때는 높이 차이가 1이 나는 지점이 생기면 이미 지났던 지점의 L개의 블럭을 보거나,
그 지점 이후의 L개의 블럭을 보는 방식을 사용했는데, 그러다 보니 경사로를 놓았는지에 대한 배열이 따로 필요했었다.

하지만 이번에는 경사로를 놓을 수 있는 지점의 개수를 미리 세거나, 경사로를 놓은 지점은 넘어가도록 구현했더니 
그러한 배열이 따로 필요하지 않게 되어서 코드가 더 깔끔해지게 되었다.

그리고 사실 처음에는 행, 열에 대한 스캔 함수를 따로 만들지 않고 solution 함수에 다 집어 넣었는데,
그러다보니 중간에 끝냈는지를 판단하기 위한 flag라는 bool 변수가 별도로 필요하다는 단점이 있었다.

그래서 다 풀고 나서는 행, 열에 대한 스캔 함수를 따로 만들어 조건을 위배하는 경우 바로 false를 return하는 방식으로 만들었더니
flag 없이도 지나갈 수 있는 길인지에 대한 판단이 명확하게 가능해졌다.

자주 쓰이는 부분, 또는 flag가 쓰여야 할 부분은 함수로 정의하는게 좋은 코드로 가는 지름길이라고 생각한다!
귀찮더라도(?) 최적화하여 최대한 함수를 이용하는 방법을 지향하도록 하자 ㅎㅎㅎ^_^

*/

#include <iostream>

using namespace std;

const int MAX = 100 + 10;

int N, L;
int map[MAX][MAX];
int answer = 0;

bool rowScan(int y) {
    int cnt = 1;
    for (int j = 0; j < N - 1; j++) {
        if (map[y][j] == map[y][j + 1]) cnt++;
        else if (map[y][j] + 1 == map[y][j + 1]) { // (y, j)의 높이가 (y, j+1)보다 1 작은 경우
            if (cnt >= L) cnt = 1;
            else return false;
        }
        else if (map[y][j] == map[y][j + 1] + 1) { // (y, j)의 높이가 (y, j+1)보다 1 큰 경우
            if (j + L > N - 1) return false;

            for (int k = j + 1; k < j + L; k++) {
                if (map[y][k] != map[y][k + 1]) return false;
            }
            
            cnt = 0;
            j += L - 1;
        }
        else return false;
    }

    return true;
}

bool colScan(int x) {
    int cnt = 1;
    for (int j = 0; j < N - 1; j++) {
        if (map[j][x] == map[j + 1][x]) cnt++;
        else if (map[j][x] + 1 == map[j + 1][x]) { // (j, x)의 높이가 (j+1, x)보다 1 작은 경우
            if (cnt >= L) cnt = 1;
            else return false;
        }
        else if (map[j][x] == map[j + 1][x] + 1) { // (j, x)의 높이가 (j+1, x)보다 1 큰 경우
            if (j + L > N - 1) return false;

            for (int k = j + 1; k < j + L; k++) {
                if (map[k][x] != map[k + 1][x]) return false;
            }

            cnt = 0;
            j += L - 1;
        }
        else return false;
    }

    return true;
}

void solution() {
    // 한 행(또는 열)을 보면서 높이 차이를 계산한다.
    for (int i = 0; i < N; i++) {
        if (rowScan(i)) answer++;
        if (colScan(i)) answer++;
    }
}

int main() {
    ios_base::sync_with_stdio(0);
    cin.tie(0);

    cin >> N >> L;
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < N; j++) {
            cin >> map[i][j];
        }
    }

    solution();
    cout << answer;

    return 0;
}