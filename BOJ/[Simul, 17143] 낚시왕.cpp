// 실행시간: 58분
// 소요시간: 164ms

/*

시간 제한	메모리 제한	제출	정답	맞은 사람	정답 비율
1 초		512 MB		14951	3596	2069		22.067%

문제
낚시왕이 상어 낚시를 하는 곳은 크기가 R×C인 격자판으로 나타낼 수 있다. 격자판의 각 칸은 (r, c)로 나타낼 수 있다. 
r은 행, c는 열이고, (R, C)는 아래 그림에서 가장 오른쪽 아래에 있는 칸이다. 
칸에는 상어가 최대 한 마리 들어있을 수 있다. 상어는 크기와 속도를 가지고 있다.

[그림1]

낚시왕은 처음에 1번 열의 한 칸 왼쪽에 있다. 다음은 1초 동안 일어나는 일이며, 아래 적힌 순서대로 일어난다. 
낚시왕은 가장 오른쪽 열의 오른쪽 칸에 이동하면 이동을 멈춘다.
1. 낚시왕이 오른쪽으로 한 칸 이동한다.
2. 낚시왕이 있는 열에 있는 상어 중에서 땅과 제일 가까운 상어를 잡는다. 상어를 잡으면 격자판에서 잡은 상어가 사라진다.
3. 상어가 이동한다.

상어는 입력으로 주어진 속도로 이동하고, 속도의 단위는 칸/초이다. 
상어가 이동하려고 하는 칸이 격자판의 경계를 넘는 경우에는 방향을 반대로 바꿔서 속력을 유지한채로 이동한다.
왼쪽 그림의 상태에서 1초가 지나면 오른쪽 상태가 된다. 
상어가 보고 있는 방향이 속도의 방향, 왼쪽 아래에 적힌 정수는 속력이다. 왼쪽 위에 상어를 구분하기 위해 문자를 적었다.

[그림2]

상어가 이동을 마친 후에 한 칸에 상어가 두 마리 이상 있을 수 있다. 
이때는 크기가 가장 큰 상어가 나머지 상어를 모두 잡아먹는다.

낚시왕이 상어 낚시를 하는 격자판의 상태가 주어졌을 때, 낚시왕이 잡은 상어 크기의 합을 구해보자.

입력
첫째 줄에 격자판의 크기 R, C와 상어의 수 M이 주어진다. (2 ≤ R, C ≤ 100, 0 ≤ M ≤ R×C)
둘째 줄부터 M개의 줄에 상어의 정보가 주어진다. 
상어의 정보는 다섯 정수 r, c, s, d, z (1 ≤ r ≤ R, 1 ≤ c ≤ C, 0 ≤ s ≤ 1000, 1 ≤ d ≤ 4, 1 ≤ z ≤ 10000) 로 이루어져 있다. 
(r, c)는 상어의 위치, s는 속력, d는 이동 방향, z는 크기이다. 
d가 1인 경우는 위, 2인 경우는 아래, 3인 경우는 오른쪽, 4인 경우는 왼쪽을 의미한다.
두 상어가 같은 크기를 갖는 경우는 없고, 하나의 칸에 둘 이상의 상어가 있는 경우는 없다.

출력
낚시왕이 잡은 상어 크기의 합을 출력한다.

예제 입력 1 
4 6 8
4 1 3 3 8
1 3 5 2 9
2 4 8 4 1
4 5 0 1 4
3 3 1 2 7
1 5 8 4 3
3 6 2 1 2
2 2 2 3 5
예제 출력 1 
22

각 칸의 왼쪽 아래에 적힌 수는 속력, 오른쪽 아래는 크기, 왼쪽 위는 상어를 구분하기 위한 문자이다. 
오른쪽 위에 ❤️는 낚시왕이 잡은 물고기 표시이다.

[그림3, 초기상태, 1초]

[그림4, 2초, 3초]

[그림5, 4초, 5초, 6초]

예제 입력 2 
100 100 0
예제 출력 2 
0
예제 입력 3 
4 5 4
4 1 3 3 8
1 3 5 2 9
2 4 8 4 1
4 5 0 1 4
예제 출력 3 
22
예제 입력 4 
2 2 4
1 1 1 1 1
2 2 2 2 2
1 2 1 2 3
2 1 2 1 4
예제 출력 4 
4

*/

/*

예전에 SWEA 에서 문제 풀 때, 비슷한 문제를 푼 것 같아서 미루고 있었는데, 알고보니 조금 많이 변형된(?)듯한 문제였다.
생각보다 빠르게 풀리지 않아서 당황했고... 상어 이동이 또 잘 떠오르지 않아서 막막했던..!!! 그래도 풀어서 뿌듯하다 ㅎㅎ

여튼... 이 문제에서 인풋으로 맵의 크기와 상어의 위치, 속력, 방향, 크기가 주어진다.
상어의 위치에 해당하는 map에 상어를 저장해도 되지만, 나는 map에는 그냥 상어 인덱스만 저장하고,
상어들을 이동시킬 때는 별도의 벡터를 사용했다.
(상어가 계속 이동하는데, 아직 이동하지 않은 상어가 이동한 상어에게 영향을 주지 않도록 하는 방법이 생각이 안났당.)

또한, 여기서 속력은 최대 1000까지로 주어지는데, 사실 상어의 방향의 행 또는 열에서 2를 곱한 값 - 2만큼은
상어가 제자리로 돌아오는 한 사이클로 생각해도 되므로, 처음부터 속력을 크게 설정하지 않고
저 값을 나머지 연산자 %를 사용해서 남는 나머지를 속력으로 집어 넣어줬다. ㅎㅎ

그리고 열을 한 칸씩 이동시키면서 맵을 보게 되는데, 낚시왕에게 가장 가까운 상어가 발견되면
그 즉시 맵을 -1(초기화가 -1이다)로 바꿔주고, 상어의 방향을 0으로 설정해줬다.
(상어가 맵에서 사라졌을 때는 방향을 d으로 바꿔주도록 구현했기 때문!!)

그 이후에는 대망의 상어가 이동할 시간인데....
아까 말했듯이 나는 상어를 별도의 벡터에 저장했기 때문에 반복문을 상어의 개수만큼 돌렸다.
그리고 방향이 0인 것은 넘어가고, 1이상부터만 상어를 이동시키도록 했다!

상어는 자신의 속력만큼의 칸을 이동할 수 있다. 따라서 나는 그 칸이 0이 될 때까지 감소시키면서
상어의 위치를 업데이트 시켜주는 방식을 사용했다.

상어가 벽에 닿기 이전까지는 방향이 변하지 않으나, 벽에 닿게 되면 방향이 변하므로
상어의 위치를 계속 보면서 범위를 벗어나는지, 벗어나지 않는지 확인했고,
벗어나는 경우에는 위치를 제대로 돌려주고, 방향도 바꿔주었다.

또한, 한 맵에는 여러 마리의 상어가 도착할 수 있는데,
맵에는 움직이지 않은 상어도 있고, 움직인 상어도 있으므로 나는 이를 구분하기 위해
항상 상어를 이동시키기 전에 맵을 -1로 다시 초기화를 해주었다.
그러므로 맵에 -1이 들어있다면, 아무도 오지 않았다는 의미가 되고, 다른 수가 들어있다면
움직인 상어가 해당 맵에 있다는 소리이므로 더 큰 상어만 남겨두면 되는 것이다.

그리고 이 다음에도 열을 이동시키며 낚시왕이 가장 가까이에 있는 상어를 계속해서 잡아나가면 된다.

상어를 이동시킬 때 한칸씩 이동시키는 게 아니라, 한번에 이동시키고 싶었는데,
순간 뇌가 정지되어서... 그냥 바로 생각나는 방법으로 구현했다.
그 때문에 실행시간이 조금 길게 나온 것 같기는 하지만, 왠지 그 방법으로 도전했더라면 머리가 하얘질 것 같았다..ㅋㅋㅋ

다음에 다시 풀 때는 그 방법도 고려해서 풀어봐야겠당.!

*/

#include <iostream>
#include <vector>

using namespace std;

const int MAX = 100 + 10;

int R, C, M;
int map[MAX][MAX];
int ans = 0;

struct SHARK{
    int r, c, s, d, z;
};

vector<SHARK> S;

int dy[5] = { 0, -1, 1, 0, 0 };
int dx[5] = { 0, 0, 0, 1, -1 };

int changeDir(int d) {
    if (d == 1) return 2;
    else if (d == 2) return 1;
    else if (d == 3) return 4;
    else return 3;
}

void moveShark() {
    for (int i = 0; i < S.size(); i++) {
        if (S[i].d == 0) continue;

        int s = S[i].s;

        while (s--) {
            S[i].r += dy[S[i].d];
            S[i].c += dx[S[i].d];

            if (S[i].r >= 1 && S[i].r <= R && S[i].c >= 1 && S[i].c <= C) continue;

            if (S[i].r < 1) S[i].r = 2;
            else if (S[i].r > R) S[i].r = R - 1;
            else if (S[i].c < 1) S[i].c = 2;
            else S[i].c = C - 1;

            S[i].d = changeDir(S[i].d);
        }
        
        int idx = map[S[i].r][S[i].c];
        if (idx == -1) {
            map[S[i].r][S[i].c] = i;
        }
        else {
            if (S[i].z > S[idx].z) {
                S[idx].d = 0;
                map[S[i].r][S[i].c] = i;
            }
            else S[i].d = 0;
        }
    }
}

void initializeMap() {
    for (int i = 0; i < S.size(); i++) {
        if (!S[i].d) continue;

        map[S[i].r][S[i].c] = -1;
    }
}

int main() {
    ios_base::sync_with_stdio(0);
    cin.tie(0);

    cin >> R >> C >> M;
    
    for (int i = 1; i <= R; i++) {
        for (int j = 1; j <= C; j++) {
            map[i][j] = -1;
        }
    }
    
    for (int i = 0; i < M; i++) {
        int r, c, s, d, z;
        cin >> r >> c >> s >> d >> z;

        if (d == 1 || d == 2) s = s % (R * 2 - 2);
        else s = s % (C * 2 - 2);

        S.push_back({ r, c, s, d, z });
        map[r][c] = i;
    }

    for (int i = 1; i <= C; i++) {
        for (int j = 1; j <= R; j++) {
            if (map[j][i] == -1) continue;

            ans += S[map[j][i]].z;
            S[map[j][i]].d = 0;
            map[j][i] = -1;

            break;
        }

        initializeMap();
        moveShark();
    }

    cout << ans;

    return 0;
}