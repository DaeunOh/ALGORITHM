// 소요시간: 49분
// 실행시간: 0ms

/*

시간 제한			메모리 제한	제출	정답	맞은 사람	정답 비율
0.5 초 (추가 시간 없음)	512 MB		5762	2590	1694	43.258%

문제
크기가 3×3인 배열 A가 있다. 1초가 지날때마다 배열에 연산이 적용된다.

R 연산: 배열 A의 모든 행에 대해서 정렬을 수행한다. 행의 개수 ≥ 열의 개수인 경우에 적용된다.
C 연산: 배열 A의 모든 열에 대해서 정렬을 수행한다. 행의 개수 < 열의 개수인 경우에 적용된다.
한 행 또는 열에 있는 수를 정렬하려면, 각각의 수가 몇 번 나왔는지 알아야 한다. 
그 다음, 수의 등장 횟수가 커지는 순으로, 그러한 것이 여러가지면 수가 커지는 순으로 정렬한다. 
그 다음에는 배열 A에 정렬된 결과를 다시 넣어야 한다. 
정렬된 결과를 배열에 넣을 때는, 수와 등장 횟수를 모두 넣으며, 순서는 수가 먼저이다.

예를 들어, [3, 1, 1]에는 3이 1번, 1가 2번 등장한다. 따라서, 정렬된 결과는 [3, 1, 1, 2]가 된다. 
다시 이 배열에는 3이 1번, 1이 2번, 2가 1번 등장한다. 다시 정렬하면 [2, 1, 3, 1, 1, 2]가 된다.

정렬된 결과를 배열에 다시 넣으면 행 또는 열의 크기가 달라질 수 있다. 
R 연산이 적용된 경우에는 가장 큰 행을 기준으로 모든 행의 크기가 변하고, 
C 연산이 적용된 경우에는 가장 큰 열을 기준으로 모든 열의 크기가 변한다. 
행 또는 열의 크기가 커진 곳에는 0이 채워진다. 수를 정렬할 때 0은 무시해야 한다. 
예를 들어, [3, 2, 0, 0]을 정렬한 결과는 [3, 2]를 정렬한 결과와 같다.

행 또는 열의 크기가 100을 넘어가는 경우에는 처음 100개를 제외한 나머지는 버린다.
배열 A에 들어있는 수와 r, c, k가 주어졌을 때, A[r][c]에 들어있는 값이 k가 되기 위한 최소 시간을 구해보자.

입력
첫째 줄에 r, c, k가 주어진다. (1 ≤ r, c, k ≤ 100)
둘째 줄부터 3개의 줄에 배열 A에 들어있는 수가 주어진다. 배열 A에 들어있는 수는 100보다 작거나 같은 자연수이다.

출력
A[r][c]에 들어있는 값이 k가 되기 위한 연산의 최소 시간을 출력한다. 이 값이 100을 넘어가는 경우에는 -1을 출력한다.

예제 입력 1 
1 2 2
1 2 1
2 1 3
3 3 3
예제 출력 1 
0

예제 입력 2 
1 2 1
1 2 1
2 1 3
3 3 3
예제 출력 2 
1

예제 입력 3 
1 2 3
1 2 1
2 1 3
3 3 3
예제 출력 3 
2

예제 입력 4 
1 2 4
1 2 1
2 1 3
3 3 3
예제 출력 4 
52

예제 입력 5 
1 2 5
1 2 1
2 1 3
3 3 3
예제 출력 5 
-1

예제 입력 6 
3 3 3
1 1 1
1 1 1
1 1 1
예제 출력 6 
2

힌트
배열 A의 초기값이 아래와 같은 경우를 생각해보자.
1 2 1
2 1 3
3 3 3
가장 처음에는 행의 개수 ≥ 열의 개수 이기 때문에, R 연산이 적용된다. 
편의상 정렬 중간 단계는 (수, 수의 등장 횟수)로 표현한다.

1 2 1 → (2, 1), (1, 2)         → 2 1 1 2
2 1 3 → (1, 1), (2, 1), (3, 1) → 1 1 2 1 3 1
3 3 3 → (3, 3)                 → 3 3

크기가 가장 큰 행은 2번 행이고, 나머지 행의 뒤에 0을 붙여야 한다.

2 1 1 2 0 0
1 1 2 1 3 1
3 3 0 0 0 0

다음에 적용되는 연산은 행의 개수 < 열의 개수이기 때문에 C 연산이다. 

1 3 1 1 3 1
1 1 1 1 1 1
2 1 2 2 0 0
1 2 1 1 0 0
3 0 0 0 0 0
1 0 0 0 0 0

연산이 적용된 결과는 위와 같다.

*/

/*

행과 열의 개수에 따라 특별한 행 정렬 또는 열 정렬을 하는 시뮬레이션 문제.
예전에 거의 비슷한 문제를 학원에서 푼 경험이 있는데, 그때는 문제를 풀지 못하고 끝났었다..ㅎㅎ;;;
그래서 이번에는 설계를 조금 더 꼼꼼하게 하려고 노력했더니 다행히도 문제를 해결할 수 있었다!!!

이 문제를 해결하기 위해서는 실행해야 할 단계는 다음과 같다.
1) 모든 행(열)을 보며 나타나는 각각의 수를 카운트한다.
    카운트와 동시에 해당 요소를 0으로 초기화해준다.
2) 등장 횟수가 0이 아닌 수를 등장 횟수와 함께 벡터에 넣어주고, 오름차순으로 정렬한다.
    만약 등장 횟수가 같다면 해당 수를 오름차순으로 정렬한다.
3) 수, 등장횟수 순서로 A 배열에 집어넣는다.

오름차순으로 정렬하는 비교함수만 잘 정의해주고, 초기화도 잘 해준다면 구현 자체는 까다롭지 않은 문제같다!

*/

#define _CRT_SECURE_NO_WARNINGS

#include <cstdio>
#include <vector>
#include <algorithm>
#include <cstring>

using namespace std;

const int MAX = 100 + 10;

int r, c, k;
int A[MAX][MAX];
int R, C;

int num[MAX];
vector<pair<int, int>> v;

bool comp(pair<int, int> a, pair<int, int> b) {
    if (a.second == b.second) return a.first < b.first;
    else return a.second < b.second;
}

void rowSort() {
    int maxC = -1;
    // 모든 행에 대해 정렬을 수행한다.
    for (int i = 1; i <= R; i++) {
        v.clear();

        // 해당 행을 보며 나타나는 수를 카운트한다.
        for (int j = 1; j <= C; j++) {
            num[A[i][j]]++;
            A[i][j] = 0;
        }
        
        // 등장 횟수가 0이 아닌 수를 등장 횟수와 함께 벡터에 넣어준다.
        for (int j = 1; j <= 100; j++) {
            if (num[j] != 0) {
                v.push_back(make_pair(j, num[j]));
                num[j] = 0;
            }
        }

        // 등장 횟수를 오름차순으로 정렬한다. 만약 등장 횟수가 같다면 수를 오름차순으로 정렬한다.
        sort(v.begin(), v.end(), comp);

        int vSize = v.size() > 50 ? 50 : v.size();
        if (maxC < vSize * 2) maxC = vSize * 2;

        int idx = 1;
        for (int j = 0; j < vSize; j++) {
            A[i][idx] = v[j].first;
            A[i][idx + 1] = v[j].second;
            idx += 2;
        }
    }

    C = maxC;
}

void colSort() {
    int maxR = -1;
    // 모든 열에 대해 정렬을 수행한다.
    for (int i = 1; i <= C; i++) {
        v.clear();

        // 해당 열을 보며 나타나는 수를 카운트한다.
        for (int j = 1; j <= R; j++) {
            num[A[j][i]]++;
            A[j][i] = 0;
        }

        // 등장 횟수가 0이 아닌 수를 등장 횟수와 함께 벡터에 넣어준다.
        for (int j = 1; j <= 100; j++) {
            if (num[j] != 0) {
                v.push_back(make_pair(j, num[j]));
                num[j] = 0;
            }
        }

        // 등장 횟수를 오름차순으로 정렬한다. 만약 등장 횟수가 같다면 수를 오름차순으로 정렬한다.
        sort(v.begin(), v.end(), comp);

        int vSize = v.size() > 50 ? 50 : v.size();
        if (maxR < vSize * 2) maxR = vSize * 2;

        int idx = 1;
        for (int j = 0; j < vSize; j++) {
            A[idx][i] = v[j].first;
            A[idx + 1][i] = v[j].second;
            idx += 2;
        }
    }

    R = maxR;
}

int main() {
    R = 3, C = 3;
    memset(A, 0, sizeof(A));

    scanf("%d %d %d", &r, &c, &k);
    for (int i = 1; i <= R; i++) {
        for (int j = 1; j <= C; j++) {
            scanf("%d", &A[i][j]);
        }
    }

    int t = 0;
    while (1) {
        if (t > 100) break;

        if (A[r][c] == k) {
            printf("%d\n", t);
            return 0;
        }

        if (R >= C) rowSort();
        else colSort();

        t++;
    }

    printf("-1\n");

    return 0;
}