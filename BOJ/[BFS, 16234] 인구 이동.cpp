/*

시간 제한	메모리 제한	제출	정답	맞은 사람	정답 비율
2 초		512 MB		17113	6859	3832		35.971%

문제
N×N크기의 땅이 있고, 땅은 1×1개의 칸으로 나누어져 있다. 
각각의 땅에는 나라가 하나씩 존재하며, r행 c열에 있는 나라에는 A[r][c]명이 살고 있다. 
인접한 나라 사이에는 국경선이 존재한다. 모든 나라는 1×1 크기이기 때문에, 모든 국경선은 정사각형 형태이다.

오늘부터 인구 이동이 시작되는 날이다.
인구 이동은 다음과 같이 진행되고, 더 이상 아래 방법에 의해 인구 이동이 없을 때까지 지속된다.
- 국경선을 공유하는 두 나라의 인구 차이가 L명 이상, R명 이하라면, 두 나라가 공유하는 국경선을 오늘 하루동안 연다.
- 위의 조건에 의해 열어야하는 국경선이 모두 열렸다면, 인구 이동을 시작한다.
- 국경선이 열려있어 인접한 칸만을 이용해 이동할 수 있으면, 그 나라를 오늘 하루 동안은 연합이라고 한다.
- 연합을 이루고 있는 각 칸의 인구수는 (연합의 인구수) / (연합을 이루고 있는 칸의 개수)가 된다. 편의상 소수점은 버린다.
- 연합을 해체하고, 모든 국경선을 닫는다.

각 나라의 인구수가 주어졌을 때, 인구 이동이 몇 번 발생하는지 구하는 프로그램을 작성하시오.

입력
첫째 줄에 N, L, R이 주어진다. (1 ≤ N ≤ 50, 1 ≤ L ≤ R ≤ 100)
둘째 줄부터 N개의 줄에 각 나라의 인구수가 주어진다. r행 c열에 주어지는 정수는 A[r][c]의 값이다. (0 ≤ A[r][c] ≤ 100)
인구 이동이 발생하는 횟수가 2,000번 보다 작거나 같은 입력만 주어진다.

출력
인구 이동이 몇 번 발생하는지 첫째 줄에 출력한다.

예제 입력 1 
2 20 50
50 30
20 40
예제 출력 1 
1

초기 상태는 아래와 같다.
[그림1-1]

L = 20, R = 50 이기 때문에, 모든 나라 사이의 국경선이 열린다. (열린 국경선은 점선으로 표시)
[그림1-2]

연합은 하나 존재하고, 연합의 인구는 (50 + 30 + 20 + 40) 이다. 연합의 크기가 4이기 때문에, 
각 칸의 인구수는 140/4 = 35명이 되어야 한다. 
[그림1-3]

예제 입력 2 
2 40 50
50 30
20 40
예제 출력 2 
0

경계를 공유하는 나라의 인구 차이가 모두 L보다 작아서 인구 이동이 발생하지 않는다.

예제 입력 3 
2 20 50
50 30
30 40
예제 출력 3 
1

초기 상태는 아래와 같다.
[그림2-1]

L = 20, R = 50이기 때문에, 아래와 같이 국경선이 열린다.
[그림2-2]

인구 수는 합쳐져있는 연합의 인구수는 (50+30+30) / 3 = 36 (소수점 버림)이 되어야 한다.
[그림2-3]

예제 입력 4 
3 5 10
10 15 20
20 30 25
40 22 10
예제 출력 4 
2
예제 입력 5 
4 10 50
10 100 20 90
80 100 60 70
70 20 30 40
50 20 100 10
예제 출력 5 
3

*/

/*

방문하지 않은 지점을 기준으로 BFS를 시작하면서,
인접해 있는 나라의 인구 차이가 L이상 R이하인 경우를 찾아 주어진 식대로 인구 이동을 하면 되는 문제.

문제에선 열어야 하는 국경선이 모두 열렸다면, 인구 이동을 시작하라고 했지만,
사실 visited 배열을 사용하기 때문에 한 지점을 기준으로 인구 이동이 가능하다면, 인구 이동을 바로 해버려도 무방하다.
(처음에는 이를 생각하지 못하고 라벨링을 따로 해야하나 싶었다 ㅎㅎ;;;)

하지만 이와 다르게 "인구 이동의 횟수"를 세는 것은 한 번에 두 번의 인구 이동이 일어 나더라도
"1번"으로 간주 해야 하기 때문에 이 점을 유의해야 한다...(유의하지 못했다...ㅋㅋ)

나머지의 경우는 일반적인 BFS 문제와 거의 유사하니 코드를 따라가면 금방 이해가 가능할 것이다 ㅎㅎ
(아 그리고 여기서 사용한 flag는 인구 이동이 일어나지 않았으면 인구 이동을 중단해야 하기 때문에 넣어준 bool 변수이다!)

요즘 BFS 문제를 많이 안 풀어서 코테에 나왔을 때 솔직히 조금 당황했는데..
그때 한번 풀고, 오늘 다시 풀었더니 감이 다시 좀 살아나기 시작한 것 같다..
역시 알고리즘은 감을 잃으면 안돼 ㅠㅠㅠㅠㅠㅠㅠㅠㅠ 꾸준하게 하는 것이 가장 중요!!

*/

#include <iostream>
#include <queue>
#include <cstring>
#include <vector>

using namespace std;

const int MAX = 50 + 10;

int N, L, R;
int A[MAX][MAX];
bool visited[MAX][MAX];
int cnt = 0;

int dy[4] = { -1, 1, 0, 0 };
int dx[4] = { 0, 0, -1, 1 };

int getAbs(int x) {
    if (x > 0) return x;
    else return -x;
}

bool BFS(int y, int x) {
    queue<pair<int, int>> q;
    vector<pair<int, int>> v; // 연합이 될 나라의 좌표를 담은 벡터
    int sum = A[y][x];

    visited[y][x] = true;
    q.push(make_pair(y, x));
    v.push_back(make_pair(y, x));

    while (!q.empty()) {
        pair<int, int> front = q.front();
        q.pop();

        for (int i = 0; i < 4; i++) {
            int ny = front.first + dy[i];
            int nx = front.second + dx[i];

            if (ny < 0 || ny > N - 1 || nx < 0 || nx > N - 1 || visited[ny][nx]) continue;

            int diff = getAbs(A[front.first][front.second] - A[ny][nx]);
            if (L <= diff && diff <= R) { // 인구 차이가 L 이상 R 이하인 나라
                visited[ny][nx] = true;
                q.push(make_pair(ny, nx));
                v.push_back(make_pair(ny, nx));
                sum += A[ny][nx];
            }
        }
    }

    if (v.size() > 1) { // 연합이 만들어진 경우
        sum /= v.size();
        for (int i = 0; i < v.size(); i++) A[v[i].first][v[i].second] = sum;
        return true;
    }
    
    return false;
}

int main() {
    ios_base::sync_with_stdio(0);
    cin.tie(0);

    cin >> N >> L >> R;
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < N; j++) {
            cin >> A[i][j];
        }
    }

    while (1) {
        bool flag = false;
        memset(visited, 0, sizeof(visited));

        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {
                if (!visited[i][j]) {
                    if (BFS(i, j)) flag = true; // 인구 이동이 한 번이라도 있었다면
                }
            }
        }

        if (flag) cnt++;
        else break;
    }

    cout << cnt;

    return 0;
}