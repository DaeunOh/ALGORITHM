// 소요시간: 13분
// 실행시간: 96ms

/*

시간 제한	메모리 제한	제출	정답	맞은 사람	정답 비율
2 초	192 MB		33677		8094	5006		22.747%

문제
N×M의 행렬로 표현되는 맵이 있다. 맵에서 0은 이동할 수 있는 곳을 나타내고, 1은 이동할 수 없는 벽이 있는 곳을 나타낸다. 
당신은 (1, 1)에서 (N, M)의 위치까지 이동하려 하는데, 이때 최단 경로로 이동하려 한다. 
최단경로는 맵에서 가장 적은 개수의 칸을 지나는 경로를 말하는데, 이때 시작하는 칸과 끝나는 칸도 포함해서 센다.

만약에 이동하는 도중에 한 개의 벽을 부수고 이동하는 것이 좀 더 경로가 짧아진다면, 벽을 한 개 까지 부수고 이동하여도 된다.

맵이 주어졌을 때, 최단 경로를 구해 내는 프로그램을 작성하시오.

입력
첫째 줄에 N(1 ≤ N ≤ 1,000), M(1 ≤ M ≤ 1,000)이 주어진다. 
다음 N개의 줄에 M개의 숫자로 맵이 주어진다. (1, 1)과 (N, M)은 항상 0이라고 가정하자.

출력
첫째 줄에 최단 거리를 출력한다. 불가능할 때는 -1을 출력한다.

*/

/*

◆ 풀이

(1, 1)에서 (N, M)의 위치까지 최단 경로로 이동하도록 해야하지만,
이동하는 도중에 최대 한 개의 벽까지는 부술 수 있다는 점을 고려하여 해결해야 하는 BFS 문제이다.

기본적으로 맵에서 0인 부분만 이동할 수 있다는 점은 다른 BFS 문제와 거의 동일하나,
맵에서 1인 부분을 최대 1번 0으로 간주할 수 있다는 점에서는 조금 다르다.

이를 해결하기 위해 여러 방법이 있을 수 있겠지만,
나는 (1, 1)부터 시작하는 BFS와 (N, M)부터 시작하는 BFS를 이용하여 각자 visited 배열에 그 위치까지의 거리를 기록했다.

0인 부분은 언제나 이동할 수 있으므로 0인 위치에 도달하면 방문 처리와 함께 큐에 넣어주었지만,
1인 부분은 최대 한 번만 부술 수 있으므로 큐에 넣어주진 않고 방문 처리만 하도록 했다.

이 방식을 활용하여 BFS를 (1, 1)부터, (N, M)부터 돌리면,
각 visited 배열에는 서로 다른 출발 위치에서 다른 지점으로의 최단 거리가 찍힐 것이고,
최종적으로는 visited 배열의 요소가 둘 다 0이 아닌 지점에 대해 서로 더한 값 - 1이 최단거리의 후보가 된다.
(하나라도 0인 지점이 있다면 (1, 1)과 (N, M) 중 적어도 한 개는 해당 지점에 도달하지 못한다는 뜻이므로 후보가 될 수 없다.)

그리고 최단거리의 후보들 중 가장 짧은 거리가 이 문제에서 구하는 답이 될 수 있다.


◆ 후기

"벽을 최대 1번 부술 수 있다"는 점을 어떻게 활용하느냐에 따라 많은 코딩 스타일이 있을 수 있는 문제이다.

벽을 여러 번 부술 수 있다면, 몇 번 부술 수 있는지에 해당하는 생명력(?)이 별도로 필요하겠지만,
어차피 최대 1번만 부술 수 있고, 결국 (1, 1)에서 (N, M)까지 가는 최단 경로만 구하면 되는 것이므로,
나는 (1, 1)과 (N, M)에서 각각 출발하여 한 지점으로 모아지는 곳을 최단 경로의 후보로 선택했다.

(1, 1)에서 (N, M)까지 도달하는 것이 불가능 하다면, 적어도 둘 중 하나는 중간에 길이 막혀있다는 의미이므로
이를 활용하여 어느 하나라도 해당 지점에 방문을 못했다면 바로 넘어가버리는 방식을 사용했다.

SWEA에서 문제를 풀 때, 산을 K만큼 깎을 수도 있는 문제가 존재했었는데,
그 문제에 사용했던 방식을 활용하여 큐에 삽입할 때 생명력에 해당하는 수도 함께 삽입하여(또는 플래그를 사용하여) 구현해도
정답을 구하는 데에는 지장이 없을 것 같다는 생각이 든다.

나중에 비슷한 문제를 만나게 된다면, 그땐 그 방식으로 풀어봐야겠다.

아 그리고!!! 이 문제에서는 맵이 띄어쓰기로 구분되어 있지 않기 때문에
cin, cout을 사용하는 것보다 scanf printf를 사용하는 것이 좋다. (%1d를 사용할 수 있기 때문 ㅎㅎ)

*/

#include <cstdio>
#include <queue>

using namespace std;

const int MAX = 1000 + 10;

int N, M;
int map[MAX][MAX];

int visitedS[MAX][MAX] = { 0, };
int visitedE[MAX][MAX] = { 0, };

int dy[4] = { -1, 1, 0, 0 };
int dx[4] = { 0, 0, -1, 1 };

void BFS(int y, int x, int visited[MAX][MAX]) {
    queue<pair<int, int>> q;
    visited[y][x] = 1;
    q.push(make_pair(y, x));

    while (!q.empty()) {
        pair<int, int> front = q.front();
        q.pop();

        for (int i = 0; i < 4; i++) {
            int ny = front.first + dy[i];
            int nx = front.second + dx[i];

            if (ny < 1 || ny > N || nx < 1 || nx > M) continue;

            if (!visited[ny][nx]) { // 벽인 지점은 거리만 갱신하고, 벽이 아닌 지점은 거리 갱신 후 큐에 넣는다.
                visited[ny][nx] = visited[front.first][front.second] + 1;
                if (!map[ny][nx]) q.push(make_pair(ny, nx));
            }
        }
    }
}

int main() {
    scanf("%d %d", &N, &M);

    for (int i = 1; i <= N; i++) {
        for (int j = 1; j <= M; j++) {
            scanf("%1d", &map[i][j]);
        }
    }

    BFS(1, 1, visitedS); // (1, 1)부터 시작하는 BFS
    BFS(N, M, visitedE); // (N, M)부터 시작하는 BFS

    int answer = 987987987;
    for (int i = 1; i <= N; i++) {
        for (int j = 1; j <= M; j++) {
            if (!visitedS[i][j] || !visitedE[i][j]) continue; // 둘 다 (i, j)에 도착하지 못하는 경우

            int dist = visitedS[i][j] + visitedE[i][j] - 1;
            if (answer > dist) answer = dist;
        }
    }

    if (answer == 987987987) printf("-1");
    else printf("%d", answer);

    return 0;
}
