// 소요시간: 1시간 43분
// 실행시간: 1192ms

/*

시간 제한	메모리 제한	제출	정답	맞은 사람	정답 비율
6 초		256 MB	21440	5496	3359		22.530%

문제
네 개의 명령어 D, S, L, R 을 이용하는 간단한 계산기가 있다. 
이 계산기에는 레지스터가 하나 있는데, 이 레지스터에는 0 이상 10,000 미만의 십진수를 저장할 수 있다. 
각 명령어는 이 레지스터에 저장된 n을 다음과 같이 변환한다. 
n의 네 자릿수를 d1, d2, d3, d4라고 하자(즉 n = ((d1 × 10 + d2) × 10 + d3) × 10 + d4라고 하자)

1. D: D 는 n을 두 배로 바꾼다. 결과 값이 9999 보다 큰 경우에는 10000 으로 나눈 나머지를 취한다. 
       그 결과 값(2n mod 10000)을 레지스터에 저장한다.
2. S: S 는 n에서 1 을 뺀 결과 n-1을 레지스터에 저장한다. n이 0 이라면 9999 가 대신 레지스터에 저장된다.
3. L: L 은 n의 각 자릿수를 왼편으로 회전시켜 그 결과를 레지스터에 저장한다. 
       이 연산이 끝나면 레지스터에 저장된 네 자릿수는 왼편부터 d2, d3, d4, d1이 된다.
4. R: R 은 n의 각 자릿수를 오른편으로 회전시켜 그 결과를 레지스터에 저장한다. 
       이 연산이 끝나면 레지스터에 저장된 네 자릿수는 왼편부터 d4, d1, d2, d3이 된다.

위에서 언급한 것처럼, L 과 R 명령어는 십진 자릿수를 가정하고 연산을 수행한다. 
예를 들어서 n = 1234 라면 여기에 L 을 적용하면 2341 이 되고 R 을 적용하면 4123 이 된다.

여러분이 작성할 프로그램은 주어진 서로 다른 두 정수 A와 B(A ≠ B)에 대하여 
A를 B로 바꾸는 최소한의 명령어를 생성하는 프로그램이다. 
예를 들어서 A = 1234, B = 3412 라면 다음과 같이 두 개의 명령어를 적용하면 A를 B로 변환할 수 있다.

1234 →L 2341 →L 3412
1234 →R 4123 →R 3412

따라서 여러분의 프로그램은 이 경우에 LL 이나 RR 을 출력해야 한다.

n의 자릿수로 0 이 포함된 경우에 주의해야 한다. 예를 들어서 1000 에 L 을 적용하면 0001 이 되므로 결과는 1 이 된다. 
그러나 R 을 적용하면 0100 이 되므로 결과는 100 이 된다.

입력
프로그램 입력은 T 개의 테스트 케이스로 구성된다. 테스트 케이스 개수 T 는 입력의 첫 줄에 주어진다. 
각 테스트 케이스로는 두 개의 정수 A와 B(A ≠ B)가 공백으로 분리되어 차례로 주어지는데 
A는 레지스터의 초기 값을 나타내고 B는 최종 값을 나타낸다. A 와 B는 모두 0 이상 10,000 미만이다.

출력
A에서 B로 변환하기 위해 필요한 최소한의 명령어 나열을 출력한다.

*/

/*

◆ 풀이

정수 A에서 BFS를 통해 여러 명령어를 거치고, 최종적으로는 정수 B가 되도록 만들어 주는 명령어 set을 구하는 BFS 문제.

일반적인 BFS 문제와 달리 D, S, L, R의 명령어가 존재하기에 명령어에 따른 프로세스들을 별도로 거쳐야 한다.
하지만 구해진 수가 방문되지 않은 수라면 방문 처리를 하고, 큐에 넣는 행위는 다른 문제와 동일하다.

나는 이 문제를 풀면서 정말 여러가지 실수로 인해 많은 실패를 거치게 되었다.

1) 시간 초과 & 메모리 초과
   1-1) 명백히 시간 초과는 아니지만 시간이 매우 많이 걸렸던 경우 (3948ms)
   최종적으로 구해야 하는 답이 A에서 B로 가기위해 사용한 명령어들인데,
   나는 이를 구하기 위해 명령어들을 계속해서 이은 string을 자신의 수와 함께 가지고 있도록 구현했다.
   
   하지만 이 명령어는 크게 잡아 최대 10000까지 길이가 늘어날 수 있으므로,
   이렇게 긴 길이의 명령어를 계속해서 큐에 넣는 행위는 시간 초과의 원인이 될 수 있다.

   따라서 큐에 현재 상태를 계속 누적시키는 것보다
   visited 배열에 자신이 어디서 왔는지에 대한 인덱스를 넣고, 
   그 인덱스에 따라 명령어를 얻어내는 것이 시간 절약에 도움이 된다.

   1-2) 시간 초과 & 메모리 초과
   마지막 결과를 출력하기 위해 무한루프를 사용했는데, 무한루프를 빠져나가는 조건은 next가 A가 되는 시점이다.

   하지만 나는 습관적으로 visited 배열을 초기에 0으로 초기화 하고 방문을 확인할 때 0인지 아닌지로 판별하도록 했는데,
   이는 A가 0으로 시작했을 때 다른 인덱스에 어디서 왔는지에 대한 정보로 0이라는 값이 들어가기 때문에
   실제로는 0으로 인덱싱했지만, 방문을 하지 않은 것으로 간주될 수 있어 무한루프를 빠져나가지 못하는 경우가 있었다.

   마지막에 결과를 출력하는 시점에서 string을 사용하면 string에 문자가 계속 추가되기만 하므로 시간 초과가 발생하고,
   vector를 사용하면 vector에 계속 숫자를 추가하게 되므로 메모리 초과가 발생한다.

   그래서 visited 배열을 초기에 -1로 초기화를 하고 방문을 확인할 때는 -1인지 아닌지로 판별했고,
   이를 통해 시간 초과 및 메모리 초과 이슈를 해결할 수 있었다.

2) 런타임 에러
   문제에서 주어진 조건을 잘못 읽어서 생긴 이슈였다.
   이 문제에서는 명령어 S에 대해 n-1을 저장하지만, n이 0이라면 9999를 저장하도록 했다.

   하지만 나는 n이 아닌 n-1이 0이라면 9999를 저장하도록 구현했기에, n이 0인 경우에 -2를 참조하는 경우가 생겨
   배열을 벗어나는 문제가 발생했기에 런타임 에러가 떴던 것이다.
   문제에서 주어진 조건을 임의로 수정하지 말도록 하자...ㅎㅎㅎ;;!
   

◆ 후기

주어진 명령어에 맞춰 잘 구현하고, BFS만 잘 사용하면 금방 해결될 줄 알았는데
생각보다 많은 오류를 접하고, 그를 해결하느라 시간이 오래걸렸던 문제이다.

일단 L과 R을 구현하는데 있어, 자리를 바꾸는 데에는 문자열이 필요할 것이라 생각했는데,
사실 항상 수는 최대 4자리로 고정되어 있기 때문에 %와 /연산자를 잘 사용하면 문자열로 구현하지 않아도 답을 쉽게 구할 수 있었다.

또한, 오래 전에 겪었던 visited 초기화 이슈도 오랜만에 접하다 보니, 저기에서 오류가 날 것이란 건 정말 상상도 하지 못했다..
예전에는 이런 경우를 많이 겪어서 꼭 꼭 확인하는 습관을 들이고자 했었는데,
최근엔 잘 겪지 않다보니 조금 무뎌져서 그런 것 같다.

모든지 익숙해지는게 가장 문제인 것 같다 ㅎㅎ핳하하하..
초기화 이슈는 어느 문제든 시간초과가 나면 한 번 짚고 넘어가도록 하자!
그리고 문제도 항상 꼼꼼하게 읽기!

*/

#include <iostream>
#include <queue>
#include <string>

using namespace std;

const int MAX = 10000 + 10;

int T;
int A, B;

int visited[MAX];
char dslr[MAX];

char flag[4] = {'D', 'S', 'L', 'R' };

void BFS() {
    queue<int> q;
    visited[A] = -1;
    q.push(A);

    while (!q.empty()) {
        int front = q.front();
        q.pop();

        if (front == B) {
            string res = "";
            int next = front;
            while (1) {
                res = dslr[next] + res;
                next = visited[next];

                if (next == A) break;
            }

            cout << res << "\n";

            return;
        }

        // D: n를 2배로 바꿔준다. 결과가 9999보다 크면 10000으로 나눈 나머지를 취한다.
        // S: n-1을 저장한다. n가 0이라면 9999를 저장한다.
        // L: n의 각 자릿수를 왼편 회전한다.
        // R: n의 각 자릿수를 오른편 회전한다.
        int DSLR[4];
        DSLR[0] = (2 * front) % 10000;
        DSLR[1] = front == 0 ? 9999 : front - 1;
        DSLR[2] = (front % 1000) * 10 + (front / 1000);
        DSLR[3] = (front / 10) + (front % 10) * 1000;

        for (int i = 0; i < 4; i++) {
            if (visited[DSLR[i]] == -1) {
                visited[DSLR[i]] = front;
                dslr[DSLR[i]] = flag[i];
                q.push(DSLR[i]);
            }
        }
    }
}

int main() {
    ios_base::sync_with_stdio(0);
    cin.tie(0);

    cin >> T;
    for (int t = 0; t < T; t++) {
        cin >> A >> B;

        for (int i = 0; i < MAX; i++) {
            visited[i] = -1;
            dslr[i] = 0;
        }

        BFS();
    }

    return 0;
}
