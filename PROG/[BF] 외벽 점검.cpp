// 소요시간: 1시간 32분
// 실행시간: 최대 34.97ms

/*

문제 설명

레스토랑을 운영하고 있는 스카피는 레스토랑 내부가 너무 낡아 친구들과 함께 직접 리모델링 하기로 했습니다. 
레스토랑이 있는 곳은 스노우타운으로 매우 추운 지역이어서 
내부 공사를 하는 도중에 주기적으로 외벽의 상태를 점검해야 할 필요가 있습니다.

레스토랑의 구조는 완전히 동그란 모양이고 외벽의 총 둘레는 n미터이며, 
외벽의 몇몇 지점은 추위가 심할 경우 손상될 수도 있는 취약한 지점들이 있습니다. 
따라서 내부 공사 도중에도 외벽의 취약 지점들이 손상되지 않았는 지, 주기적으로 친구들을 보내서 점검을 하기로 했습니다. 
다만, 빠른 공사 진행을 위해 점검 시간을 1시간으로 제한했습니다. 
친구들이 1시간 동안 이동할 수 있는 거리는 제각각이기 때문에, 
최소한의 친구들을 투입해 취약 지점을 점검하고 나머지 친구들은 내부 공사를 돕도록 하려고 합니다. 
편의 상 레스토랑의 정북 방향 지점을 0으로 나타내며, 
취약 지점의 위치는 정북 방향 지점으로부터 시계 방향으로 떨어진 거리로 나타냅니다. 
또, 친구들은 출발 지점부터 시계, 혹은 반시계 방향으로 외벽을 따라서만 이동합니다.

외벽의 길이 n, 취약 지점의 위치가 담긴 배열 weak, 
각 친구가 1시간 동안 이동할 수 있는 거리가 담긴 배열 dist가 매개변수로 주어질 때, 
취약 지점을 점검하기 위해 보내야 하는 친구 수의 최소값을 return 하도록 solution 함수를 완성해주세요.

제한사항
- n은 1 이상 200 이하인 자연수입니다.
- weak의 길이는 1 이상 15 이하입니다.
  - 서로 다른 두 취약점의 위치가 같은 경우는 주어지지 않습니다.
  - 취약 지점의 위치는 오름차순으로 정렬되어 주어집니다.
  - weak의 원소는 0 이상 n - 1 이하인 정수입니다.
- dist의 길이는 1 이상 8 이하입니다.
  - dist의 원소는 1 이상 100 이하인 자연수입니다.
- 친구들을 모두 투입해도 취약 지점을 전부 점검할 수 없는 경우에는 -1을 return 해주세요.

입출력 예
n	weak	dist	result
12	[1, 5, 6, 10]	[1, 2, 3, 4]	2
12	[1, 3, 4, 9, 10]	[3, 5, 7]	1

입출력 예에 대한 설명
입출력 예 #1
원형 레스토랑에서 외벽의 취약 지점의 위치는 다음과 같습니다.
[외벽 점검1.jpg]

친구들을 투입하는 예시 중 하나는 다음과 같습니다.
- 4m를 이동할 수 있는 친구는 10m 지점에서 출발해 시계방향으로 돌아 1m 위치에 있는 취약 지점에서 외벽 점검을 마칩니다.
- 2m를 이동할 수 있는 친구는 4.5m 지점에서 출발해 6.5m 지점에서 외벽 점검을 마칩니다.

그 외에 여러 방법들이 있지만, 두 명보다 적은 친구를 투입하는 방법은 없습니다. 따라서 친구를 최소 두 명 투입해야 합니다.

입출력 예 #2
원형 레스토랑에서 외벽의 취약 지점의 위치는 다음과 같습니다.
[외벽 점검2.jpg]

7m를 이동할 수 있는 친구가 4m 지점에서 출발해 반시계 방향으로 점검을 돌면 모든 취약 지점을 점검할 수 있습니다. 
따라서 친구를 최소 한 명 투입하면 됩니다.

*/

/*

◆ 풀이

취약 지점의 개수가 최대 15개, 사람의 수가 최대 8명으로 매우 작은 수이므로 완전 탐색을 이용하여
사람을 1명부터 최대 8명까지 늘려가면서 중복되지 않는 모든 조합을 구하고, 순서대로 각 취약 지점에 배정하는 문제.

이 문제에서의 핵심은, "원형으로 되어 있는 레스토랑을 직선으로 배치하는 것"이다.
즉, 초기 취약 지점이 [1, 5, 6, 10]로 주어진다면 당연히 가장 먼저 생각하게 되는 건
1번부터 10번까지 차례대로 사람들을 배치하는 방법인데,
여기서 시작 지점은 1번이 될 수도, 5번이 될 수도, ... 10번이 될 수도 있다.

따라서 취약 지점의 시작 지점을 매번 바꿔가면서 원형으로 되어 있는 걸 직선으로 바꾸게 된다면,
5번이 시작 지점일 때는 [5, 6, 10, 13], 10번이 시작 지점일 때는 [10, 13, 17, 18]이 된다.
즉 그 앞에 있던 수들은 기존 수 + n이 되는 것이다.

그리고 이렇게 시작 지점을 바꿔 가면서 모든 경우를 구했다면,
다음 단계는 완전 탐색을 이용하여 사람을 1명부터 최대 8명까지 여러 조합을 구하는 것이다.

난 처음에는 항상 뽑히는 번호가 증가하게끔 조합을 짰었는데, 사실 뽑히는 번호는 항상 증가해야 된다는 법은 없었다..
오히려 이 문제에서는 어떤 사람이 먼저 나오냐에 따라 문제가 풀릴 수도, 풀리지 않을 수도 있으므로
뽑히는 번호의 순서는 증가할 수도, 감소할 수도 있다. (이미 뽑혔던 번호인지만 확인해주면 된다.)

조합을 구하게 되면 이전에 구해 놓았던 취약 지점 리스트에 따라 사람들을 배정해주면 되는데,
인덱스 0부터 가장 끝 인덱스까지 확인하면서
자신이 커버할 수 있는 만큼 최대한 커버한 후 다음 친구에게 넘겨주는 방법을 사용하면 된다.

이렇게 계속 넘겨주다가, 결국 넘길 지점이 없게 되면(모든 지점이 다 커버가 되었으면)
그때는 모든 취약 지점이 점검되었다는 뜻이므로 다른 경우는 볼 필요 없이 정답은 진행되고 있는 사람의 수가 된다.


◆ 후기

여러 상황을 생각해봐야 하는 경우, 입력의 크기가 작다면 거의 완전탐색으로 해결할 수 있는데,
나는 다른 방향의 완전탐색으로 삽질(?)을 하고 있어서 결국 처음에는 해결하지 못했다.
50분정도 고민한 끝에, 결국 카카오에서 발표한 해설을 보게 되었고, 그 방식대로 풀었더니 1번의 실수 후에 해결된 문제..!

프로그래머스에서는 해당 문제를 Level 3에 배치했지만, 실제 정답률이 0.6%밖에 되지 않았고,
나 역시도 풀이를 처음 봤을 때는 이렇게 접근하는 거였다고?! 싶었다. (결론은 어려웠다!ㅋㅋㅋㅋㅋㅋ)

완전 탐색 문제는 자주 나오는 유형이기에 그만큼 많이 풀기도 했어서
웬만한 문제들은 다 풀 수 있을 것이라 생각했는데... 역시나 건방진 생각이었다 ㅋㅋㅋㅋ ㅠㅠ

항상 겸손함을 잃지 말고, 어떤 일이든 열심히, 그리고 최선을 다하자!

*/

#include <string>
#include <vector>
#include <algorithm>

using namespace std;

const int MAX = 20;

int answer = -1;
bool isFinished = false;

vector<vector<int>> visitList;
int comb[MAX];
bool visited[MAX];

bool comp(int a, int b) {
    return a > b;
}

bool assignFriend(int K, vector<int> &dist) {
    for(int i=0; i<visitList.size(); i++) {
        int s = 0;
        for(int j=0; j<K; j++) {
            // 친구들을 순서대로 배정한다.
            bool flag = false;
            for(int k=s+1; k<visitList[i].size(); k++) {
                if(visitList[i][s] + dist[comb[j]] < visitList[i][k]) {
                    // j번째 친구가 k지점은 점검하지 못하는 경우
                    flag = true;
                    s = k;
                    break;
                }
            }
            
            if(!flag) return true;
        }
    }
    
    return false;
}

void getComb(int x, int K, vector<int> &dist) {
    if(isFinished) return;
    
    if(x >= K) {
        // k명의 친구들을 visitList에 따라 순서대로 배정한다.
        if(assignFriend(K, dist)) {
            isFinished = true;
            answer = K;
            
            return;
        }
    }
    else {
        for(int i=0; i<dist.size(); i++) {
            if(!visited[i]) { // i번째 친구가 조합 내에 존재하지 않는다면
                comb[x] = i;
                visited[i] = true;
                getComb(x+1, K, dist);
                visited[i] = false;
            }
        }
    }
}

int solution(int n, vector<int> weak, vector<int> dist) {
    sort(dist.begin(), dist.end(), comp); // 내림차순 정렬
    
    // 취약 지점의 시작 지점을 바꿔가면서 직선으로 펼쳐준 리스트를 구한다.
    for(int i=0; i<weak.size(); i++) {
        visitList.push_back(weak);
        
        // 다음 시작 지점을 기준으로 직선으로 펼쳐준다.
        int temp = weak[0];
        for(int j=0; j<weak.size()-1; j++) weak[j] = weak[j+1];
        weak[weak.size()-1] = temp + n;
    }
    
    // 1명부터 최대 dist.size()명까지 중복 없는 조합을 구한다.
    for(int i=1; i<=dist.size(); i++) {
        getComb(0, i, dist);
        if(isFinished) break;
    }
    
    return answer;
}