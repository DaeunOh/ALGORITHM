// 소요시간: 28분
// 실행시간: 0ms

/*

신입사원 어피치는 카카오톡으로 전송되는 메시지를 압축하여 전송 효율을 높이는 업무를 맡게 되었다. 
메시지를 압축하더라도 전달되는 정보가 바뀌어서는 안 되므로, 
압축 전의 정보를 완벽하게 복원 가능한 무손실 압축 알고리즘을 구현하기로 했다.

어피치는 여러 압축 알고리즘 중에서 성능이 좋고 구현이 간단한 LZW(Lempel–Ziv–Welch) 압축을 구현하기로 했다. 
LZW 압축은 1983년 발표된 알고리즘으로, 이미지 파일 포맷인 GIF 등 다양한 응용에서 사용되었다.

LZW 압축은 다음 과정을 거친다.
1. 길이가 1인 모든 단어를 포함하도록 사전을 초기화한다.
2. 사전에서 현재 입력과 일치하는 가장 긴 문자열 w를 찾는다.
3. w에 해당하는 사전의 색인 번호를 출력하고, 입력에서 w를 제거한다.
4. 입력에서 처리되지 않은 다음 글자가 남아있다면(c), w+c에 해당하는 단어를 사전에 등록한다.
5. 단계 2로 돌아간다.

압축 알고리즘이 영문 대문자만 처리한다고 할 때, 사전은 다음과 같이 초기화된다. 
사전의 색인 번호는 정수값으로 주어지며, 1부터 시작한다고 하자.
색인 번호	1	2	3	...	24	25	26
단어	A	B	C	...	X	Y	Z

예를 들어 입력으로 KAKAO가 들어온다고 하자.
1. 현재 사전에는 KAKAO의 첫 글자 K는 등록되어 있으나, 두 번째 글자까지인 KA는 없으므로, 
   첫 글자 K에 해당하는 색인 번호 11을 출력하고, 다음 글자인 A를 포함한 KA를 사전에 27 번째로 등록한다.
2. 두 번째 글자 A는 사전에 있으나, 세 번째 글자까지인 AK는 사전에 없으므로, 
   A의 색인 번호 1을 출력하고, AK를 사전에 28 번째로 등록한다.
3. 세 번째 글자에서 시작하는 KA가 사전에 있으므로, KA에 해당하는 색인 번호 27을 출력하고, 
   다음 글자 O를 포함한 KAO를 29 번째로 등록한다.
4. 마지막으로 처리되지 않은 글자 O에 해당하는 색인 번호 15를 출력한다.

현재 입력(w)	다음 글자(c)	출력	사전 추가(w+c)
K	A	11	27: KA
A	K	1	28: AK
KA	O	27	29: KAO
O		15	

이 과정을 거쳐 다섯 글자의 문장 KAKAO가 4개의 색인 번호 [11, 1, 27, 15]로 압축된다.

입력으로 TOBEORNOTTOBEORTOBEORNOT가 들어오면 다음과 같이 압축이 진행된다.

현재 입력(w)	다음 글자(c)	출력	사전 추가(w+c)
T	O	20	27: TO
O	B	15	28: OB
B	E	2	29: BE
E	O	5	30: EO
O	R	15	31: OR
R	N	18	32: RN
N	O	14	33: NO
O	T	15	34: OT
T	T	20	35: TT
TO	B	27	36: TOB
BE	O	29	37: BEO
OR	T	31	38: ORT
TOB	E	36	39: TOBE
EO	R	30	40: EOR
RN	O	32	41: RNO
OT		34	

입력 형식
입력으로 영문 대문자로만 이뤄진 문자열 msg가 주어진다. msg의 길이는 1 글자 이상, 1000 글자 이하이다.

출력 형식
주어진 문자열을 압축한 후의 사전 색인 번호를 배열로 출력하라.

입출력 예제
msg	answer
KAKAO	[11, 1, 27, 15]
TOBEORNOTTOBEORTOBEORNOT	[20, 15, 2, 5, 15, 18, 14, 15, 20, 27, 29, 31, 36, 30, 32, 34]
ABABABABABABABAB	[1, 2, 27, 29, 28, 31, 30]

*/

/*

◆ 풀이

'LWZ 압축'이라는 개념이 생소할지 모르겠지만, 문제에서 LZW 압축의 과정이 설명되어 있으므로
사실 LWZ 압축의 개념을 몰라도 과정대로만 구현하면 풀 수 있는 문제이다.

나는 주어진 압축 과정을 그대로 구현하진 않고, 조금 더 깔끔하게 구현하기 위해 주어진 예시 설명을 활용했다.
(압축 과정을 그대로 구현하려면 기존 msg의 내용을 바꾸는 행위가 추가적으로 필요하다.)


1. 길이가 1인 모든 단어를 포함하도록 사전을 초기화한다.

처음에는 길이가 1인 모든 단어(A-Z)를 포함하도록 사전을 초기화 하는 과정이 필요한데,
구현할 당시에는 A부터 Z까지를 하드코딩 없이 어떻게 map의 key로 사용할 수 있을지에 대한 고민이 조금 길었다.

결과적으로는 alpha라는 A-Z까지의 string을 선언하여, temp라는 string에 해당 인덱스의 알파벳을 더하면서 맵에 추가했는데,
사실 원했던 결과물은 굳이 alpha라는 string을 선언하지 않고, 'A' + i의 방식을 활용하여 맵에 추가하는 것이었다.
(그런데 i + 'A'는 char에서 사용되고, 이를 string으로 어떻게 바꿔야 하나에 대해 답을 찾지 못했었다.)

하지만 문제를 해결한 이후 다른 사람의 풀이를 참고했을 때,
string(반복 횟수, char) 을 사용하면 char 형의 문자를 반복 횟수만큼 반복하여 string으로 변환할 수 있음을 알게 되었다.
따라서 해당 문제에서는 string(1, 'A' + i)를 사용하면 "A", "B", "C", ..., "Z"에 해당하는 string을 얻어낼 수 있다.


2. 사전에서 현재 입력과 일치하는 가장 긴 문자열 w를 찾는다.
3. w에 해당하는 사전의 색인 번호를 출력하고, 입력에서 w를 제거한다.
4. 입력에서 처리되지 않은 다음 글자가 남아있다면(c), w+c에 해당하는 단어를 사전에 등록한다.

2. 3. 4. 에 설명되어 있는 대로 구현하게 되면, 기존 msg의 내용을 바꾸는 행위가 추가적으로 필요하다.
따라서 나는 기존 msg의 내용을 바꾸지 않게끔 msg의 처음부터 끝까지 보면서, w를 업데이트 시켜주는 방식을 활용했다.

즉, 초기 w의 값은 빈 string인 ""가 되며, 이후 w + msg[i]가 사전에 존재한다면, w에 msg[i]를 추가시키지만,
사전에 존재하지 않는다면, w에 해당하는 색인 번호를 즉시 answer에 넣고,
w + msg[i]를 사전에 추가시킨 후, w를 msg[i]로 초기화한다.

그리고 이 방법을 사용하면 가장 마지막에 생성되는 w의 색인 번호는 answer에 넣어지지 않으므로,
추가적으로 answer에 w에 해당하는 색인 번호를 answer에 넣어주는 작업이 필요하다.

이 방법이 문제에서 주어진 방법보다 더 깔끔한 것 같다!! (내 생각^_^)


◆ 후기

웬만하면 문제에서 주어진 그대로 구현하는 편인데,
이 문제는 사실 문자를 지우고 인덱스를 바꿔주고 하는 행위가 번거로워서(?) 예시를 참고하여 새롭게 구현해보았다.

결과적으로는 내가 사용한 방법이 주어진 방법보다 깔끔하게 되어서 기분이 좋긴 하지만,
만약 원하는 대로 구현이 되지 않았다면 오랜 시간 삽질했을 것 같은 느낌적인 느낌 ㅎㅎㅎ..

사실 그래서 다른 사람의 풀이를 참고하여 원래대로 구현하면 어떻게 될지 보려고 했는데,
살짝 보니 조금 복잡한 것 같아서 그냥 내 방법이 더 좋다!!!! 하고 넘어갔다.. ㅋㅋㅋㅋ

그래도 그동안 char 형의 문자 1개를 string으로 변환하기 위해 항상 빈 스트링을 선언하고 그에 더해주는 방식을 활용했는데,
새로운 방법을 알게 되어서 너무 너무 좋다.
(물론 A-Z처럼 일반적으로 사용되는 연속적인 문자라 가능한 일이다.
만약 불연속적인 값에 대해 색인번호를 주고자 한다면 원래 사용했던 방식이 더 맞는 방법이다!)

- char 형의 문자를 string으로 변환하는 함수
  string(반복 횟수, char); // 반복 횟수가 1이면 char 형의 문자 1개를 string으로 변환시켜준다.

*/

#include <string>
#include <vector>
#include <unordered_map>

using namespace std;

unordered_map<string, int> m;

vector<int> solution(string msg) {
    vector<int> answer;
    
    // 길이가 1인 모든 단어를 포함하도록 사전을 초기화한다.
    string alpha = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
    for(int i=0; i<26; i++) {
        string temp = "";
        m[temp + alpha[i]] = i+1;
    }

    // for(int i=0; i<26; i++) m[string(1, 'A' + i)] = i+1;
    
    string w = "";
    for(int i=0; i<msg.size(); i++) {
        // w + msg[i]가 사전에 존재한다면, w에 msg[i]를 추가시킨다.
        // 하지만 사전에 존재하지 않는다면, w에 해당하는 색인 번호를 answer에 넣고,
        //   w + msg[i]를 사전에 추가시킨 후, w를 msg[i]로 초기화한다.
        if(m.find(w + msg[i]) != m.end()) w += msg[i];
        else {
            answer.push_back(m[w]);
            m[w + msg[i]] = m.size() + 1;
            
            w = "";
            w += msg[i];
        }
    }
    answer.push_back(m[w]);
    
    return answer;
}