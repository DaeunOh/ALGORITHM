/*

▶ 소요시간 및 실행시간
19분, 0ms

▶ 문제
각 지방에서 요청하는 예산이 담긴 배열과 총 예산이 매개변수로 주어질 때, 위의 조건을 모두 만족하는 상한액을 구하시오.

▶ 출처
https://programmers.co.kr/learn/courses/30/lessons/43237

▶ 풀이
주어진 예산 내에서 각 지방이 요청하는 예산을 최대한 만족하게끔 예산을 지급하는 문제.

모든 요청이 배정될 수 있는 경우에는 요청 금액을 그대로 배정하지만,
배정될 수 없는 경우에는 정수 상한액을 계산하여 이상인 금액은 상한액을 배정하고, 미만인 금액은 요청 금액을 배정해야 한다.

이 문제의 총 예산은 지방의 수 이상이므로, 적어도 1의 예산만큼은 다 줄 수 있다는 소리이므로
1부터 요청 예산 중 최댓값 사이에 원하는 상한액이 OOOOOXX 패턴으로 나타날 수 있다.
즉, 만약 모든 요청이 배정될 수 있는 경우에는 상한액이 요청 예산 중 최댓값이 되고, (이 경우에는 OOOOO 패턴이다.)
그렇지 않은 경우에는 상한액이 OX 패턴 중, O가 나타나는 마지막 지점이다.

보통 OX의 패턴이 나오는 경우 시간을 절약하기 위해 이분탐색을 이용하며, 이분탐색에서는 start와 end의 정의가 중요하다.
이에 나는 start를 정답과 같거나 작은 금액(최소 1)으로 설정하고, end를 정답보다 항상 큰 금액으로 설정했다.

이후 둘 사이의 mid를 구했을 때, 만약 예산 이하라면 start를 mid로 변경하고, 예산을 초과했다면 end를 미드로 변경해서
최종적으로 start와 end가 붙게 되었을 때, start는 O가 나타나는 마지막 지점을 가리키므로
answer을 start로 설정해주는 방식을 사용했다.

또한, 중간에 예산을 계산하는 부분에 sum이라는 변수를 사용하게 되는데,
문제에서 총 예산은 int형 범위이지만, 각 지방에서 요청하는 예산의 합인 sum은 int형 범위를 넘어갈 수도 있으므로
int가 아닌 long long int 타입을 써줘야 함을 잊지 말자! (경험담 ㅋㅋㅋㅋ ㅠㅠ)

▶ 후기
어느 기업 코딩 테스트에서 나는 특정 문제에 대해 이분탐색을 사용하는 방식 시도해보려고 했다.
(사실 문제에서 원하는 풀이 방식이 이분탐색은 아니었던 것 같지만... ㅠㅠ)
그런데 사실 평소에 이분탐색 문제를 많이 풀지 않아서 이분탐색 개념을 사용하고자 했을 때 한 번에 떠오르지 않았고,
결국 그 문제는 이분탐색을 사용하지 못했다 ...! (긴장감때문에 더 그랬을 것 같다.)

그때 못푼 문제가 너무 아쉬워서..ㅎ 이분탐색에 대해서는 확실히 집고 넘어가자 하는 마음에 이 문제를 풀게 되었고,
이상하게도(?) 그때랑 지금이랑 달라진 건 없는데, 이 문제는 이분탐색 개념이 한 번에 떠올라서 신기했다.. ㅋㅋㅋ

어쨌든 그때 기억이 안난 거라면, 지금 잘 풀었어도 이분탐색 개념을 헷갈리고 있었던 것은 맞으니!
제대로 공부하고 넘어가도록 하자 ㅎㅎㅎ

*/

#include <string>
#include <vector>

using namespace std;

int solution(vector<int> budgets, int M) {
    int answer = 0;
    
    long long sum = 0;
    int myMax = 1;
    for(int i=0; i<budgets.size(); i++) {
        sum += budgets[i];
        if(myMax < budgets[i]) myMax = budgets[i];
    }
    
    // 1. if 모든 요청이 배정될 수 있는 경우 ? 요청 금액을 그대로 배정한다.
    // 2. else ? 상한액 이상인 요청에는 상한액을 배정하고, 미만인 요청에는 요청 금액을 배정한다.
    if(sum <= M) answer = myMax;
    else { 
        int start = 1, end = myMax; // start : 정답과 같거나 작은 금액, end : 정답보다 항상 큰 금액
        
        while(start + 1 != end) { // start와 end가 붙을 때까지
            int mid = (start + end) / 2;
            
            long long sum = 0;
            for(int i=0; i<budgets.size(); i++) {
                if(budgets[i] >= mid) sum += mid;
                else sum += budgets[i];
            }
            
            if(sum <= M) start = mid; // 배정 가능
            else end = mid; // 배정 불가능
        }
        
        answer = start;
    }
    
    return answer;
}