/*

▶ 소요시간 및 실행시간
33분, 1ms

▶ 문제
작업의 요청부터 종료까지 걸린 시간의 평균을 가장 줄이는 방법으로 처리하면 평균(int)이 얼마가 되는지 구하시오.

▶ 출처
https://programmers.co.kr/learn/courses/30/lessons/42627

▶ 풀이
요청이 온 순서대로 작업을 처리하는 것이 아니라, 걸린 시간의 평균을 가장 줄이는 방법으로 처리하는 문제.

이 문제를 풀기 위해선 "어떻게 평균 시간을 줄일 수 있을까?" 부터 시작해야 한다.
나는 이에 대한 해답이
"요청이 온 순서대로 처리하되, 만약 처리해야 할 요청이 많으면 가장 소요시간이 짧은 것부터 처리한다."라고 생각했다.

따라서 요청이 온 순서대로 처리하기 위해서는 가장 먼저 1) 요청 시점에 따라 오름차순으로 정렬하는 것이 필요하다.
(문제에서는 요청 시점이 오름차순으로 정렬되어 있다는 말이 없다.)

이후에는 반복문을 사용하여 t(현재 시간)를 1씩 증가시킴으로써
2) jobs에 들어있는 작업 중 시간 t에 요청된 작업이 있는지 확인하고, 그 작업을 우선순위큐에 넣어야 한다.

이때 사용되는 유선순위큐의 비교함수는
기본적으로는 소요시간을 내림차순으로 정렬하도록 되어 있으며, 만약 같은 소요시간이라면 먼저 요청된 작업이 우선이다.

또한, 미리 요청 시점에 대해서 오름차순으로 정렬해 놓았기 때문에,
이미 큐에 추가된 작업들은 다시 보지 않도록 하기 위해 시작 인덱스 idx를 별도록 사용하도록 했다.
(큐에 추가될 때마다 idx를 증가 시키면서 idx 이전의 인덱스는 보지 않도록 구현했다.)

그리고 이후, 큐가 비었을 때는 t를 증가시키지만,
큐가 비어있지 않고, 현재 시간이 작업 종료 시간보다 크거나 같은 경우(진행되고 있는 작업이 끝난 경우)에는
큐의 탑에 있는 작업을 꺼내서 작업 종료 시간을 업데이트 하고,
answer에 요청 시점부터 종료 시점까지 얼마나 소요되는지를 누적해서 더해준다.

이 과정이 끝나는 시점은 모든 작업을 큐에 한 번씩 다 넣었고, 그 요청을 다 끝낸 경우가 된다.

▶ 후기
처음에는 요청 시점이 당연히 오름차순으로 정렬 되어 있을 것이라 생각했으며, 중복된 요청 시점은 없을 것이라 생각했다.
하지만 이런 경우가 있었다면 당연히 조건에 명시해주었을텐데, 너무 당연스럽게 생각해버렸다는 안타까움이 있었다...

그래도 다행히 오름차순으로 정렬해야 한다는 점과, 중복된 요청 시점이 있을 것이라는 점은 금방 캐치했기에,
기존 코드에서 몇 가지의 수정으로 문제를 해결할 수 있었다.

앞서 풀었던 다른 우선순위큐 문제와 같이, 이 문제도 우선순위큐의 개념을 조금 더 익히려고 푼 문제인데,
사실 우선순위큐를 사용해야 한다는 것을 알아서 쉽게 풀린건지, 아니면 몰랐더라도 우선순위큐를 썼을지는 잘 모르겠다. ㅎㅎㅎ;;

그래도 후자라고 생각하고...
다른 문제를 풀 때도 뭔가 특정 시점에서 최대한 만족하게끔 하는 문제들은 우선순위큐를 고려해보도록 해야겠다!

*/

#include <string>
#include <vector>
#include <queue>
#include <iostream>
#include <algorithm>

using namespace std;

struct comp {
    bool operator()(pair<int, int> &a, pair<int, int> &b) {
        if(a.second == b.second) return a.first > b.first;
        else return a.second > b.second;
    }
};

priority_queue<pair<int, int>, vector<pair<int, int>>, comp> pq;

int solution(vector<vector<int>> jobs) {
    int answer = 0;
    sort(jobs.begin(), jobs.end()); // 오름차순으로 시간 정렬
    
    int idx = 0; // 요청된 작업을 확인하기 위한 시작 인덱스
    int t = 0, e = 0; // 현재 시간, 작업 종료 시간
    while(1) {
        for(int i=idx; i<jobs.size(); i++) {
            if(jobs[i][0] == t) { // 시간 t에 요청된 작업을 우선순위큐에 넣는다.
                pq.push({jobs[i][0], jobs[i][1]});
                idx++;
            }
            else break;
        }
        
        if(!pq.empty() && t >= e) { // 현재 시간이 작업 종료 시간보다 크거나 같은 경우
            pair<int, int> top = pq.top(); // 가장 짧은 소요시간의 작업을 선택한다.
            pq.pop();
            
            e = t + top.second; // 끝나는 시간 = 현재 시간 + 소요시간
            answer += e - top.first; // 총 시간(누적) += 끝나는 시간 - 요청시간
        }
        
        if(idx == jobs.size() && pq.empty()) break; // 모든 작업을 큐에 넣었고, 그 요청을 다 끝냈다면
        t++;
    }
    
    return answer / jobs.size();
}