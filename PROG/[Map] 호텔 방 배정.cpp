// 소요시간: 정확성만 20분, 효율성은 통과하지 못함

/*

문제 설명
[본 문제는 정확성과 효율성 테스트 각각 점수가 있는 문제입니다.]

스노우타운에서 호텔을 운영하고 있는 스카피는 호텔에 투숙하려는 고객들에게 방을 배정하려 합니다. 
호텔에는 방이 총 k개 있으며, 각각의 방은 1번부터 k번까지 번호로 구분하고 있습니다. 
처음에는 모든 방이 비어 있으며 스카피는 다음과 같은 규칙에 따라 고객에게 방을 배정하려고 합니다.

1) 한 번에 한 명씩 신청한 순서대로 방을 배정합니다.
2) 고객은 투숙하기 원하는 방 번호를 제출합니다.
3) 고객이 원하는 방이 비어 있다면 즉시 배정합니다.
4) 고객이 원하는 방이 이미 배정되어 있으면 원하는 방보다 번호가 크면서 비어있는 방 중 가장 번호가 작은 방을 배정합니다.

예를 들어, 방이 총 10개이고, 고객들이 원하는 방 번호가 순서대로 [1, 3, 4, 1, 3, 1] 일 경우 다음과 같이 방을 배정받게 됩니다.

원하는 방 번호	배정된 방 번호
1	1
3	3
4	4
1	2
3	5
1	6

전체 방 개수 k와 고객들이 원하는 방 번호가 순서대로 들어있는 배열 room_number가 매개변수로 주어질 때, 
각 고객에게 배정되는 방 번호를 순서대로 배열에 담아 return 하도록 solution 함수를 완성해주세요.

[제한사항]
- k는 1 이상 1012 이하인 자연수입니다.
- room_number 배열의 크기는 1 이상 200,000 이하입니다.
- room_number 배열 각 원소들의 값은 1 이상 k 이하인 자연수입니다.
- room_number 배열은 모든 고객이 방을 배정받을 수 있는 경우만 입력으로 주어집니다.
    - 예를 들어, k = 5, room_number = [5, 5] 와 같은 경우는 방을 배정받지 못하는 고객이 발생하므로 
      이런 경우는 입력으로 주어지지 않습니다.

[입출력 예]
k	room_number	result
10	[1,3,4,1,3,1]	[1,3,4,2,5,6]

입출력 예에 대한 설명
입출력 예 #1

문제의 예시와 같습니다.

첫 번째 ~ 세 번째 고객까지는 원하는 방이 비어 있으므로 즉시 배정받을 수 있습니다. 
네 번째 고객의 경우 1번 방을 배정받기를 원했는데, 1번 방은 빈 방이 아니므로, 
1번 보다 번호가 크고 비어 있는 방 중에서 가장 번호가 작은 방을 배정해야 합니다. 
1번 보다 번호가 크면서 비어있는 방은 [2번, 5번, 6번...] 방이며, 이중 가장 번호가 작은 방은 2번 방입니다. 
따라서 네 번째 고객은 2번 방을 배정받습니다. 마찬가지로 5, 6번째 고객은 각각 5번, 6번 방을 배정받게 됩니다.

*/

/*

정확성만 통과하는 방식의 구현은 굉장히 쉽지만, 효율성 점수까지 얻어내는 데에는 아이디어가 떠오르지 않았던 문제.

정확성만 통과하려면, 손님들을 차례로 배정하는 방법만 구현하면 된다.
즉, 손님이 1번방을 원하는데 1번방이 비었다면 배정해주지만, 다음 손님이 1번방을 원하면 1번방이 아닌 그 다음 방을 확인하면서
그 다음 방이 비었으면 배정해주고, 다시 비지 않았다면 다음 방으로 또 넘어가는 방식을 사용하면 되는 것이다.

하지만, 위와 같은 방법은 K가 최대 10^12이므로 효율성 면에서는 굉장히 떨어지는 방법이다.
보통 효율성 문제의 경우 map(또는 set), 이분탐색, DP 등의 알고리즘으로 해결이 가능하다고 알고 있기에,
처음에 알고리즘을 선택할 때 이 문제에서 DP는 당연히 아닌 것 같고, 그나마 가능성이 보이는 이분탐색으로 정했다.

하지만 이분탐색을 사용하려 하더라도, start와 end를 적절히 옮기는 방법을 사용하기에는
여전히 K가 너무 컸고, 억지로 시행한다 하더라도
"원하는 방보다 번호가 크면서 비어있는 방중 가장 작은 번호의 방"을 찾을 수가 없었다.

그럼 그나마 가능성이 있는건 map이라고 생각했고, map으로 구현하려 했으나 이 역시도 어떻게 구현해야 할지는 막막했다.
사실 map으로 구현하자 하고 가장 처음 떠올랐던 생각은
1번방이 배정되었다면 1번방이 2번방을 가리키도록 하면 되지 않을까? 였다.

하지만 그렇게 해서 1번방을 또 원하는 사람이 2번방이 배정되었다고 하면,
1번이 가리키던 2번은 어떻게 다시 업데이트 시켜주지? 그리고 업데이트 해줘도 똑같이 시간이 오래걸리지 않을까? 였다.
그러고 나서 결국 map으로 구현하는 방법은 포기하고... 정확성만 맞춘 후 해설을 보게 되었다.

해설에서는 위에 생각했던과 비슷한 방법을 얘기하고 있었다.
map(또는 hash_map. 정렬할 필요는 없으므로 hash_map을 사용해도 되며 이게 더 빠르기도 하다)을 사용하면서
key에는 방번호를 넣어주고, value에는 부모노드를 넣어주는데 기본적으로는 자신+1을 넣어준다.

만약 방이 비었다면, 즉시 map에 node, node+1을 insert해주고 answer에는 node를 넣어준다.
하지만 방이 비지 않았다면, 해당 노드가 가리키는 부모의 맨 끝까지 올라가서 빈 방을 찾고,
새롭게 node, node+1을 insert한 후에 answer에 node를 넣어주고 나서,
그 빈 방의 번호를 지금까지 거쳐왔던 노드들의 parent로 설정해주면 된다.(재귀함수를 사용하면 된다!!!!)

또한, 이것보다 더 짧은 코드로 구현하는 방법도 있다. (모범 답안 참고)
똑같이 map과 재귀를 사용하긴 하나, 방이 비든 비지 않든 일단 find라는 함수로 시각하며,
그 함수 내에서는 해당 노드의 부모가 0인지(부모 방이 비었는지), 0이 아닌지(그럼 다시 그 부모를 타고 올라간다)에 따라
return 값이 서로 다르다. (부모 방이 비었으면 가장 최상단이므로 node를 리턴하고, 아니면 node의 parent를 리턴한다.)

그러나 여기에서 주의할 점은 m이 map일 때 x가 있는지 없는지를 확인하고자 m[x] == 0처럼 사용한다면,
생성자가 호출되어 x의 value가 0인 pair 하나가 자동으로 생성되므로,
0이어야 할 사이즈가 1로 바뀌어 버린다.

이 문제에서는 사이즈 자체를 고려할 필요는 없으므로 상관 없지만,
이론상으로는 해당 키가 존재하는지 확인하기 위한 올바른 방법이 아니므로
해당 키가 존재하는지 확인하려면 m.find(node) == m.end() (node가 맵에 없는 경우)와 같은 방법을 사용하도록 하자!

*/

#include <string>
#include <vector>
#include <map>
#include <iostream>

using namespace std;

vector<long long> answer;
map<long long, long long> m;

long long getNextNode(long long node) {
    if(m.find(node) == m.end()) {
        m.insert(make_pair(node, node + 1));
        answer.push_back(node);
    }
    else {
        m[node] = getNextNode(m[node]);
    }
    
    return m[node];
}

vector<long long> solution(long long k, vector<long long> room_number) {
    for(int i=0; i<room_number.size(); i++) {
        long long node = room_number[i];
        if(m.find(node) == m.end()) { // 빈 방인 경우
            m.insert(make_pair(node, node + 1));
            answer.push_back(node);
        }
        else { // 이미 배정된 방인 경우
            m[node] = getNextNode(m[node]);
        }
    }
    
    return answer;
}

// 모범답안
/*

#include <string>
#include <vector>
#include <map>

using namespace std;

map<long long, long long> p;

long long find(long long x) {
    if (p[x] == 0) return x;
    else {
        p[x] = find(p[x]);
        return p[x];
    }
}

vector<long long> solution(long long k, vector<long long> room_number) {
    vector<long long> answer;
    for (long long x : room_number) {
        long long y = find(x);
        answer.push_back(y);
        p[y] = y + 1;
    }
    return answer;
}

*/