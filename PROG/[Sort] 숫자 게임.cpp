/*

▶ 소요시간 및 실행시간
33분, 13ms

▶ 문제
A 팀원들이 부여받은 수가 출전 순서대로 나열되어있는 배열과
i번째 원소가 B팀의 i번 팀원이 부여받은 수를 의미하는 배열이 주어질 때, B 팀원들이 얻을 수 있는 최대 승점을 구하시오.

▶ 출처
https://programmers.co.kr/learn/courses/30/lessons/12987

▶ 풀이
A와 B의 길이가 최대 10만이므로,
순열을 이용하여 모든 케이스를 생각해보고(N) 점수를 계산하는(N) 방법인 완전탐색(O(N^2))으로는 해결할 수 없다.

그러면 이를 어떻게 O(N)까지 줄일 수 있을까?
이를 떠올리기 위해선 가장 먼저 A와 B를 오름차순으로 정렬해야함을 캐치해야 한다.
즉, A와 B를 오름차순으로 정렬하고, B의 인덱스를 증가시키면서 A보다 큰 경우를 구하는 것이다.

하지만 이때, 가장 중요한 건 A와 B의 인덱스를 같이 증가시키면 안된다는 것이다!!
B가 가진 점수를 통해 최대한 A를 이기려고 노력해야 하기 때문에,
현 B팀원의 점수로 A팀원에게 지는 경우가 생기면, B팀원은 다음 팀원으로 넘어가되 A팀원은 넘어가지 않아야 한다.

이렇게 최대한 A팀원을 이기는 방식으로 경기를 진행하게 되면,
B가 A보다 큰 경우의 개수가 바로 이 문제에서 원하는 B 팀원들이 얻을 수 있는 최대 승점이 된다.

▶ 후기
처음에 가장 먼저 떠올랐던 방법은 순열을 구해서 그 순열에 따라 점수를 계산하는 방법이었는데,
사실 순열을 구하는 데에는 O(N)이 걸리지만, 그 안에서 또 계산을 하는 부분이 있기 때문에 최종적으로는 O(N^2)이 된다.
그렇기에 당연히 이와 같은 방법으로는 원하는 답을 제한 시간 내에 구할 수 없게 된다...!

코드 자체를 놓고 보면, 코드 길이가 매우 짧고 간단하기 때문에 왜 LEVEL 3에 있는지 의문이겠지만,
문제에서 원하는 방법을 빠르게 캐치하느냐 / 하지 못하느냐에 따라 문제가 풀릴 수도, 풀리지 않을 수도 있는 문제라는 점에서
LEVEL 3에 배치 되었다고 생각한다. (나는 캐치하지 못했다 ㅎㅎ...)

아마 나는 문제에서 주어진 대로, A의 출전 순서에 맞춰 B의 순서를 정하는 방법을 사용하려다 보니,
문제에서 원하는 방식을 캐치하지 못한 것 같다.
(오름차순까지는 생각했지만, A와 B의 인덱스를 동일하게 증가시키는 방식밖에 떠오르지 않았다 ㅠ.ㅠ)

요즘 문제를 풀면서 느끼는 거지만, 요즘따라 문제에서 주어진 상황에 따라 코딩을 하는 것이 아니라
다른 관점에서 생각하여 새로운 풀이 방식을 구하는 경우가 많은 것 같다.
아마 이전에도 이와 비슷한 후기를 많이 썼던 것 같은데...
다른 관점에서 생각해보려 하지만 그게 잘 안되는 것 같아 조금 속상하당 ㅜㅜ..

그래도 아직까지는 문제를 얼마나 많이 푸느냐가 가장 중요하다고 생각하기 때문에..!
이런 상황에 좌절하지 말고 더 열심히 많이 많이 풀기 위해 노력해야겠다!

*/

#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int solution(vector<int> A, vector<int> B) {
	int answer = 0;

	sort(A.begin(), A.end());
	sort(B.begin(), B.end());

	for (int i=0; i<B.size(); i++) {
		if (A[answer] < B[i]) answer++;
	}
    
	return answer;
}