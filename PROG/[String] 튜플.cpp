// 소요시간: 33분
// 실행시간: 최대 9ms

/*

문제 설명

셀수있는 수량의 순서있는 열거 또는 어떤 순서를 따르는 요소들의 모음을 튜플(tuple)이라고 합니다. 
n개의 요소를 가진 튜플을 n-튜플(n-tuple)이라고 하며, 다음과 같이 표현할 수 있습니다.
(a1, a2, a3, ..., an)

튜플은 다음과 같은 성질을 가지고 있습니다.
1) 중복된 원소가 있을 수 있습니다. ex : (2, 3, 1, 2)
2) 원소에 정해진 순서가 있으며, 원소의 순서가 다르면 서로 다른 튜플입니다. ex : (1, 2, 3) ≠ (1, 3, 2)
3) 튜플의 원소 개수는 유한합니다.

원소의 개수가 n개이고, 중복되는 원소가 없는 튜플 (a1, a2, a3, ..., an)이 주어질 때(단, a1, a2, ..., an은 자연수), 
이는 다음과 같이 집합 기호 '{', '}'를 이용해 표현할 수 있습니다.

{{a1}, {a1, a2}, {a1, a2, a3}, {a1, a2, a3, a4}, ... {a1, a2, a3, a4, ..., an}}

예를 들어 튜플이 (2, 1, 3, 4)인 경우 이는
{{2}, {2, 1}, {2, 1, 3}, {2, 1, 3, 4}}
와 같이 표현할 수 있습니다. 이때, 집합은 원소의 순서가 바뀌어도 상관없으므로
{{2}, {2, 1}, {2, 1, 3}, {2, 1, 3, 4}}
{{2, 1, 3, 4}, {2}, {2, 1, 3}, {2, 1}}
{{1, 2, 3}, {2, 1}, {1, 2, 4, 3}, {2}}
는 모두 같은 튜플 (2, 1, 3, 4)를 나타냅니다.

특정 튜플을 표현하는 집합이 담긴 문자열 s가 매개변수로 주어질 때, 
s가 표현하는 튜플을 배열에 담아 return 하도록 solution 함수를 완성해주세요.

[제한사항]
1) s의 길이는 5 이상 1,000,000 이하입니다.
2) s는 숫자와 '{', '}', ',' 로만 이루어져 있습니다.
3) 숫자가 0으로 시작하는 경우는 없습니다.
4) s는 항상 중복되는 원소가 없는 튜플을 올바르게 표현하고 있습니다.
5) s가 표현하는 튜플의 원소는 1 이상 100,000 이하인 자연수입니다.
6) return 하는 배열의 길이가 1 이상 500 이하인 경우만 입력으로 주어집니다.

[입출력 예]
s	result
"{{2},{2,1},{2,1,3},{2,1,3,4}}"	[2, 1, 3, 4]
"{{1,2,3},{2,1},{1,2,4,3},{2}}"	[2, 1, 3, 4]
"{{20,111},{111}}"	[111, 20]
"{{123}}"	[123]
"{{4,2,3},{3},{2,3,4,1},{2,3}}"	[3, 2, 4, 1]

입출력 예에 대한 설명
입출력 예 #1
문제 예시와 같습니다.

입출력 예 #2
문제 예시와 같습니다.

입출력 예 #3
(111, 20)을 집합 기호를 이용해 표현하면 {{111}, {111,20}}이 되며, 이는 {{20,111},{111}}과 같습니다.

입출력 예 #4
(123)을 집합 기호를 이용해 표현하면 {{123}} 입니다.

입출력 예 #5
(3, 2, 4, 1)을 집합 기호를 이용해 표현하면 {{3},{3,2},{3,2,4},{3,2,4,1}}이 되며, 이는 {{4,2,3},{3},{2,3,4,1},{2,3}}과 같습니다.

*/

/*

"튜플"이라는 개념 자체가 생소해서, 처음에는 뭐지 했지만 차근 차근 따라가다 보면 해결할 수 있는 문제.
조건에 따라 스트링에 주어져 있는 숫자를 int형 변수로 바꾸는 함수인 stoi만 잘 사용해주면 된다.

사실 맨 처음에 떠올린 방법은 차집합을 이용하는 것이었다.
길이 1인 원소가 시작 원소이고, 다음 길이 2중에서 시작 원소를 뺀 원소가 2번째 원소, ...
이런식으로 이미 나온 원소는 지우고, 나오지 않은 원소를 해당번째의 원소로 확정시키면 되는 방법이다!

해당 방법은 { } 다음에 나타나는 ,를 기준으로 문자열을 나눠놓고 벡터에 넣은 후 길이 순으로 정렬한 후,
앞에서 언급한 방법을 그대로 사용하면 되는데,
처음 구현 당시에는 해당 방법까지는 떠오르지 않았고, 스트링 안에서 길이 1인 원소를 찾고, 2인 원소를 찾다보면
문자 전체를 보는 행위를 계속 해야하는 거 아니야?! 라고 생각한 탓에.. 구현을 하지 않았다.. ㅋㅋ
그리고 다른 방법으로 문제 풀고 나서 카카오에서 제공한 해설을 보니 저렇게 하는 방법이 있었다는 거..!

어쨌든, 내 방법도 생각보다 로직은 그렇게 복잡하지 않으니(맞겠지?) 나쁘지 않은 방법이라고 본다!

문제에서 주어진 스트링 s는 {{2},{2,1},{2,1,3},{2,1,3,4}}와 같이 양 끝에 괄호가 존재하고,
그 안에 또 숫자를 담은 괄호들이 ,로 나열되어 있는 형태이다.
따라서 나는 양 끝의 괄호를 제외한 나머지 괄호들만 보는 방식으로 시작했다!

해당 반복문에서 사용되는 변수들은 다음과 같다.
1) number[i] : 숫자 i가 몇 번째 수인지 저장한다.
2) flag : {} 이후에 나오는 ','와 {} 안에 나오는 ','를 구분한다. false면 {} 이후에 나오는 ','
3) num : {}안에 나오는','를 만나기 전까지 완성된 숫자를 저장한다.
4) S : 스택에 push가 끝나는 시점의 size에 따라 number[i]에 무슨 수가 저장될지 결정된다.

1) '{'를 만나는 경우
    flag를 true로 설정해준다.
2) 숫자를 만나는 경우
    num(string)에 해당 숫자를 더해준다.
3) ','를 만나는 경우
    스택에 현재까지 만들어진 num(string)을 int형 변수로 바꿔서 push한다.
4) '}'를 만나는 경우
    flag를 false로 바꾸고 num(string)을 스택에 마지막으로 푸쉬한다.
    그리고 스택 사이즈를 저장해놓은 후 스택에서 하나씩 꺼내면서
    number[top]이 0이거나 저장해놓은 스택 사이즈보다 큰 경우에 저장해놓은 스택 사이즈로 바꿔준다.

이렇게 구현하면 반복문이 끝난 시점에는 number[i]에 i가 몇 번째 수인지 저장된다.
이후 필요한 작업은 오름차순으로 숫자를 정렬하는 것이다.
그리고 오름차순으로 정렬된 숫자는 answer에 순서대로 푸쉬된다!

나중에 이 글을 봤을 때 빠르게 이해할 수 있게 최대한 쉽게(?) 설명했지만.... 바로 이해가 될지는 미지수다 ㅎㅎ..
이해... 되겠지..? 됐으면 좋겠다!!!!
내가 생각하고 있는 것을 그대로 전달하는 건 진짜 어려운 것 같다 ㅠㅠㅠ 앞으로도 많이 노력해야지!

*/

#include <string>
#include <vector>
#include <stack>
#include <algorithm>

using namespace std;

const int MAX = 100000 + 10;

bool comp(pair<int, int> a, pair<int, int> b) {
    return a.first < b.first;
}

vector<int> solution(string s) {
    vector<int> answer;
    int number[MAX] = {0, };
    
    bool flag = false;
    string num = "";
    stack<int> S;
    
    for(int i=1; i<s.size()-1; i++) {
        if(!flag && s[i] == ',') continue;
        
        if(s[i] == '{') {
            flag = true;
        }
        else if(s[i] == ',') {
            S.push(stoi(num));
            num = "";
        }
        else if(s[i] == '}') {
            flag = false;
            
            S.push(stoi(num));
            num = "";
            
            int len = S.size();
            while(!S.empty()) {
                int top = S.top();
                S.pop();
                
                if(!number[top] || number[top] > len) number[top] = len;
            }
        }
        else {
            num += s[i];
        }
    }
    
    vector<pair<int, int>> v;
    for(int i=1; i<=100000; i++) {
        if(!number[i]) continue;
        
        v.push_back(make_pair(number[i], i));
    }
    
    sort(v.begin(), v.end(), comp);
    
    for(int i=0; i<v.size(); i++) answer.push_back(v[i].second);
    
    return answer;
}