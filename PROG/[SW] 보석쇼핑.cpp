/*

▶ 소요시간 및 실행시간
39분, 0ms ~ 70ms

▶ 문제
가장 짧은 구간의 시작 진열대 번호와 끝 진열대 번호를 차례대로 배열에 담아서 return 하도록 하며,
만약 가장 짧은 구간이 여러 개라면 시작 진열대 번호가 가장 작은 구간을 return 하시오.

▶ 출처
https://programmers.co.kr/learn/courses/30/lessons/67258

▶ 풀이
진열대에서 특정 구간을 선택했을 때, 그 구간 안에 모든 종류의 보석이 다 들어갈 수 있는 최소 구간 길이를 구하는 문제.
(진열된 모든 종류의 보석을 적어도 1개 이상 포함하는 가장 짧은 구간을 구하는 문제)

몇 종류의 보석이 진열대에 존재하는지는 set을 이용하면 구할 수 있고,
해당 구간에 어떤 보석이 몇개 들어가 있는지, 몇 종류가 들어가 있는지는 map을 이용하면 구할 수 있다.

또한, 진열대에 들어가는 보석의 개수는 최대 10만이므로, O(N^2)의 시간 복잡도로는 풀 수 없는 문제이다.
따라서 이보다 작은 시간 복잡도를 가지도록 구현해야 하는데,
나는 O(N)의 시간 복잡도를 가지고 있는 슬라이딩 윈도우(투 포인터) 기법을 사용했다.

즉, start와 end라는 포인터를 움직여 가면서
start와 end가 가리키는 지점 사이에 모든 종류의 보석이 들어가도록 하는 최소 길이를 구하는 것이다.
나는 이 두 변수를 정의할 때 start가 가리키는 지점의 보석은 포함하고, end가 가리키는 지점의 보석은 포함하지 않도록 정의했다.

초기 start와 end는 둘 다 0으로 시작함으로써 반복문을 돌게 되는데,
반복문에서는 가장 처음에 map의 크기와 set의 크기가 같은지 확인하고,
같지 않다면 end가 보석 개수의 범위를 넘어가진 않았는지 확인한다. (슬라이딩 윈도우에서는 이 순서가 굉장히 중요하다)

만약 map의 크기와 set의 크기가 같다면 그 구간에는 모든 종류의 보석이 있다는 뜻이므로
start를 1 증가시키고, start가 가리키고 있던 보석을 map에서 1개 감소시킨다. (이때 감소시킨 후의 개수가 0개라면 map에서 제거한다)
또한, 매번 myMin(최솟값)이 end-start보다 큰지를 항상 확인하며 최솟값을 갱신해줘야 한다.

하지만 만약 크기가 같지 않다면 end를 증가시켜 주면서 그 보석을 map에 넣어야 하는데,
end가 보석 개수의 범위를 넘어가면 안되므로 넘어가는지 확인하는 것이 필요하다.
만약 넘어가지 않았다면 end를 증가시켜 주면서 end가 가리키고 있던 지점의 보석을 map에 넣어주고,
넘어갔다면 이제 모든 종류의 보석이 있는 구간은 모두 찾았다는 뜻이므로 반복문을 빠져나온다.

▶ 후기
연속된 구간에서 특정 조건을 만족하는 무언가를 찾는 문제는 대부분 슬라이딩 윈도우(투 포인터)로 해결할 수 있다.
또한, 시간복잡도를 무조건 O(N^2)보다 작도록 구현해야 하면 더더욱 그렇다.

특히 요즘 많은 기업에서 슬라이딩 윈도우 문제를 많이 출제하는 것 같다.
내 기억상 이번 상반기 코딩테스트만 해도 2개의 기업에서 슬라이딩 윈도우 문제를 출제했던 것 같다.

모르고 있는 개념이라면 접근 방법을 떠올리기 쉽지 않지만,
만약 아는 개념이라면 금방 떠올릴 수 있는 문제 유형이므로 기억하고 있도록 하자!
(근데 사실 나는 슬라이딩 윈도우가 익숙하지 않아서 푸는데 조금 더 걸렸다 ㅎ;;)

*/

#include <string>
#include <vector>
#include <set>
#include <map>

using namespace std;

set<string> s;
map<string, int> m;
int myMin = 987987987;
int mStart = -1, mEnd = -1;

vector<int> solution(vector<string> gems) {
    vector<int> answer;
    
    for(int i=0; i<gems.size(); i++) {
        s.insert(gems[i]);
    }
    
    int start = 0, end = 0; // s는 포함하고, e는 포함하지 않음
    while(1) {
        if(m.size() == s.size()) {
            if(myMin > end - start) {
                myMin = end - start;
                mStart = start;
                mEnd = end - 1;
            }

            m[gems[start++]]--;
            if(m[gems[start-1]] == 0) m.erase(gems[start-1]);
        }
        else if(end == gems.size()) break;
        else m[gems[end++]]++;
    }
    
    answer.push_back(mStart+1);
    answer.push_back(mEnd+1);
    
    return answer;
}