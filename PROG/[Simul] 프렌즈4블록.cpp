// 소요시간: 31분
// 실행시간: 0ms

/*

블라인드 공채를 통과한 신입 사원 라이언은 신규 게임 개발 업무를 맡게 되었다. 이번에 출시할 게임 제목은 프렌즈4블록.
같은 모양의 카카오프렌즈 블록이 2×2 형태로 4개가 붙어있을 경우 사라지면서 점수를 얻는 게임이다.

[그림1]
만약 판이 위와 같이 주어질 경우, 라이언이 2×2로 배치된 7개 블록과 콘이 2×2로 배치된 4개 블록이 지워진다. 
같은 블록은 여러 2×2에 포함될 수 있으며, 지워지는 조건에 만족하는 2×2 모양이 여러 개 있다면 한꺼번에 지워진다.

[그림2]
블록이 지워진 후에 위에 있는 블록이 아래로 떨어져 빈 공간을 채우게 된다.

[그림3]
만약 빈 공간을 채운 후에 다시 2×2 형태로 같은 모양의 블록이 모이면 다시 지워지고 떨어지고를 반복하게 된다.

[그림4]
위 초기 배치를 문자로 표시하면 아래와 같다.
TTTANT
RRFACC
RRRFCC
TRRRAA
TTMMMF
TMMTTJ
각 문자는 라이언(R), 무지(M), 어피치(A), 프로도(F), 네오(N), 튜브(T), 제이지(J), 콘(C)을 의미한다

입력으로 블록의 첫 배치가 주어졌을 때, 지워지는 블록은 모두 몇 개인지 판단하는 프로그램을 제작하라.

입력 형식
- 입력으로 판의 높이 m, 폭 n과 판의 배치 정보 board가 들어온다. (2 ≦ n, m ≦ 30)
- board는 길이 n인 문자열 m개의 배열로 주어진다. 블록을 나타내는 문자는 대문자 A에서 Z가 사용된다.

출력 형식
입력으로 주어진 판 정보를 가지고 몇 개의 블록이 지워질지 출력하라.

입출력 예제
m	n	board	answer
4	5	[CCBDE, AAADE, AAABF, CCBBF]	14
6	6	[TTTANT, RRFACC, RRRFCC, TRRRAA, TTMMMF, TMMTTJ]	15

예제에 대한 설명
- 입출력 예제 1의 경우, 첫 번째에는 A 블록 6개가 지워지고, 
  두 번째에는 B 블록 4개와 C 블록 4개가 지워져, 모두 14개의 블록이 지워진다.
- 입출력 예제 2는 본문 설명에 있는 그림을 옮긴 것이다. 11개와 4개의 블록이 차례로 지워지며, 모두 15개의 블록이 지워진다.

*/

/*

◆ 풀이

보드에서 같은 모양의 2 x 2 블록을 찾아 지우고,
빈칸을 메꾸기 위해 위에 있던 블록을 아래로 떨어뜨린 후 다시 2 x 2 블록을 찾아 지우는 과정을 반복하는 시뮬레이션 문제.

블록을 지울 때, 연쇄적으로 일어나지 않고 개별적으로 일어나므로 queue를 이용하는 BFS를 사용하지 않아도 된다.
그저 [0~M-2][0~N-1]의 블럭에 대해 자신의 오른쪽, 아래쪽, 오른쪽아래를 확인하면서 자신의 모양과 같은지 확인하면 된다.

따라서 전체적인 진행 과정은 다음과 같다.
1) 자신의 오른쪽, 아래쪽, 오른쪽아래 3방향을 모두 확인하여 자신의 모양과 같은지 본다.
2) 3방향이 모두 자신의 모양과 같다면 visited 배열에 true로 표시해준다.
3) 모든 블록에 대해 확인해봤다면 visited 배열이 true로 표시 되어있는 지점의 블록을 모두 제거한다.
4) 제거가 끝나면 블록 사이에 빈 공간이 존재하지 않도록 위에 있는 블록을 아래로 떨어뜨린다.
5) 제거되는 블록이 없을 때까지 1) ~ 4)를 반복한다.

만약 3가지 방향을 확인할 때, 하나라도 다른 모양이 있다면 그 블록을 기준으로 하는 2x2가 완성되지 않기 때문에
그 즉시 다음 블록으로 넘어가야 하며, 모두 같은 모양이라면 그 블록을 기준으로 하는 2x2는 모두 제거 대상이 된다.
그리고 제거는 모든 2x2 블록을 찾은 이후에 진행되기 때문에, 제거대상을 visited 배열에 따로 표시를 해둬야 한다.

visited가 true인 지점에 대해서 블록을 모두 지워주고 나서는(나는 ' '를 지운 상태로 표시했다)
블록 사이에 빈 공간기 존재하지 않도록 위에 존재하는 블록들을 아래로 떨어뜨려줘야 한다.

블록은 항상 아래로 떨어지므로 모든 열에 대해 각 행의 맨 아래쪽 - 1부터 시작하여
빈칸은 넘어가고, 빈칸이 아닌 곳에 대해서만 아래로 떨어뜨리는 과정을 진행했다.

아래로 떨어뜨릴 때 사용한 방법은 다음과 같다.
while(y < m-1 && board[y+1][i] == ' ') y++;

이 코드는 m-1보다 작은 행들에 대해서 자신의 아래 행에 있는 블록이 빈칸이 아닐 때까지 y를 증가시켜 주는 코드이다.
즉, 자신을 기준으로 가장 아래에 있는 빈칸이 이후 자신의 위치가 되는 것이다.

나는 배열 안에 있는 무언가를 특정 방향으로 옮기고자 할 때, 위와 같은 코드를 매우 자주 사용한다.
+1 위치에 dy를 넣고, 생략 되었지만 i 뒤에 dx를 넣으면 아래 방향뿐만 아니라 모든 방향에 대해
하나의 함수만으로 구현할 수 있게 되므로 모든 방향을 따로 고려하지 않아도 된다는 장점이 있다.

최종적으로는 지워지는 블록이 없을 때까지 같은 과정을 계속 반복해주면 되므로,
이전 블록의 개수를 기억해둔 후 그 개수와 업데이트 된 개수를 비교하여 지워진 블록이 있는지 확인함으로써
다음 단계를 진행할지 종료할지 결정하면 된다.


◆ 후기

실제로 많은 게임에서 블록을 아래로 떨어뜨리는 방식을 자주 사용해서 그런지
시뮬레이션 문제에 비슷한 류의 문제들이 자주 보이는 것 같다.

그 때마다 풀이에서 언급했던 코드는 굉장히 유용한 코드가 되는데,
사실 매번 저 코드를 구현할 때마다 까먹어서 이전에 사용했던 코드를 참고하는 경우가 많았다 ㅎㅎㅎ;;
이제는 정말 외워야 할 시점인 것 같다 ㅎㅎ;; 다음에는 해당 코드를 다시 참고하는 일이 없게 하기 위해 꼭 기억해두도록 하자!

*/

#include <string>
#include <vector>

using namespace std;

const int MAX = 30 + 10;

int answer = 0;
bool visited[MAX][MAX] = {0, };

int dy[4] = {0, 0, 1, 1};
int dx[4] = {0, 1, 0, 1};

void check(int m, int n, vector<string> &board) {
    for(int i=0; i<m-1; i++) {
        for(int j=0; j<n-1; j++) {
            if(board[i][j] == ' ') continue;
            
            bool flag = false;
            for(int k=1; k<=3; k++) {
                int ny = i + dy[k];
                int nx = j + dx[k];
                
                if(board[i][j] != board[ny][nx]) {
                    flag = true;
                    break;
                }
            }
            
            if(!flag) {
                for(int k=0; k<4; k++) {
                    int ny = i + dy[k];
                    int nx = j + dx[k];
                    
                    if(!visited[ny][nx]) visited[ny][nx] = true;
                }
            }
        }
    }
}

void rem(int m, int n, vector<string> &board) {
    for(int i=0; i<m; i++) {
        for(int j=0; j<n; j++) {
            if(visited[i][j]) {
                board[i][j] = ' ';
                visited[i][j] = 0;
                answer++;
            }
        }
    }
}

void goDown(int m, int n, vector<string> &board) {
    for(int i=0; i<n; i++) {
        for(int j=m-2; j>=0; j--) { // 빈 공간을 채운다.
            if(board[j][i] == ' ') continue;
            
            int y = j;
            while(y < m - 1 && board[y+1][i] == ' ') y++;
            
            if(j != y) {
                board[y][i] = board[j][i];
                board[j][i] = ' ';
            }
        }
    }
}

int solution(int m, int n, vector<string> board) {
    while(1) {
        int prev = answer;
        check(m, n, board);
        rem(m, n, board);
        goDown(m, n, board);
        
        if(prev == answer) break;
    }
    
    return answer;
}
