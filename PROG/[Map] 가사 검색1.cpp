// 소요시간: 43분
// 실행시간: 효율성 문제 4, 5번 실패

/*

문제 설명
[본 문제는 정확성과 효율성 테스트 각각 점수가 있는 문제입니다.]

친구들로부터 천재 프로그래머로 불리는 프로도는 음악을 하는 친구로부터 
자신이 좋아하는 노래 가사에 사용된 단어들 중에 특정 키워드가 몇 개 포함되어 있는지 궁금하니 
프로그램으로 개발해 달라는 제안을 받았습니다.
그 제안 사항 중, 키워드는 와일드카드 문자중 하나인 '?'가 포함된 패턴 형태의 문자열을 뜻합니다. 
와일드카드 문자인 '?'는 글자 하나를 의미하며, 어떤 문자에도 매치된다고 가정합니다. 
예를 들어 "fro??"는 "frodo", "front", "frost" 등에 매치되지만 "frame", "frozen"에는 매치되지 않습니다.

가사에 사용된 모든 단어들이 담긴 배열 words와 찾고자 하는 키워드가 담긴 배열 queries가 주어질 때, 
각 키워드 별로 매치된 단어가 몇 개인지 순서대로 배열에 담아 반환하도록 solution 함수를 완성해 주세요.

가사 단어 제한사항
1) words의 길이(가사 단어의 개수)는 2 이상 100,000 이하입니다.
2) 각 가사 단어의 길이는 1 이상 10,000 이하로 빈 문자열인 경우는 없습니다.
3) 전체 가사 단어 길이의 합은 2 이상 1,000,000 이하입니다.
4) 가사에 동일 단어가 여러 번 나올 경우 중복을 제거하고 words에는 하나로만 제공됩니다.
5) 각 가사 단어는 오직 알파벳 소문자로만 구성되어 있으며, 특수문자나 숫자는 포함하지 않는 것으로 가정합니다.

검색 키워드 제한사항
1) queries의 길이(검색 키워드 개수)는 2 이상 100,000 이하입니다.
2) 각 검색 키워드의 길이는 1 이상 10,000 이하로 빈 문자열인 경우는 없습니다.
3) 전체 검색 키워드 길이의 합은 2 이상 1,000,000 이하입니다.
4) 검색 키워드는 중복될 수도 있습니다.
5) 각 검색 키워드는 오직 알파벳 소문자와 와일드카드 문자인 '?' 로만 구성되어 있으며, 
    특수문자나 숫자는 포함하지 않는 것으로 가정합니다.
6) 검색 키워드는 와일드카드 문자인 '?'가 하나 이상 포함돼 있으며, 
    '?'는 각 검색 키워드의 접두사 아니면 접미사 중 하나로만 주어집니다.
  6-1) 예를 들어 "??odo", "fro??", "?????"는 가능한 키워드입니다.
  6-2) 반면에 "frodo"('?'가 없음), "fr?do"('?'가 중간에 있음), "?ro??"('?'가 양쪽에 있음)는 불가능한 키워드입니다.

입출력 예
words	queries	result
["frodo", "front", "frost", "frozen", "frame", "kakao"]	["fro??", "????o", "fr???", "fro???", "pro?"]	[3, 2, 4, 1, 0]

입출력 예에 대한 설명
1) "fro??"는 "frodo", "front", "frost"에 매치되므로 3입니다.
2) "????o"는 "frodo", "kakao"에 매치되므로 2입니다.
3) "fr???"는 "frodo", "front", "frost", "frame"에 매치되므로 4입니다.
4) "fro???"는 "frozen"에 매치되므로 1입니다.
5) "pro?"는 매치되는 가사 단어가 없으므로 0 입니다.

*/

/*

queries의 전체 키워드 길이의 합이 최대 100만이고, words도 100만이므로
완전탐색을 사용한 방법은 효율성 문제를 통과하지 못함을 알 수 있다.
(와일드카드 문자가 있긴 하지만 대략적으로 계산했을 때)

나는 연산 횟수를 최대한 줄이기 위해 unordered_map을 사용했는데,
이를 활용한 방법은 빈번한 삽입때문에 효율성 4, 5번 문제를 통과하지 못한다.. ㅠㅠ
(처음에는 삽입시간을 고려하지 못하고 길이가 100만이기에 약 100만번의 연산 + 100만번의 연산이라고 생각해버렸다...)

그래도 맵을 이용한 방법은 다른 문제에서 잘 사용될 수도 있으니 정리는 필요하다고 생각했다!

나는 해당 문제를 해결하기 위해 words에 있는 word들을 길이1, 길이2, 길이3... 으로 나눴다.
예를들어 frodo라는 문자가 있으면 "f" "fr" "fro" "frod"처럼 길이가 1씩 증가하는 접두사로 나누고,
"o" "od" "odd" "odor"처럼 길이가 1씩 증가하는 접미사로 나누었다.

그리고 나서 myFront[5(문자 길이)]["f" 또는 "fr" 또는 ... "odor"] 의 값을 1씩 증가시켜 줌으로써
해당 접두사 또는 접미사를 가지는 단어의 개수들을 저장했다.

그리고 queries에 있는 쿼리들을 탐색하면서, 와일드카드 문자가 나오기 이전까지의 문자를 통해
answer에다가 myFront[q.size()][문자]의 값을 넣어주도록 했다!

그리고 모든 문자가 와일드카드인 경우도 처리해줘야 하므로,
그건 접두사와 접미사를 나누기 전에 길이에 따른 개수들을 mySize에 저장했으므로 그걸 사용하면 된다.
자세한 내용은 주석에 달아놓았으니 참고!

그리고 알아본 결과, 이 문제를 푸는 방법은 "Trie"라는 자료구조라고 한다.
나는 애초에 "Trie"라는 자료 구조를 모르고 시작했던 문제라 조금 당황스럽지만...
문자열에 특화된 이 "Trie" 자료구조는 문자열 집합을 표현하는 트리 자료구조이고,
원하는 원소를 찾는 작업을 O(n)에 해결할 수 있다고 한다.

이에 대한 개념을 먼저 배우고, 관련 예제문제를 풀어본 후 해당 문제를 다시 풀어보도록 해야겠다!

*/

#include <string>
#include <vector>
#include <map>
#include <iostream>
#include <unordered_map>

using namespace std;

const int MAX = 10000 + 10;

vector<unordered_map<string, int>> myFront(MAX);
vector<unordered_map<string, int>> myEnd(MAX);

int mySize[MAX] = {0, };

void divide(string w) {
    mySize[w.size()]++;
    
    string f = "";
    string e = "";
    for(int i=0; i<w.size(); i++) {
        f += w[i];
        e += w[w.size()-i-1];
        
        myFront[w.size()][f]++;
        myEnd[w.size()][e]++;
    }
}

vector<int> solution(vector<string> words, vector<string> queries) {
    vector<int> answer;
    
    for(auto &w : words) divide(w);
       
    for(auto &q : queries) {
        string str = "";
        
        if(q[0] == '?' && q[q.size()-1] == '?') {
            answer.push_back(mySize[q.size()]);
        }
        else if(q[0] != '?') {
            for(int i=0; i<q.size(); i++) {
                if(q[i] == '?') break;
                str += q[i];
            }
            
            answer.push_back(myFront[q.size()][str]);
        }
        else {
            for(int i=q.size()-1; i>=0; i--) {
                if(q[i] == '?') break;
                str += q[i];
            }
            
            answer.push_back(myEnd[q.size()][str]);
        }
    }
    
    return answer;
}