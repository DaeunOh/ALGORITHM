// 소요시간: 5분
// 실행시간: 최대 2.29ms

/*

문제 설명
초 단위로 기록된 주식가격이 담긴 배열 prices가 매개변수로 주어질 때, 가격이 떨어지지 않은 기간은 몇 초인지를 return 하도록 solution 함수를 완성하세요.

제한사항
prices의 각 가격은 1 이상 10,000 이하인 자연수입니다.
prices의 길이는 2 이상 100,000 이하입니다.
입출력 예
prices	return
[1, 2, 3, 2, 3]	[4, 3, 1, 1, 0]
입출력 예 설명
1초 시점의 ₩1은 끝까지 가격이 떨어지지 않았습니다.
2초 시점의 ₩2은 끝까지 가격이 떨어지지 않았습니다.
3초 시점의 ₩3은 1초뒤에 가격이 떨어집니다. 따라서 1초간 가격이 떨어지지 않은 것으로 봅니다.
4초 시점의 ₩2은 1초간 가격이 떨어지지 않았습니다.
5초 시점의 ₩3은 0초간 가격이 떨어지지 않았습니다.

*/

/*

이 문제를 처음 봤을 때, 가장 생각할 수 있는 방법은 완전탐색이다.

처음에는 prices의 길이가 최대 10만이기 때문에 O(n^2)의 방법으로는 풀 수 없다고 생각했는데,
같은 O(n^2)이더라도 그 안에서 연산을 어떻게 수행하느냐에 따라
O(N^2)의 방법으로도 풀릴 수 있다는 걸 처음에는 생각하지 못했다. ㅎㅎ;;;

O(N)의 방법을 우선적으로 생각해보려 했지만, 결국 생각이 나지 않아 이중 반복문을 사용했는데 통과돼서 매우 당황ㅎ;;
(소요 시간을 5분으로 적어놨는데, 이는 O(N)을 고민한 시간은 제외하고 완탐 사용해야지! 한 순간부터의 시간을 적은 것이다!)

아마 이중 반복문을 쓰더라도 봐야할 범위가 점점 좁아지고,
중간에 자신보다 작은게 하나라도 나타나면 반복문을 빠져나가기 때문에 시간이 오래 걸리지 않은 것 같다.

오늘 느낀 점은 + 그리고 사실 코테를 보면서 느낀 점은.
일단 효율성 점수가 따로 있는 문제는, 효율성 신경쓰지 말고 먼저 구현을 해놓고(어차피 많이 소요되지 않는다.)
그 이후에 시간이 부족하지 않으면 효율성도 고려해보는 것이 좋은 것 같다!

방법이 빠르게 생각나면 좋겠지만, 그렇지 않다면 특히나 시간이 황금같은 코테에서는
다른 풀 수 있는 문제도 놓쳐버릴 수 있기 때문이다. ㅜㅜ
내가 할 수 있는 한에서 최대한 많이 푸는 것이 중요하다고 생각한다! 화이팅!
(이제는 다시 O(N) 방법 고려해봐야지........)

*/

#include <string>
#include <vector>

using namespace std;

vector<int> solution(vector<int> prices) {
    vector<int> answer;
    
    for(int i=0; i<prices.size(); i++) {
        int cnt = 0;
        bool flag = false;
        for(int j=i+1; j<prices.size(); j++) {
            if(prices[i] <= prices[j]) cnt++;
            else {
                answer.push_back(cnt+1);
                flag = true;
                break;
            }
        }
        if(!flag) answer.push_back(cnt);
    }
    
    return answer;
}