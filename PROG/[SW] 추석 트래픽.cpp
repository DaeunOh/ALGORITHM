// 소요시간: 2시간
// 실행시간: 3ms

/*

이번 추석에도 시스템 장애가 없는 명절을 보내고 싶은 어피치는 서버를 증설해야 할지 고민이다. 
장애 대비용 서버 증설 여부를 결정하기 위해 작년 추석 기간인 9월 15일 로그 데이터를 분석한 후
초당 최대 처리량을 계산해보기로 했다.
초당 최대 처리량은 요청의 응답 완료 여부에 관계없이 임의 시간부터
1초(=1,000밀리초)간 처리하는 요청의 최대 개수를 의미한다.

입력 형식
- solution 함수에 전달되는 lines 배열은 N(1 ≦ N ≦ 2,000)개의 로그 문자열로 되어 있으며, 
  각 로그 문자열마다 요청에 대한 응답완료시간 S와 처리시간 T가 공백으로 구분되어 있다.
- 응답완료시간 S는 작년 추석인 2016년 9월 15일만 포함하여 고정 길이 2016-09-15 hh:mm:ss.sss 형식으로 되어 있다.
- 처리시간 T는 0.1s, 0.312s, 2s 와 같이 최대 소수점 셋째 자리까지 기록하며 뒤에는 초 단위를 의미하는 s로 끝난다.
- 예를 들어, 로그 문자열 2016-09-15 03:10:33.020 0.011s은 2016년 9월 15일 오전 3시 10분 **33.010초**부터
  2016년 9월 15일 오전 3시 10분 **33.020초**까지 **0.011초** 동안 처리된 요청을 의미한다. 
  (처리시간은 시작시간과 끝시간을 포함)
- 서버에는 타임아웃이 3초로 적용되어 있기 때문에 처리시간은 0.001 ≦ T ≦ 3.000이다.
- ines 배열은 응답완료시간 S를 기준으로 오름차순 정렬되어 있다.

출력 형식
solution 함수에서는 로그 데이터 lines 배열에 대해 초당 최대 처리량을 리턴한다.

입출력 예제
예제1
입력: [
2016-09-15 01:00:04.001 2.0s,
2016-09-15 01:00:07.000 2s
]

출력: 1

예제2
입력: [
2016-09-15 01:00:04.002 2.0s,
2016-09-15 01:00:07.000 2s
]

출력: 2

설명: 처리시간은 시작시간과 끝시간을 포함하므로
첫 번째 로그는 01:00:02.003 ~ 01:00:04.002에서 2초 동안 처리되었으며,
두 번째 로그는 01:00:05.001 ~ 01:00:07.000에서 2초 동안 처리된다.
따라서, 첫 번째 로그가 끝나는 시점과 두 번째 로그가 시작하는 시점의 구간인
01:00:04.002 ~ 01:00:05.001 1초 동안 최대 2개가 된다.

예제3
입력: [
2016-09-15 20:59:57.421 0.351s,
2016-09-15 20:59:58.233 1.181s,
2016-09-15 20:59:58.299 0.8s,
2016-09-15 20:59:58.688 1.041s,
2016-09-15 20:59:59.591 1.412s,
2016-09-15 21:00:00.464 1.466s,
2016-09-15 21:00:00.741 1.581s,
2016-09-15 21:00:00.748 2.31s,
2016-09-15 21:00:00.966 0.381s,
2016-09-15 21:00:02.066 2.62s
]

출력: 7

설명: 아래 타임라인 그림에서 빨간색으로 표시된 1초 각 구간의 처리량을 구해보면 
(1)은 4개, (2)는 7개, (3)는 2개임을 알 수 있다. 따라서 초당 최대 처리량은 7이 되며, 
동일한 최대 처리량을 갖는 1초 구간은 여러 개 존재할 수 있으므로 이 문제에서는 구간이 아닌 개수만 출력한다.

[그림]

*/

/*

◆ 풀이

로그 데이터에 주어진 응답완료시간과 처리시간을 통해
슬라이딩 윈도우 기법을 활용하여 초당 최대 처리량을 구하는 문제.

전체적인 과정은 다음과 같다.

1) 로그 데이터에서 응답완료시간(S)과 처리시간(T)를 분리한다.
띄어쓰기를 기준으로 날짜/시간/처리시간이 구분되어 있으므로 stringstream을 이용해서 쉽게 분리할 수 있다.

2) 응답완료시간(S)에서 hh:mm:ss.sss 형식으로 되어 있는 시간을 밀리 세컨드 단위로 변환한다.
응답완료시간은 항상 hh:mm:ss.sss 형식으로 되어 있기 때문에 substr과 인덱스를 이용해서 분리해준후,
(hh * 3600 + mm * 60 + ss) * 1000 + sss 식을 이용하여 밀리 세컨드 단위로 변환해준다.

3) 처리시간(T)을 밀리 세컨드 단위로 변환한다.
T는 항상 세컨드 단위이므로 T에 * 1000을 해준 값이 밀리 세컨드이다.

4) 응답시작시간을 구한다.
처리시간은 시작시간과 끝시간을 포함하므로 응답시작시간은 응답종료시간 - 처리시간 + 1이 된다.

5) 응답시작시간과 응답완료시간이 포함되어 있는 벡터를 처음부터 끝까지 보면서,
   응답완료시간 + 999 안에 응답시작시간이 걸쳐있는 경우가 있다면 카운트를 1 증가시킨다.
   (lines 배열이 응답완료시간을 기준으로 오름차순 되어 있기 때문에 항상 응답시작시간을 보는 인덱스는 자신부터 시작한다)

6) 구한 카운트를 통해 초당 최대 처리량인 answer을 업데이트 시킬지 말지 정한다.


◆ 후기

level 3에 들어 있어서 당연히 level 2보다는 어렵겠지만, 1시간 내로 풀 수 있을 정도의 난이도라고 생각했다.
하지만 밀리 세컨드 단위로 바꾸는 과정에서 자꾸 오류가 나고(stof로 ss.sss를 받고 * 1000을 해주면 값이 달라진다;;)
start와 end 포인터를 이용해서 O(N)만에 풀 수 있을 것이란 착각에 많은 시간을 소비했다.

밀리 세컨드 단위로 바꾸는 과정은
굳이 ss.sss를 받지 않고, ss와 sss를 분리하여 받은 후 변환함으로써 쉽게 오류를 해결할 수 있었다.

또한, 이 문제의 시간 복잡도는 O(N)이 아니라 O(N^2)인데,
나는 문제에서 종료시간이 오름차순으로 되어 있다는 말에 꽂혀서 시작시간은 생각하지 않고 종료시간 + 999보다
그 다음 인덱스의 시작시간이 더 크다면 그 이후의 인덱스의 시작시간은 보지 않아도 된다고 생각했다.

하지만 문제에서는 종료시간만 오름차순으로 되어 있을뿐, 시작시간은 다음 인덱스라고 해서 항상 더 뒤에 있다는 법은 없었다.
즉, 시작시간은 처리시간에 종속되어 있는 시간이므로 다음 인덱스에서는 1초 내에 포함되지 않지만,
그 다음 인덱스에서는 1초 내에 포함될 수도 있는 것이므로 투 포인터로 O(N)에 해결할 수 없게 되는 것이다.

그러므로 한 종료시간을 기준으로 그 이후의 인덱스를 맨 끝까지 보면서,
종료시간 + 999이 다른 인덱스의 시작시간보다 크거나 같은 경우에 cnt를 1 증가시켜 주는 방식을 활용하면
O(N^2)으로 답을 구할 수 있게 된다. (여기서 N은 최대 2000이므로 N^2은 4000000밖에 되지 않는다.)

너무나 당연하게 투 포인터로 풀어야지~ 했는데, 아니었던 문제 ㅎㅎ..
또한, 이 문제에서 종료시간 + 999를 기준으로 윈도우가 옮겨져 가기 때문에 슬라이딩 윈도우를 사용한다고 하는 것 같은데,
슬라이딩 윈도우 == 투 포인터 라고 여기고 있었던 나의 생각을 바로잡아준 문제.
(그것도 모르고 해설을 참고할 때 슬라이딩 윈도우 썼는데 왜 안되지?! 왜 O(N^2)이지?! 라고 생각했었당ㅎㅎㅎㅎ;;)

슬라이딩 윈도우랑 투 포인터는 가끔 그 개념이 비슷하다고 여겨질 때가 있어 동일하게 보는 경우도 있지만,
엄연히 말하면 다른 개념이므로 항상 같다고 생각하면 안된다!!

*/

#include <string>
#include <vector>
#include <sstream>
#include <algorithm>

using namespace std;

struct MILLIS {
    int sMS, eMS;
};

bool comp(MILLIS a, MILLIS b) {
    if(a.eMS == b.eMS) return a.sMS < b.sMS;
    else return a.eMS < b.eMS;
}

int solution(vector<string> lines) {
    int answer = 0;
    int N = lines.size();
    vector<MILLIS> MS;
    
    for(int i=0; i<lines.size(); i++) {
        stringstream ss(lines[i]);
        
        string S1, S2, T;
        ss >> S1 >> S2 >> T;
        
        T.erase(T.end() - 1);
        
        int t = stof(T) * 1000;
        
        int eH = stoi(S2.substr(0, 2));
        int eM = stoi(S2.substr(3, 2));
        int eS = stoi(S2.substr(6, 2));
        int eMS = (stoi(S2.substr(0, 2)) * 3600
                   + stoi(S2.substr(3, 2)) * 60
                   + stoi(S2.substr(6, 2))) * 1000
                   + stoi(S2.substr(9, 3));
        
        int sMS = eMS - t + 1;
        
        MS.push_back({sMS, eMS});
    }
    
    for(int i=0; i<MS.size(); i++) {
        int cnt = 0;
        
        for(int j=i; j<MS.size(); j++) {
            if(MS[i].eMS + 999 >= MS[j].sMS) cnt++;
        }
        
        if(answer < cnt) answer = cnt;
    }
    
    return answer;
}