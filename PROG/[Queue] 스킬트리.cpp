/*

▶ 소요시간 및 실행시간
13분, 0ms

▶ 문제
선행 스킬 순서와 유저들이 만든 스킬트리를 담은 배열이 매개변수로 주어질 때, 가능한 스킬트리 개수를 구하시오.

▶ 출처
https://programmers.co.kr/learn/courses/30/lessons/49993

▶ 풀이
선행 스킬 순서에 위배 되지 않는 가능한 스킬트리의 개수를 구하는 문제.
이 문제를 풀기 위해서 여러 방법을 사용할 수 있지만, 나는 가장 먼저 떠오르는 게 queue를 이용한 방법이었다.

queue를 이용한 풀이의 전체적인 수행 과정은 다음과 같다.

1) 문제에서 스킬은 중복해 주어지지 않는다고 했으므로,
    크기 26의 배열을 이용하여 선행 스킬 순서에 들어있는 스킬들만 check 배열을 true로 표시해줌과 동시에 큐에 넣는다.

2) 주어진 스킬 트리를 보면서,
    선행 스킬 순서에 포함되지 않은 스킬이라면 배울 수 있지만, 포함된 스킬이라면 그 스킬이 큐의 front에 있는지 확인해야 한다.
    또한, 만약 배우려고 하는 스킬이 큐의 front와 같다면 선행 스킬 순서에 위배되지 않으므로 배우고 넘어갈 수 있지만,
    같지 않다면 먼저 배워야 하는 스킬이 있다는 뜻이므로 바로 false를 return하여 카운트를 세지 않도록 구현한다.
    (선행 스킬 순서에 포함되어 있어도 그 순서를 위배하지 않게 배운 스킬 이라면 큐에서 pop이 될 것이다.)

▶ 후기
사실 스킬들이 모두 대문자로만 주어져 있고(대문자는 -'A'를 해서 0부터 25까지로 치환할 수 있다)
선행 스킬 순서가 1세트로만 주어져 있기 때문에 어찌 됐든 선행 스킬 순서만 위배되지 않도록 스킬을 배우면 되므로
다른 방법은 생각하지 않고 바로 queue를 사용하는 방법을 떠올렸다.

확장성을 고려하여 문제에서 주어진 조건을 조금 까따롭게 변형해보기도 했다. (여러 세트의 선행 스킬 순서, 중복된 스킬)

예를 들어 만약 선행 스킬 순서가 여러 세트가 주어진다면 bool 배열을 int 배열로 바꾸고,
해당 알파벳의 자리에다가 세트의 번호를 적는다면, 큐를 여러 개 만들어서 인덱스를 활용한 방식을 사용하면 될 것이다.

그리고 만약 선행 스킬 순서에 사용된 스킬이 중복해서 주어지는 경우가 있다 하더라도
int 배열을 vector<int> 배열로 만들어서 활용하는 방법으로 해결이 가능할 것이다!

여러 방식으로 변형한다 하더라도 queue를 사용해서 해결이 가능하기 때문에 좋은 방법인 것 같다 ㅎㅎ!

*/

#include <string>
#include <vector>
#include <queue>

using namespace std;

bool isPossible(string &skill, string &st) {
    bool check[26] = {0, };
    queue<int> q;
    
    for(auto &s : skill) {
        check[s-'A'] = true; // 선행 스킬을 true로 표시한다.
        q.push(s-'A'); // 큐에 선행 스킬 순서대로 넣는다.
    }
    
    for(auto &s : st) {
        if(!check[s-'A']) continue; // 선행 스킬 순서에 포함되지 않은 스킬이라면 넘어간다.
        else {
            if(q.front() == s-'A') q.pop(); // 선행 스킬 중 가장 먼저 배워야 하는 스킬인 경우
            else return false; // 먼저 배워야 하는 스킬이 있는 경우라면 불가능한 스킬트리이다.
        }
    }
    
    return true;
}

int solution(string skill, vector<string> skill_trees) {
    int answer = 0;
    
    for(auto &st : skill_trees) {
        if(isPossible(skill, st)) answer++;
    }
    
    return answer;
}