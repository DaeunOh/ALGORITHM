/*

▶ 소요시간 및 실행시간
13분, 11ms

▶ 문제
종이를 접은 횟수가 매개변수로 주어질 때, 종이를 절반씩 n번 접은 후 모두 펼쳤을 때 생기는 접힌 부분의 모양을 구하시오.

▶ 출처
https://programmers.co.kr/learn/courses/30/lessons/62049

▶ 풀이
종이를 한 번 접을때마다 생기는 접힌 부분의 모양을 이용하여 다음 모양을 구하는 문제.
이전의 결과를 이용하여 현재의 결과를 구하기 때문에 DP를 사용하여 구현했다!

즉, 종이를 1번 접을 때는 접힌 모양이 0으로 되어 있다는 것을 기저 조건으로 하고,
그 이후 2번 접을 때는 (1번 접었을 때의 모양 + 0 + !(1번 접었을 때의 대칭)) 으로 생각할 수 있으며,
이를 간단하게(?) 식으로 표현하면 T[i] = T[i-1] + 0 + !(T[i-1]의 역순)이 된다. (여기서 +는 연산에 사용되는 +가 아니다)

따라서 나는 이 식을 이용하여 처음 T[1]의 값을 0으로 집어넣고,
이후 T[i]를 구할 때는 이전 T[i-1]을 복사한 후, 0을 넣고, T[i-1]을 거꾸로 보면서 그 반댓값을 넣어주는 방식을 활용했으며,
T[n]의 값이 정답이 되도록 구현하였다.

▶ 후기
사실 이 문제는 T라는 공간을 따로 잡지 않아도
종이 접기를 n번 수행했을 때의 결과가 점점 누적되기 때문에 answer 하나만으로 해결이 가능하다.

즉, 매번 종이접기는 항상 "이전 결과값 + 0 + 이전 결과값의 역순을 반대로한 값"이 되므로,
가장 처음에 answer에 0을 넣어준 이후로는 이후 1번, ..., n번의 종이접기를 수행할 때,
answer 그 자체가 이전 결과값이 되기 때문에 바로 그 값에 0을 넣어주고,
이전 결과값의 맨 끝 이전부터(맨 끝은 새로 추가한 0이다) 0번 인덱스까지 보며 그 반대의 값을 넣어주면 된다.
(아래 코드 참고)

answer.push_back(0);
for(int i=0; i<n-1; i++) {
    answer.push_back(0);
    for(int j=answer.size()-2; j>=0; j--) 
        answer.push_back(!answer[j]);

항상 DP 문제를 해결할 때, 가장 중요한 이슈가 공간을 많이 사용한다는 점인데(뇌피셜)
내가 처음 풀었던 방식은 쓸데 없이 공간을 낭비하고 있다(?)는 점에서 아주 좋은 코딩 방식은 아니라고 생각한다.

최대한 공간을 적게 쓰는 내에서 효율적으로 답을 구하는 것이 가장 좋기 때문에!! 그러한 코딩 방식을 지향하도록 하자 ^_^

*/

#include <string>
#include <vector>

using namespace std;

vector<int> solution(int n) {
    vector<int> answer;
    vector<int> T[30];
    
    T[1].push_back(0);
    
    for(int i=2; i<=n; i++) {
        T[i] = T[i-1];
        T[i].push_back(0);
        for(int j=T[i-1].size()-1; j>=0; j--) {
            T[i].push_back(!T[i-1][j]);
        }
    }
    
    answer = T[n];
    
    return answer;
}