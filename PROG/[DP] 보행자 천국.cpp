/*

▶ 소요시간 및 실행시간
1시간 30분, bottom-up: 18ms / top-down(Memoization): 50ms

▶ 문제
도시의 도로 상태가 입력으로 주어졌을 때, 왼쪽 위의 출발점에서 오른쪽 아래 도착점까지 
자동차로 이동 가능한 전체 가능한 경로 수를 출력하는 프로그램을 작성하시오.
(이때 가능한 경로의 수는 컴퓨터가 표현할 수 있는 정수의 범위를 넘어설 수 있으므로, 
가능한 경로 수를 20170805로 나눈 나머지 값을 출력하시오.)

▶ 출처
https://programmers.co.kr/learn/courses/30/lessons/1832

▶ 풀이
주어진 도로 상태에 따라 (0, 0)에서 (m-1, n-1)로 이동이 가능한 경로의 수를 구하는 문제.
이 문제를 해결하기 위해서는 다이나믹 프로그래밍(DP)이 필요하다.

DP는 크게 bottom-up과 top-down 방식으로 나뉜다.
bottom-up 방식은 말 그대로 맨 밑바닥에서 부터 정답으로 가기 위해 필요한 값들을 차근 차근 계산해나가는 방식이며,
top-down 방식은 위에서 아래로 내려오는 방식으로, 함수 호출을 줄이기 위해 메모이제이션을 기법을 사용한다.
(메모이제이션: 중복된 계산을 막기 위해 저장된 값을 이용하는 방식)
나는 bottom-up 방식으로 먼저 구현을 시도하고, 이후 top-down 방식으로도 구현해보는 시간을 가졌다.

1) bottom-up
bottom-up 방식은 일반적으로 기저 조건을 정한 후, for문을 이용해서 처음값부터 다음값을 계산한다.
이 문제에서는 오른쪽, 아래쪽으로의 이동만 가능하므로,
현재 위치(i, j)에서 오른쪽으로 갈 수 있는 경우의 수와 아래쪽으로 갈 수 있는 경우의 수를 담는 2차원 배열이 총 2개 필요하다.
(또는 3차원 배열을 통해 [0]은 오른쪽, [1]은 아래쪽으로 사용해도 무방하다.)

그리고 가장 처음에는 도로 상태가 항상 0(어느 방향으로든 이동 가능)이므로, H[1][1]과 V[1][1]에 1을 기저조건으로 설정해준다.
이후에는 정답으로 가기 위해 필요한 값을 차근 차근 계산해 나가야 하는데, 이 역시도 도로의 상태에 따라 값을 정할 수 있다.

만약 현재 자신의 위치가 (i, j)라고 할 때 도로의 상태가 0이라면,
자신의 위쪽과 왼쪽 모두에서 (i, j)로 올 수 있기 때문에 H[i][j]와 V[i][j] 모두 H[i][j-1] + V[i-1][j]가 된다.

하지만 도로의 상태가 1이라면,
자신의 위쪽과 왼쪽 모두에서 (i, j)로 올 수 없기 때문에 H[i][j]와 V[i][j] 모두 0이 된다.

또한, 도로의 상태가 2라면 좌회전 또는 우회전은 안되지만 직진은 가능하므로,
H[i][j]는 자신의 왼쪽에서 온 H[i][j-1]이 되며, V[i][j]는 자신의 위쪽에서 온 V[i-1][j]가 된다.

이런 식으로 도로의 상태에 따라 이전의 값을 이용해서 자신의 값을 정해줌으로써
최종적으로 (m-1, n-1)에 있는 H 또는 V의 값을 정답으로 결정하는 것이 바로 bottom-up 방식이다.
(물론 경로의 수가 정수 범위를 넘어서지 않게 중간에 MOD로 나눈 나머지를 취하는 부분이 있어야 한다.
또한, 나는 배열의 범위를 넘어가는 경우가 없도록 하기 위해 (1, 1) ~ (m, n)으로 조정했다.)

2) top-down
top-down 방식은 일반적으로 메모이제이션을 사용하여 중복 계산을 막는다.
따라서 계산하는 중간에 이미 계산된 값이 있다면 중간에 계산을 중단하고 그 값을 그대로 사용한다.
이 방식을 활용하기 위해서는 3차원 배열을 사용했다. ([y][x][d])

이 문제에서 최종적으로 알고 싶은 값은 (m-1, n-1)으로 이동 가능한 경로의 수기 때문에,
(m-1, n-1)으로 도착한 케이스가 있다면 경로가 1개 증가한 것으로 볼 수 있다.
따라서 종료 시점을 자신의 위치가 (m-1, n-1)일 때로 하고, 그때 1을 반환하도록 해야한다.

그리고 메모이제이션을 사용하여 중복 계산을 막는다고 했는데,
이는 맨 처음에 테이블의 값을 -1로 초기화 해줬기 때문에 저장된 값이 있는지 없는지 확인하기 위해
자신의 위치 및 방향의 테이블이 -1인지 아닌지를 통해 확인한다.
만약 -1이 아니라면 자신을 출발로 하여 (m-1, n-1)으로 가는 경로가 있을 수 있다는 뜻이므로, 그 즉시 저장된 값을 반환한다.

이후에는 방향에 따라 차를 이동시키는 과정이 필요하다.
초기에 테이블 값을 -1으로 초기화 해줬지만, 실제 -1번이란 값은 없으므로 아무것도 하지 않았다는 의미에서 0을 재할당한다.

그리고 오른쪽, 아래쪽으로 차를 이동시킬 수 있을지 확인하게 되는데,
문제에서 맵이 2인 부분은 직진만 가능하다고 했으므로,
현재 자신의 도로 상태가 2인데 방향이 다르다면 그 방향으로는 움직일 수 없게 된다.
또한, 가고자 하는 위치가 범위를 벗어나는 경우나 그 위치의 도로 상태가 1인 경우에도 움직일 수 없게 된다.

따라서 최종적으로 움직일 수 있게 되는 경우는
범위 내에서 자신의 도로 상태가 0인 경우에 왼쪽, 오른쪽과 2인 경우에 방향이 같은 경우가 되며,
이를 통해 테이블의 값을 계속 누적시키면서(T[y][x][d] = T[y][x][d] + DFS(ny, nx, i, city_map)) % MOD)
구한 테이블의 값을 T[y][x][d] 반환하도록 해야한다.
(누적시킬 때 사용한 식은 (ny, nx)로부터 (y, x)로 온 경로의 수라고 볼 수 있다.)

최종적으로는 T[0][0][0]에 저장된 값이 우리가 구하고자 하는 정답이 되므로, 이를 반환하면 된다.

(DFS는 M과 N의 크기가 늘어나면 그 연산 횟수가 기하급수적으로 늘어나기 때문에
메모이제이션을 사용하지 않으면 시간초과에 걸리게 되므로, 메모이제이션을 잘 활용해야 한다.)

▶ 후기

사실 처음에는 맵이 주어져있고, M과 N의 최댓값도 500이라는 나름 큰 수로 설정되어 있었기 때문에
아 이거 BFS 문제 아니야? 하고 자연스레 BFS로 구현을 시도했다.....ㄷㄷㄷ

그런데 BFS는 큐에 들어간 순서대로 방문하고, 중간에 누적한 값이 정답에 포함되는 지의 여부도 확실하지 않기 때문에
이 문제에서 원하는 모든 경우의 수를 구할 수가 없었다.

결국 1시간 정도 삽질만 했고, 다른 방법도 생각이 나지 않아서 카카오에서 제공한 해설을 참고했다.
해설을 보니 이 문제는 BFS 문제가 아니라... DP문제였다 ㅎㅎㅎ.. (설명되어 있는 방법은 bottom-up 방식이었다.)

생각해보면 DP 문제라는 점을 바로 알아차릴 법도 한데,
아무런 의심없이 맵과 제한 조건을 보고 BFS라고 생각한 내가 너무 바보같았다 ㅜ.ㅜ...

그래도 다시 풀면서, 아 이렇게 접근할 수도 있구나하며 깨달은 것도 많고,
top-down으로도 구현해보면서 익숙하지 않았던 메모이제이션 기법도 제대로 짚고 넘어갈 수 있었기에
문제의 정답 여부와는 별개로 기분은 좋았다 ^_^

*/

// BOTTOM-UP
#include <vector>

using namespace std;

// 전역 변수를 정의할 경우 함수 내에 초기화 코드를 꼭 작성해주세요.
int solution(int m, int n, vector<vector<int>> city_map) {
    int answer = 0;
    int MOD = 20170805;
    
    int H[510][510] = {0, }; // H[i][j]: i행 j열에서 오른쪽으로 갈 수 있는 경우의 수
    int V[510][510] = {0, }; // V[i][j]: i행 j열에서 아래쪽으로 갈 수 있는 경우의 수
    H[1][1] = V[1][1] = 1;
    
    for(int i=1; i<=m; i++) {
        for(int j=1; j<=n; j++) {
            if(i == 1 && j == 1) continue;
            
            if(city_map[i-1][j-1] == 0) {
                H[i][j] = (H[i][j-1] + V[i-1][j]) % MOD;
                V[i][j] = (H[i][j-1] + V[i-1][j]) % MOD;
            }
            else if(city_map[i-1][j-1] == 1) {
                H[i][j] = 0;
                V[i][j] = 0;
            }
            else {
                H[i][j] = H[i][j-1];
                V[i][j] = V[i-1][j];
            }
        }
    }
    
    return H[m][n];
}

/*

// TOP-DOWN
#include <vector>

using namespace std;

const int MAX = 500 + 10;

int MOD = 20170805;
int M, N;
int T[MAX][MAX][2];

int dy[] = {0, 1};
int dx[] = {1, 0};

int DFS(int y, int x, int d, vector<vector<int>>& city_map) {
    if(y == M-1 && x == N-1) return 1;
    
    if(T[y][x][d] != -1) return T[y][x][d];

    T[y][x][d] = 0;
    
    for (int i=0; i<2; i++) {
        if(city_map[y][x] == 2 && i != d) continue;
        
        int ny = y + dy[i];
        int nx = x + dx[i];
        
        if(ny < 0 || ny > M-1 || nx < 0 || nx > N-1) continue;
        
        if(city_map[ny][nx] != 1)
            T[y][x][d] = (T[y][x][d] + DFS(ny, nx, i, city_map)) % MOD;
    }
    return T[y][x][d];
}

// 전역 변수를 정의할 경우 함수 내에 초기화 코드를 꼭 작성해주세요.
int solution(int m, int n, vector<vector<int>> city_map)
{
    int answer = 0;
    M = m;
    N = n;
    
    for(int i=0; i<m; i++) {
        for(int j=0; j<n; j++) {
            T[i][j][0] = T[i][j][1] = -1;
        }
    }
    
    answer = DFS(0, 0, 0, city_map);

    return answer;
}

*/